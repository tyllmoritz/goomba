; generated by Norcroft  Thumb C vsn 1.20 (ARM Ltd SDT2.50) [Build number 80]


|x$codeseg| DATA

;;;1      /*
;;;2      	gba_nds_fat.c
;;;3      	By chishm (Michael Chisholm)
;;;4      
;;;5      	Routines for reading a compact flash card
;;;6      	using the GBA Movie Player or M3.
;;;7      
;;;8      	Some FAT routines are based on those in fat.c, which
;;;9      	is part of avrlib by Pascal Stang.
;;;10     
;;;11     	This software is completely free. No warranty is provided.
;;;12     	If you use it, please give me credit and email me about your
;;;13     	project at chishm@hotmail.com
;;;14     
;;;15     	See gba_nds_fat.txt for help and license details.
;;;16     */
;;;17     
;;;18     //---------------------------------------------------------------
;;;19     // Includes
;;;20     
;;;21     #include "gba_nds_fat.h"
;;;22     #include <string.h>
;;;23     //----------------------------------------------------------------
;;;24     // Data	types
;;;25     #ifndef	NULL
;;;26      #define	NULL	0
;;;27     #endif
;;;28     
;;;29     #define JUNK 0
;;;30     
;;;31     //-----------------------------------------------------------------
;;;32     // FAT constants
;;;33     #define CLUSTER_EOF_16	0xFFFF
;;;34     #define	CLUSTER_EOF	0x0FFFFFFF
;;;35     #define CLUSTER_FREE	0x0000
;;;36     #define CLUSTER_FIRST	0x0002
;;;37     
;;;38     #define FILE_LAST 0x00
;;;39     #define FILE_FREE 0xE5
;;;40     
;;;41     #define ATTRIB_ARCH	0x20
;;;42     #define ATTRIB_DIR	0x10
;;;43     #define ATTRIB_LFN	0x0F
;;;44     #define ATTRIB_VOL	0x08
;;;45     #define ATTRIB_HID	0x02
;;;46     #define ATTRIB_SYS	0x04
;;;47     #define ATTRIB_RO	0x01
;;;48     
;;;49     #define FAT16_ROOT_DIR_CLUSTER 0x00
;;;50     
;;;51     
;;;52     //-----------------------------------------------------------------
;;;53     // long file name constants
;;;54     #define LFN_END 0x40
;;;55     #define LFN_DEL 0x80
;;;56     
;;;57     //---------------------------------------------------------------
;;;58     // CF Addresses & Commands
;;;59     
;;;60     #define GAME_PAK		0x08000000			// Game pack start address
;;;61     
;;;62     // GBAMP CF Addresses
;;;63     #define MP_REG_STS		*(vu16*)(GAME_PAK + 0x018C0000)	// Status of the CF Card / Device control
;;;64     #define MP_REG_CMD		*(vu16*)(GAME_PAK + 0x010E0000)	// Commands sent to control chip and status return
;;;65     #define MP_REG_ERR		*(vu16*)(GAME_PAK + 0x01020000)	// Errors / Features
;;;66     
;;;67     #define MP_REG_SEC		*(vu16*)(GAME_PAK + 0x01040000)	// Number of sector to transfer
;;;68     #define MP_REG_LBA1		*(vu16*)(GAME_PAK + 0x01060000)	// 1st byte of sector address
;;;69     #define MP_REG_LBA2		*(vu16*)(GAME_PAK + 0x01080000)	// 2nd byte of sector address
;;;70     #define MP_REG_LBA3		*(vu16*)(GAME_PAK + 0x010A0000)	// 3rd byte of sector address
;;;71     #define MP_REG_LBA4		*(vu16*)(GAME_PAK + 0x010C0000)	// last nibble of sector address | 0xE0
;;;72     
;;;73     #define MP_DATA			(vu16*)(GAME_PAK + 0x01000000)		// Pointer to buffer of CF data transered from card
;;;74     
;;;75     // Card status
;;;76     #define CF_STS_INSERTED		0x50
;;;77     #define CF_STS_REMOVED		0x00
;;;78     #define CF_STS_READY		0x58
;;;79     
;;;80     #define CF_STS_DRQ			0x08
;;;81     #define CF_STS_BUSY			0x80
;;;82     
;;;83     // Card commands
;;;84     #define CF_CMD_LBA			0xE0
;;;85     #define CF_CMD_READ			0x20
;;;86     #define CF_CMD_WRITE		0x30
;;;87     
;;;88     #define CARD_TIMEOUT	10000000		// Updated due to suggestion from SaTa, otherwise card will timeout sometimes on a write
;;;89     #define BYTE_PER_READ 512
;;;90     
;;;91     //-----------------------------------------------------------------
;;;92     // Data Structures
;;;93     
;;;94     // Take care of packing for GCC - it doesn't obey pragma pack()
;;;95     // properly for ARM targets.
;;;96     #ifdef __GNUC__
;;;97      #define __PACKED __attribute__ ((__packed__))
;;;98     #else
;;;99      #define __PACKED 
;;;100    // #pragma pack(1)
;;;101    #endif
;;;102    
;;;103    		typedef __packed struct  
;;;104    		{
;;;105    			// Ext BIOS Parameter Block for FAT16
;;;106    			__PACKED	u8	driveNumber;
;;;107    			__PACKED	u8	reserved1;
;;;108    			__PACKED	u8	extBootSig;
;;;109    			__PACKED	u32	volumeID;
;;;110    			__PACKED	u8	volumeLabel[11];
;;;111    			__PACKED	u8	fileSysType[8];
;;;112    			// Bootcode
;;;113    			__PACKED	u8	bootCode[448];
;;;114    		}	fat16_t;
;;;115    		typedef __packed struct  
;;;116    		{
;;;117    			// FAT32 extended block
;;;118    			__PACKED	u32	sectorsPerFAT32;
;;;119    			__PACKED	u16	extFlags;
;;;120    			__PACKED	u16	fsVer;
;;;121    			__PACKED	u32	rootClus;
;;;122    			__PACKED	u16	fsInfo;
;;;123    			__PACKED	u16	bkBootSec;
;;;124    			__PACKED	u8	reserved[12];
;;;125    			// Ext BIOS Parameter Block for FAT16
;;;126    			__PACKED	u8	driveNumber;
;;;127    			__PACKED	u8	reserved1;
;;;128    			__PACKED	u8	extBootSig;
;;;129    			__PACKED	u32	volumeID;
;;;130    			__PACKED	u8	volumeLabel[11];
;;;131    			__PACKED	u8	fileSysType[8];
;;;132    			// Bootcode
;;;133    			__PACKED	u8	bootCode[420];
;;;134    		}	fat32_t;
;;;135    
;;;136    	typedef __packed union	// Different types of extended BIOS Parameter Block for FAT16 and FAT32
;;;137    	{
;;;138    		__PACKED	fat16_t fat16;
;;;139    		__PACKED	fat32_t fat32;
;;;140    	}	extBlock_t;
;;;141    
;;;142    
;;;143    // Boot Sector - must be packed
;;;144    typedef __packed struct
;;;145    {
;;;146    	__PACKED	u8	jmpBoot[3];
;;;147    	__PACKED	u8	OEMName[8];
;;;148    	// BIOS Parameter Block
;;;149    	__PACKED	u16	bytesPerSector;
;;;150    	__PACKED	u8	sectorsPerCluster;
;;;151    	__PACKED	u16	reservedSectors;
;;;152    	__PACKED	u8	numFATs;
;;;153    	__PACKED	u16	rootEntries;
;;;154    	__PACKED	u16	numSectorsSmall;
;;;155    	__PACKED	u8	mediaDesc;
;;;156    	__PACKED	u16	sectorsPerFAT;
;;;157    	__PACKED	u16	sectorsPerTrk;
;;;158    	__PACKED	u16	numHeads;
;;;159    	__PACKED	u32	numHiddenSectors;
;;;160    	__PACKED	u32	numSectors;
;;;161    	__PACKED	extBlock_t extBlock;
;;;162    	__PACKED	u16	bootSig;
;;;163    
;;;164    }	BOOT_SEC;
;;;165    
;;;166    
;;;167    // Directory entry - must be packed
;;;168    typedef __packed struct
;;;169    {
;;;170    	__PACKED	u8	name[8];
;;;171    	__PACKED	u8	ext[3];
;;;172    	__PACKED	u8	attrib;
;;;173    	__PACKED	u8	reserved;
;;;174    	__PACKED	u8	cTime_ms;
;;;175    	__PACKED	u16	cTime;
;;;176    	__PACKED	u16	cDate;
;;;177    	__PACKED	u16	aDate;
;;;178    	__PACKED	u16	startClusterHigh;
;;;179    	__PACKED	u16	mTime;
;;;180    	__PACKED	u16	mDate;
;;;181    	__PACKED	u16	startCluster;
;;;182    	__PACKED	u32	fileSize;
;;;183    }	DIR_ENT;
;;;184    
;;;185    // Long file name directory entry - must be packed
;;;186    typedef __packed struct
;;;187    {
;;;188      	__PACKED	u8 ordinal;	// Position within LFN
;;;189      	__PACKED	u16 char0;	
;;;190      	__PACKED	u16 char1;
;;;191      	__PACKED	u16 char2;
;;;192      	__PACKED	u16 char3;
;;;193      	__PACKED	u16 char4;
;;;194     	__PACKED	u8 flag;	// Should be equal to ATTRIB_LFN
;;;195     	__PACKED	u8 reserved1;	// Always 0x00
;;;196     	__PACKED	u8 checkSum;	// Checksum of short file name (alias)
;;;197      	__PACKED	u16 char5;
;;;198      	__PACKED	u16 char6;
;;;199      	__PACKED	u16 char7;
;;;200      	__PACKED	u16 char8;
;;;201      	__PACKED	u16 char9;
;;;202      	__PACKED	u16 char10;
;;;203      	__PACKED	u16 reserved2;	// Always 0x0000
;;;204      	__PACKED	u16 char11;
;;;205      	__PACKED	u16 char12;
;;;206    }	DIR_ENT_LFN;
;;;207    
;;;208    const char lfn_offset_table[13]={0x01,0x03,0x05,0x07,0x09,0x0E,0x10,0x12,0x14,0x16,0x18,0x1C,0x1E};
;;;209    
;;;210    
;;;211    // End of packed structs
;;;212    #ifdef __PACKED
;;;213     #undef __PACKED
;;;214    #endif
;;;215    #ifndef __GNUC__
;;;216     #undef __PACKED
;;;217    #endif
;;;218    
;;;219    //-----------------------------------------------------------------
;;;220    // Global Variables
;;;221    
;;;222    // Files
;;;223    extern FAT_FILE openFiles[MAX_FILES_OPEN];
;;;224    
;;;225    // Long File names
;;;226    extern char lfnName[MAX_FILENAME_LENGTH];
;;;227    bool lfnExists;
;;;228    
;;;229    // Locations on card
;;;230    int filesysRootDir;
;;;231    int filesysRootDirClus;
;;;232    int filesysFAT;
;;;233    int filesysSecPerFAT;
;;;234    int filesysNumSec;
;;;235    int filesysData;
;;;236    int filesysBytePerSec;
;;;237    int filesysSecPerClus;
;;;238    int filesysBytePerClus;
;;;239    
;;;240    enum {FS_UNKNOWN, FS_FAT12, FS_FAT16, FS_FAT32} filesysType = FS_UNKNOWN;
;;;241    
;;;242    // Info about FAT
;;;243    u32 fatLastCluster;
;;;244    u32 fatFirstFree;
;;;245    
;;;246    // fatBuffer used to reduce wear on the CF card from multiple writes
;;;247    extern char fatBuffer[BYTE_PER_READ];
;;;248    u32 fatBufferCurSector;
;;;249    
;;;250    // Current working directory
;;;251    u32 curWorkDirCluster;
;;;252    
;;;253    // Position of the directory entry last retreived with FAT_GetDirEntry
;;;254    u32 wrkDirCluster;
;;;255    int wrkDirSector;
;;;256    int wrkDirOffset;
;;;257    
;;;258    // Global sector buffer to save on stack space
;;;259    extern unsigned char globalBuffer[BYTE_PER_READ];
;;;260    
;;;261    //-----------------------------------------------------------------
;;;262    // Functions contained in this file - predeclarations
;;;263    char ucase (char character);
;;;264    //u16 getRTCtoFileTime (void);
;;;265    //u16 getRTCtoFileDate (void);
;;;266    
;;;267    bool FAT_AddDirEntry (const char* path, DIR_ENT newDirEntry);
;;;268    bool FAT_ClearLinks (u32 cluster);
;;;269    DIR_ENT FAT_DirEntFromPath (const char* path);
;;;270    u32 FAT_FirstFreeCluster(void);
;;;271    DIR_ENT FAT_GetDirEntry ( u32 dirCluster, int entry, int origin);
;;;272    u32 FAT_LinkFreeCluster(u32 cluster);
;;;273    u32 FAT_NextCluster(u32 cluster);
;;;274    bool FAT_WriteFatEntry (u32 cluster, u32 value);
;;;275    bool FAT_GetFilename (DIR_ENT dirEntry, char* alias);
;;;276    
;;;277    bool FAT_InitFiles (void);
;;;278    bool FAT_FreeFiles (void);
;;;279    int FAT_remove (const char* path);
;;;280    bool FAT_chdir (const char* path);
;;;281    FILE_TYPE FAT_FindFirstFile (char* filename);
;;;282    FILE_TYPE FAT_FindNextFile (char* filename);
;;;283    FILE_TYPE FAT_FileExists (const char* filename);
;;;284    bool FAT_GetAlias (char* alias);
;;;285    bool FAT_GetLongFilename (char* filename);
;;;286    u32 FAT_GetFileSize (void);
;;;287    u32 FAT_GetFileCluster (void);
;;;288    
;;;289    FAT_FILE* FAT_fopen(const char* path, const char* mode);
;;;290    bool FAT_fclose (FAT_FILE* file);
;;;291    bool FAT_feof(FAT_FILE* file);
;;;292    int FAT_fseek(FAT_FILE* file, s32 offset, int origin);
;;;293    u32 FAT_ftell (FAT_FILE* file);
;;;294    u32 FAT_fread (void* buffer, u32 size, u32 count, FAT_FILE* file);
;;;295    u32 FAT_fwrite (const void* buffer, u32 size, u32 count, FAT_FILE* file);
;;;296    char FAT_fgetc (FAT_FILE* file);
;;;297    char FAT_fputc (char c, FAT_FILE* file);
;;;298    
;;;299    
;;;300    /*-----------------------------------------------------------------
;;;301    MPCF_IsInserted
;;;302    Is a compact flash card inserted?
;;;303    bool return OUT:  true if a CF card is inserted
;;;304    -----------------------------------------------------------------*/
;;;305    bool MPCF_IsInserted (void) 
;;;306    {
;;;307    	// Change register, then check if value did change
;;;308    	MP_REG_STS = CF_STS_INSERTED;
000000                      MPCF_IsInserted
000000  4904                        LDR      r1,F1L1
000002  2050                        MOV      r0,#&50
000004  8008                        STRH     r0,[r1,#0]
;;;309    	return (MP_REG_STS == CF_STS_INSERTED);
000006  8809                        LDRH     r1,[r1,#0]
000008  2001                        MOV      r0,#1
00000a  2950                        CMP      r1,#&50
00000c  d000                        BEQ      F1L11
00000e  2000                        MOV      r0,#0
                            F1L11
000010  4770                        BX       lr
000012  0000                        LSL      r0,#0
                            F1L1
000014  098c0000                    DCD      0x098c0000

;;;310    }
;;;311    
;;;312    
;;;313    /*-----------------------------------------------------------------
;;;314    MPCF_ClearStatus
;;;315    Tries to make the CF card go back to idle mode
;;;316    bool return OUT:  true if a CF card is idle
;;;317    -----------------------------------------------------------------*/
;;;318    bool MPCF_ClearStatus (void) 
;;;319    {
000018                      MPCF_ClearStatus
000018  b480                        PUSH     {r7}
;;;320    	int i;
;;;321    	
;;;322    	// Wait until CF card is finished previous commands
;;;323    	i=0;
00001a  2000                        MOV      r0,#0
00001c  490d                        LDR      r1,F2L1
00001e  4a0e                        LDR      r2,F2L1+4
000020  e000                        B        F2L22
                            F2L4
;;;324    	while ((MP_REG_CMD & CF_STS_BUSY) && (i < CARD_TIMEOUT))
;;;325    	{
;;;326    		i++;
000022  3001                        ADD      r0,#1
                            F2L22
000024  880f                        LDRH     r7,[r1,#0]   ;;;324
000026  0a3b                        LSR      r3,r7,#8   ;;;324
000028  d301                        BCC      F2L23   ;;;324
00002a  4290                        CMP      r0,r2   ;;;324
00002c  dbf9                        BLT      F2L4   ;;;324
                            F2L23
;;;327    	}
;;;328    	
;;;329    	// Wait until card is ready for commands
;;;330    	i = 0;
00002e  2000                        MOV      r0,#0
000030  490a                        LDR      r1,F2L1+8
000032  e000                        B        F2L24
                            F2L9
;;;331    	while ((!(MP_REG_STS & CF_STS_INSERTED)) && (i < CARD_TIMEOUT))
;;;332    	{
;;;333    		i++;
000034  3001                        ADD      r0,#1
                            F2L24
000036  880f                        LDRH     r7,[r1,#0]   ;;;331
000038  2350                        MOV      r3,#&50   ;;;331
00003a  403b                        AND      r3,r7   ;;;331
00003c  d102                        BNE      F2L25   ;;;331
00003e  4290                        CMP      r0,r2   ;;;331
000040  dbf8                        BLT      F2L9   ;;;331
000042  e001                        B        F2L26   ;;;331
                            F2L25
;;;334    	}
;;;335    	if (i >= CARD_TIMEOUT)
000044  4290                        CMP      r0,r2
000046  db02                        BLT      F2L27
                            F2L26
;;;336    		return false;
000048  2000                        MOV      r0,#0
                            F2L20
00004a  bc80                        POP      {r7}
00004c  4770                        BX       lr
                            F2L27
;;;337    
;;;338    	return true;
00004e  2001                        MOV      r0,#1
000050  e7fb                        B        F2L20
000052  0000                        LSL      r0,#0
                            F2L1
000054  090e0000                    DCD      0x090e0000
000058  00989680                    DCD      0x00989680
00005c  098c0000                    DCD      0x098c0000

;;;339    }
;;;340    
;;;341    
;;;342    /*-----------------------------------------------------------------
;;;343    MPCF_ReadSectors
;;;344    Read 512 byte sector numbered "sector" into "buffer"
;;;345    u32 sector IN: address of first 512 byte sector on CF card to read
;;;346    u8 numSecs IN: number of 512 byte sectors to read,
;;;347     1 to 256 sectors can be read, 0 = 256
;;;348    void* buffer OUT: pointer to 512 byte buffer to store data in
;;;349    bool return OUT: true if successful
;;;350    -----------------------------------------------------------------*/
;;;351    bool MPCF_ReadSectors (u32 sector, u8 numSecs, void* buffer)
;;;352    {
000060                      MPCF_ReadSectors
000060  b4f0                        PUSH     {r4-r7}
;;;353    	int i;
;;;354    	int j = (numSecs > 0 ? numSecs : 256);
000062  25ff                        MOV      r5,#&ff
000064  3501                        ADD      r5,#1
000066  2900                        CMP      r1,#0
000068  dd00                        BLE      F3L41
00006a  1c0d                        MOV      r5,r1
                            F3L41
;;;355    	u16 *buff = (u16*)buffer;
;;;356    #ifdef _CF_ALLOW_UNALIGNED
;;;357    	u8 *buff_u8 = (u8*)buffer;
;;;358    	int temp;
;;;359    #endif
;;;360    
;;;361    #if (defined _CF_USE_DMA) && (defined NDS) && (defined ARM9)
;;;362    	DC_FlushRange( buffer, j * BYTE_PER_READ);
;;;363    #endif
;;;364    
;;;365    	// Wait until CF card is finished previous commands
;;;366    	i=0;
00006c  1c17                        MOV      r7,r2
00006e  2200                        MOV      r2,#0
000070  4e29                        LDR      r6,F3L1
000072  e000                        B        F3L42
                            F3L7
;;;367    	while ((MP_REG_CMD & CF_STS_BUSY) && (i < CARD_TIMEOUT))
;;;368    	{
;;;369    		i++;
000074  3201                        ADD      r2,#1
                            F3L42
000076  4b29                        LDR      r3,F3L1+4   ;;;367
000078  881c                        LDRH     r4,[r3,#0]   ;;;367
00007a  0a23                        LSR      r3,r4,#8   ;;;367
00007c  d301                        BCC      F3L43   ;;;367
00007e  42b2                        CMP      r2,r6   ;;;367
000080  dbf8                        BLT      F3L7   ;;;367
                            F3L43
;;;370    	}
;;;371    	
;;;372    	// Wait until card is ready for commands
;;;373    	i = 0;
000082  2200                        MOV      r2,#0
000084  4c26                        LDR      r4,F3L1+8
000086  e000                        B        F3L44
                            F3L12
;;;374    	while ((!(MP_REG_STS & CF_STS_INSERTED)) && (i < CARD_TIMEOUT))
;;;375    	{
;;;376    		i++;
000088  3201                        ADD      r2,#1
                            F3L44
00008a  8826                        LDRH     r6,[r4,#0]   ;;;374
00008c  2350                        MOV      r3,#&50   ;;;374
00008e  4033                        AND      r3,r6   ;;;374
000090  d103                        BNE      F3L45   ;;;374
000092  4b21                        LDR      r3,F3L1   ;;;374
000094  429a                        CMP      r2,r3   ;;;374
000096  dbf7                        BLT      F3L12   ;;;374
000098  e02a                        B        F3L46   ;;;374
                            F3L45
;;;377    	}
;;;378    	if (i >= CARD_TIMEOUT)
00009a  4e1f                        LDR      r6,F3L1
00009c  42b2                        CMP      r2,r6
00009e  da27                        BGE      F3L46
;;;379    		return false;
;;;380    	
;;;381    	// Set number of sectors to read
;;;382    	MP_REG_SEC = numSecs;	
0000a0  4a20                        LDR      r2,F3L1+12
0000a2  8011                        STRH     r1,[r2,#0]
;;;383    	
;;;384    	// Set read sector
;;;385    	MP_REG_LBA1 = sector & 0xFF;						// 1st byte of sector number
0000a4  0601                        LSL      r1,r0,#24
0000a6  4a20                        LDR      r2,F3L1+16
0000a8  0e09                        LSR      r1,#24
0000aa  8011                        STRH     r1,[r2,#0]
;;;386    	MP_REG_LBA2 = (sector >> 8) & 0xFF;					// 2nd byte of sector number
0000ac  0a01                        LSR      r1,r0,#8
0000ae  0609                        LSL      r1,#24
0000b0  4a1e                        LDR      r2,F3L1+20
0000b2  0e09                        LSR      r1,#24
0000b4  8011                        STRH     r1,[r2,#0]
;;;387    	MP_REG_LBA3 = (sector >> 16) & 0xFF;				// 3rd byte of sector number
0000b6  0c01                        LSR      r1,r0,#16
0000b8  0609                        LSL      r1,#24
0000ba  0e09                        LSR      r1,#24
;;;388    	MP_REG_LBA4 = ((sector >> 24) & 0x0F )| CF_CMD_LBA;	// last nibble of sector number
0000bc  0e00                        LSR      r0,#24
0000be  0700                        LSL      r0,#28
0000c0  4a1b                        LDR      r2,F3L1+24   ;;;387
0000c2  0f00                        LSR      r0,#28
0000c4  23e0                        MOV      r3,#&e0
0000c6  8011                        STRH     r1,[r2,#0]   ;;;387
0000c8  491a                        LDR      r1,F3L1+28
0000ca  4318                        ORR      r0,r3
0000cc  8008                        STRH     r0,[r1,#0]
;;;389    	
;;;390    	// Set command to read
;;;391    	MP_REG_CMD = CF_CMD_READ;
0000ce  2020                        MOV      r0,#&20
0000d0  4b12                        LDR      r3,F3L1+4
0000d2  2109                        MOV      r1,#9
0000d4  0609                        LSL      r1,#24
0000d6  8018                        STRH     r0,[r3,#0]
0000d8  e017                        B        F3L47
                            F3L19
;;;392    	
;;;393    	
;;;394    	while (j--)
;;;395    	{
;;;396    		// Wait until card is ready for reading
;;;397    		i = 0;
0000da  2000                        MOV      r0,#0
0000dc  e000                        B        F3L48
                            F3L21
;;;398    		while ((MP_REG_STS != CF_STS_READY) && (i < CARD_TIMEOUT))
;;;399    		{
;;;400    			i++;
0000de  3001                        ADD      r0,#1
                            F3L48
0000e0  8822                        LDRH     r2,[r4,#0]   ;;;398
0000e2  2a58                        CMP      r2,#&58   ;;;398
0000e4  d002                        BEQ      F3L49   ;;;398
0000e6  42b0                        CMP      r0,r6   ;;;398
0000e8  dbf9                        BLT      F3L21   ;;;398
0000ea  e001                        B        F3L50   ;;;398
                            F3L49
;;;401    		}
;;;402    		if (i >= CARD_TIMEOUT)
0000ec  42b0                        CMP      r0,r6
0000ee  db02                        BLT      F3L51
                            F3L46
                            F3L50
;;;403    			return false;
0000f0  2000                        MOV      r0,#0
                            F3L39
0000f2  bcf0                        POP      {r4-r7}
0000f4  4770                        BX       lr
                            F3L51
;;;404    		
;;;405    		// Read data
;;;406    #ifdef _CF_USE_DMA
;;;407     #ifdef NDS
;;;408    		DMA3_SRC = (u32)MP_DATA;
;;;409    		DMA3_DEST = (u32)buff;
;;;410    		DMA3_CR = 256 | DMA_COPY_HALFWORDS | DMA_SRC_FIX;
;;;411     #else
;;;412    		DMA3COPY ( MP_DATA, buff, 256 | DMA16 | DMA_ENABLE | DMA_SRC_FIXED);
;;;413     #endif
;;;414    		buff += BYTE_PER_READ / 2;
;;;415    #elif defined _CF_ALLOW_UNALIGNED
;;;416    		i=256;
;;;417    		if ((u32)buff_u8 & 0x01) {
;;;418    			while(i--)
;;;419    			{
;;;420    				temp = *MP_DATA;
;;;421    				*buff_u8++ = temp & 0xFF;
;;;422    				*buff_u8++ = temp >> 8;
;;;423    			}
;;;424    		} else {
;;;425    		while(i--)
;;;426    			*buff++ = *MP_DATA; 
;;;427    		}
;;;428    #else
;;;429    		i=256;
0000f6  20ff                        MOV      r0,#&ff
0000f8  3001                        ADD      r0,#1
0000fa  e002                        B        F3L52
                            F3L28
;;;430    		while(i--)
;;;431    			*buff++ = *MP_DATA; 
0000fc  880a                        LDRH     r2,[r1,#0]
0000fe  803a                        STRH     r2,[r7,#0]
000100  3702                        ADD      r7,#2
                            F3L52
000102  1c02                        MOV      r2,r0   ;;;430
000104  3801                        SUB      r0,#1   ;;;430
000106  2a00                        CMP      r2,#0   ;;;430
000108  d1f8                        BNE      F3L28   ;;;430
                            F3L47
00010a  1c28                        MOV      r0,r5   ;;;394
00010c  3d01                        SUB      r5,#1   ;;;394
00010e  2800                        CMP      r0,#0   ;;;394
000110  d1e3                        BNE      F3L19   ;;;394
;;;432    #endif
;;;433    	}
;;;434    #if (defined _CF_USE_DMA) && (defined NDS)
;;;435    	// Wait for end of transfer before returning
;;;436    	while(DMA3_CR & DMA_BUSY);
;;;437    #endif
;;;438    	return true;
000112  2001                        MOV      r0,#1
000114  e7ed                        B        F3L39
000116  0000                        LSL      r0,#0
                            F3L1
000118  00989680                    DCD      0x00989680
00011c  090e0000                    DCD      0x090e0000
000120  098c0000                    DCD      0x098c0000
000124  09040000                    DCD      0x09040000
000128  09060000                    DCD      0x09060000
00012c  09080000                    DCD      0x09080000
000130  090a0000                    DCD      0x090a0000
000134  090c0000                    DCD      0x090c0000

;;;439    }
;;;440    
;;;441    
;;;442    
;;;443    /*-----------------------------------------------------------------
;;;444    MPCF_WriteSectors
;;;445    Write 512 byte sector numbered "sector" from "buffer"
;;;446    u32 sector IN: address of 512 byte sector on CF card to read
;;;447    u8 numSecs IN: number of 512 byte sectors to read,
;;;448     1 to 256 sectors can be read, 0 = 256
;;;449    void* buffer IN: pointer to 512 byte buffer to read data from
;;;450    bool return OUT: true if successful
;;;451    -----------------------------------------------------------------*/
;;;452    bool MPCF_WriteSectors (u32 sector, u8 numSecs, void* buffer)
;;;453    {
000138                      MPCF_WriteSectors
000138  b4f0                        PUSH     {r4-r7}
;;;454    	int i;
;;;455    	int j = (numSecs > 0 ? numSecs : 256);
00013a  25ff                        MOV      r5,#&ff
00013c  3501                        ADD      r5,#1
00013e  2900                        CMP      r1,#0
000140  dd00                        BLE      F4L41
000142  1c0d                        MOV      r5,r1
                            F4L41
;;;456    	u16 *buff = (u16*)buffer;
;;;457    #ifdef _CF_ALLOW_UNALIGNED
;;;458    	u8 *buff_u8 = (u8*)buffer;
;;;459    	int temp;
;;;460    #endif
;;;461    	
;;;462    #if defined _CF_USE_DMA && defined NDS && defined ARM9
;;;463    	DC_FlushRange( buffer, j * BYTE_PER_READ);
;;;464    #endif
;;;465    
;;;466    	// Wait until CF card is finished previous commands
;;;467    	i=0;
000144  1c17                        MOV      r7,r2
000146  2200                        MOV      r2,#0
000148  4e29                        LDR      r6,F4L1
00014a  e000                        B        F4L42
                            F4L7
;;;468    	while ((MP_REG_CMD & CF_STS_BUSY) && (i < CARD_TIMEOUT))
;;;469    	{
;;;470    		i++;
00014c  3201                        ADD      r2,#1
                            F4L42
00014e  4b29                        LDR      r3,F4L1+4   ;;;468
000150  881c                        LDRH     r4,[r3,#0]   ;;;468
000152  0a23                        LSR      r3,r4,#8   ;;;468
000154  d301                        BCC      F4L43   ;;;468
000156  42b2                        CMP      r2,r6   ;;;468
000158  dbf8                        BLT      F4L7   ;;;468
                            F4L43
;;;471    	}
;;;472    	
;;;473    	// Wait until card is ready for commands
;;;474    	i = 0;
00015a  2200                        MOV      r2,#0
00015c  4c26                        LDR      r4,F4L1+8
00015e  e000                        B        F4L44
                            F4L12
;;;475    	while ((!(MP_REG_STS & CF_STS_INSERTED)) && (i < CARD_TIMEOUT))
;;;476    	{
;;;477    		i++;
000160  3201                        ADD      r2,#1
                            F4L44
000162  8826                        LDRH     r6,[r4,#0]   ;;;475
000164  2350                        MOV      r3,#&50   ;;;475
000166  4033                        AND      r3,r6   ;;;475
000168  d103                        BNE      F4L45   ;;;475
00016a  4b21                        LDR      r3,F4L1   ;;;475
00016c  429a                        CMP      r2,r3   ;;;475
00016e  dbf7                        BLT      F4L12   ;;;475
000170  e02a                        B        F4L46   ;;;475
                            F4L45
;;;478    	}
;;;479    	if (i >= CARD_TIMEOUT)
000172  4e1f                        LDR      r6,F4L1
000174  42b2                        CMP      r2,r6
000176  da27                        BGE      F4L46
;;;480    		return false;
;;;481    	
;;;482    	// Set number of sectors to write
;;;483    	MP_REG_SEC = numSecs;	
000178  4a20                        LDR      r2,F4L1+12
00017a  8011                        STRH     r1,[r2,#0]
;;;484    	
;;;485    	// Set write sector
;;;486    	MP_REG_LBA1 = sector & 0xFF;						// 1st byte of sector number
00017c  0601                        LSL      r1,r0,#24
00017e  4a20                        LDR      r2,F4L1+16
000180  0e09                        LSR      r1,#24
000182  8011                        STRH     r1,[r2,#0]
;;;487    	MP_REG_LBA2 = (sector >> 8) & 0xFF;					// 2nd byte of sector number
000184  0a01                        LSR      r1,r0,#8
000186  0609                        LSL      r1,#24
000188  4a1e                        LDR      r2,F4L1+20
00018a  0e09                        LSR      r1,#24
00018c  8011                        STRH     r1,[r2,#0]
;;;488    	MP_REG_LBA3 = (sector >> 16) & 0xFF;				// 3rd byte of sector number
00018e  0c01                        LSR      r1,r0,#16
000190  0609                        LSL      r1,#24
000192  0e09                        LSR      r1,#24
;;;489    	MP_REG_LBA4 = ((sector >> 24) & 0x0F )| CF_CMD_LBA;	// last nibble of sector number
000194  0e00                        LSR      r0,#24
000196  0700                        LSL      r0,#28
000198  4a1b                        LDR      r2,F4L1+24   ;;;488
00019a  0f00                        LSR      r0,#28
00019c  23e0                        MOV      r3,#&e0
00019e  8011                        STRH     r1,[r2,#0]   ;;;488
0001a0  491a                        LDR      r1,F4L1+28
0001a2  4318                        ORR      r0,r3
0001a4  8008                        STRH     r0,[r1,#0]
;;;490    	
;;;491    	// Set command to write
;;;492    	MP_REG_CMD = CF_CMD_WRITE;
0001a6  2030                        MOV      r0,#&30
0001a8  4b12                        LDR      r3,F4L1+4
0001aa  2109                        MOV      r1,#9
0001ac  0609                        LSL      r1,#24
0001ae  8018                        STRH     r0,[r3,#0]
0001b0  e017                        B        F4L47
                            F4L19
;;;493    	
;;;494    	while (j--)
;;;495    	{
;;;496    		// Wait until card is ready for writing
;;;497    		i = 0;
0001b2  2000                        MOV      r0,#0
0001b4  e000                        B        F4L48
                            F4L21
;;;498    		while ((MP_REG_STS != CF_STS_READY) && (i < CARD_TIMEOUT))
;;;499    		{
;;;500    			i++;
0001b6  3001                        ADD      r0,#1
                            F4L48
0001b8  8822                        LDRH     r2,[r4,#0]   ;;;498
0001ba  2a58                        CMP      r2,#&58   ;;;498
0001bc  d002                        BEQ      F4L49   ;;;498
0001be  42b0                        CMP      r0,r6   ;;;498
0001c0  dbf9                        BLT      F4L21   ;;;498
0001c2  e001                        B        F4L50   ;;;498
                            F4L49
;;;501    		}
;;;502    		if (i >= CARD_TIMEOUT)
0001c4  42b0                        CMP      r0,r6
0001c6  db02                        BLT      F4L51
                            F4L46
                            F4L50
;;;503    			return false;
0001c8  2000                        MOV      r0,#0
                            F4L39
0001ca  bcf0                        POP      {r4-r7}
0001cc  4770                        BX       lr
                            F4L51
;;;504    		
;;;505    		// Write data
;;;506    #ifdef _CF_USE_DMA
;;;507     #ifdef NDS
;;;508    		DMA3_SRC = (u32)buff;
;;;509    		DMA3_DEST = (u32)MP_DATA;
;;;510    		DMA3_CR = 256 | DMA_COPY_HALFWORDS | DMA_DST_FIX;
;;;511     #else
;;;512    		DMA3COPY( buff, MP_DATA, 256 | DMA16 | DMA_ENABLE | DMA_DST_FIXED);
;;;513     #endif
;;;514    		buff += BYTE_PER_READ / 2;
;;;515    #elif defined _CF_ALLOW_UNALIGNED
;;;516    		i=256;
;;;517    		if ((u32)buff_u8 & 0x01) {
;;;518    			while(i--)
;;;519    			{
;;;520    				temp = *buff_u8++;
;;;521    				temp |= *buff_u8++ << 8;
;;;522    				*MP_DATA = temp;
;;;523    			}
;;;524    		} else {
;;;525    		while(i--)
;;;526    			*MP_DATA = *buff++; 
;;;527    		}
;;;528    #else
;;;529    		i=256;
0001ce  20ff                        MOV      r0,#&ff
0001d0  3001                        ADD      r0,#1
0001d2  e002                        B        F4L52
                            F4L28
;;;530    		while(i--)
;;;531    			*MP_DATA = *buff++; 
0001d4  883a                        LDRH     r2,[r7,#0]
0001d6  3702                        ADD      r7,#2
0001d8  800a                        STRH     r2,[r1,#0]
                            F4L52
0001da  1c02                        MOV      r2,r0   ;;;530
0001dc  3801                        SUB      r0,#1   ;;;530
0001de  2a00                        CMP      r2,#0   ;;;530
0001e0  d1f8                        BNE      F4L28   ;;;530
                            F4L47
0001e2  1c28                        MOV      r0,r5   ;;;494
0001e4  3d01                        SUB      r5,#1   ;;;494
0001e6  2800                        CMP      r0,#0   ;;;494
0001e8  d1e3                        BNE      F4L19   ;;;494
;;;532    #endif
;;;533    	}
;;;534    #if defined _CF_USE_DMA && defined NDS
;;;535    	// Wait for end of transfer before returning
;;;536    	while(DMA3_CR & DMA_BUSY);
;;;537    #endif
;;;538    	
;;;539    	return true;
0001ea  2001                        MOV      r0,#1
0001ec  e7ed                        B        F4L39
0001ee  0000                        LSL      r0,#0
                            F4L1
0001f0  00989680                    DCD      0x00989680
0001f4  090e0000                    DCD      0x090e0000
0001f8  098c0000                    DCD      0x098c0000
0001fc  09040000                    DCD      0x09040000
000200  09060000                    DCD      0x09060000
000204  09080000                    DCD      0x09080000
000208  090a0000                    DCD      0x090a0000
00020c  090c0000                    DCD      0x090c0000

;;;540    }
;;;541    
;;;542    #if JUNK
;;;543    
;;;544    /*-----------------------------------------------------------------
;;;545    CF_LastSector
;;;546    Returns the number of the last sector accessed as an u32
;;;547    Best to use this before using any other reads of CF when first 
;;;548    starting program, to get the last sector where the program is stored
;;;549    u32 return OUT: Address of last read sector
;;;550    -----------------------------------------------------------------*/
;;;551    u32 MPCF_LastSector (void)
;;;552    {
;;;553    	return ( MP_REG_LBA1 + (MP_REG_LBA2 << 8) + (MP_REG_LBA3 << 16) );
;;;554    }
;;;555    #endif
;;;556    
;;;557    bool MPCF_StartUp(void)
;;;558    {
;;;559    	u8 temp = MP_REG_LBA1;
000210                      MPCF_StartUp
000210  4a05                        LDR      r2,F5L1
000212  8810                        LDRH     r0,[r2,#0]
;;;560    	MP_REG_LBA1 = (~temp & 0xFF);
000214  43c0                        MVN      r0,r0
000216  0601                        LSL      r1,r0,#24
000218  0e09                        LSR      r1,#24
00021a  8011                        STRH     r1,[r2,#0]
;;;561    	temp = (~temp & 0xFF);
;;;562    	return (MP_REG_LBA1 == temp) ;
00021c  8812                        LDRH     r2,[r2,#0]
00021e  2001                        MOV      r0,#1
000220  4291                        CMP      r1,r2
000222  d000                        BEQ      F5L11
000224  2000                        MOV      r0,#0
                            F5L11
000226  4770                        BX       lr
                            F5L1
000228  09060000                    DCD      0x09060000

;;;563    }
;;;564    
;;;565    
;;;566    /*-----------------------------------------------------------------
;;;567    ucase
;;;568    Returns the uppercase version of the given char
;;;569    char IN: a character
;;;570    char return OUT: uppercase version of character
;;;571    -----------------------------------------------------------------*/
;;;572    char ucase (char character)
;;;573    {
;;;574    	if ((character > 0x60) && (character < 0x7B))
00022c                      ucase
00022c  1fc1                        SUB      r1,r0,#7
00022e  395a                        SUB      r1,#&5a
000230  291a                        CMP      r1,#&1a
000232  d202                        BCS      F6L12
;;;575    		character = character - 0x20;
000234  3820                        SUB      r0,#&20
000236  0600                        LSL      r0,#24
000238  0e00                        LSR      r0,#24
                            F6L12
00023a  4770                        BX       lr

;;;576    	return (character);
;;;577    }
;;;578    
;;;579    
;;;580    #if JUNK
;;;581    /*-----------------------------------------------------------------
;;;582    getRTCtoFileTime and getRTCtoFileDate
;;;583    Returns the time / date in Dir Entry styled format
;;;584    u16 return OUT: time / date in Dir Entry styled format
;;;585    -----------------------------------------------------------------*/
;;;586    u16 getRTCtoFileTime (void)
;;;587    {
;;;588    #ifdef NDS
;;;589    	return (
;;;590    		( ( (IPC->rtc_hours > 11 ? IPC->rtc_hours - 40 : IPC->rtc_hours) & 0x1F) << 11) |
;;;591    		( (IPC->rtc_minutes & 0x3F) << 5) |
;;;592    		( (IPC->rtc_seconds >> 1) & 0x1F) );
;;;593    #else
;;;594    	return 0;
;;;595    #endif
;;;596    }
;;;597    
;;;598    u16 getRTCtoFileDate (void)
;;;599    {
;;;600    #ifdef NDS
;;;601    	return ( 
;;;602    		( ((IPC->rtc_year + 20) & 0x7F) <<9) |
;;;603    		( (IPC->rtc_month & 0xF) << 5) |
;;;604    		(IPC->rtc_day & 0x1F) );
;;;605    #else
;;;606    	return 0;
;;;607    #endif
;;;608    }
;;;609    #endif
;;;610    
;;;611    /*-----------------------------------------------------------------
;;;612    Disc level FAT routines
;;;613    -----------------------------------------------------------------*/
;;;614    #define FAT_ClustToSect(m) \
;;;615    	(((m-2) * filesysSecPerClus) + filesysData)
;;;616    
;;;617    /*-----------------------------------------------------------------
;;;618    FAT_NextCluster
;;;619    Internal function - gets the cluster linked from input cluster
;;;620    -----------------------------------------------------------------*/
;;;621    u32 FAT_NextCluster(u32 cluster)
;;;622    {
00023c                      FAT_NextCluster
00023c  b5f0                        PUSH     {r4-r7,lr}
;;;623    	u32 nextCluster = CLUSTER_FREE;
;;;624    	u32 sector;
;;;625    	int offset;
;;;626    	
;;;627    	switch (filesysType) 
00023e  4d34                        LDR      r5,F7L1
000240  1c07                        MOV      r7,r0   ;;;623
000242  1de9                        ADD      r1,r5,#7
000244  3119                        ADD      r1,#&19
000246  7a09                        LDRB     r1,[r1,#8]
000248  2000                        MOV      r0,#0   ;;;623
00024a  2900                        CMP      r1,#0
00024c  d01c                        BEQ      F7L35
00024e  4e31                        LDR      r6,F7L1+4
000250  2901                        CMP      r1,#1
000252  d01c                        BEQ      F7L36
000254  2902                        CMP      r1,#2
000256  d046                        BEQ      F7L37
000258  2903                        CMP      r1,#3
00025a  d115                        BNE      F7L38
;;;628    	{
;;;629    		case FS_UNKNOWN:
;;;630    			nextCluster = CLUSTER_FREE;
;;;631    			break;
;;;632    			
;;;633    		case FS_FAT12:
;;;634    			sector = filesysFAT + (((cluster * 3) / 2) / BYTE_PER_READ);
;;;635    			offset = ((cluster * 3) / 2) % BYTE_PER_READ;
;;;636    
;;;637    			// If FAT buffer contains wrong sector
;;;638    			if (sector != fatBufferCurSector)
;;;639    			{
;;;640    				// Load correct sector to buffer
;;;641    				fatBufferCurSector = sector;
;;;642    				disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;643    			}
;;;644    
;;;645    			nextCluster = ((u8*)fatBuffer)[offset];
;;;646    			offset++;
;;;647    			
;;;648    			if (offset >= BYTE_PER_READ) {
;;;649    				offset = 0;
;;;650    				fatBufferCurSector++;
;;;651    				disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;652    			}
;;;653    			
;;;654    			nextCluster |= (((u8*)fatBuffer)[offset]) << 8;
;;;655    			
;;;656    			if (cluster & 0x01) {
;;;657    				nextCluster = nextCluster >> 4;
;;;658    			} else 	{
;;;659    				nextCluster &= 0x0FFF;
;;;660    			}
;;;661    			
;;;662    			if (nextCluster >= 0x0FF7)
;;;663    			{
;;;664    				nextCluster = CLUSTER_EOF;
;;;665    			}
;;;666    
;;;667    			break;
;;;668    			
;;;669    		case FS_FAT16:
;;;670    			sector = filesysFAT + ((cluster << 1) / BYTE_PER_READ);
;;;671    			offset = cluster % (BYTE_PER_READ >> 1);
;;;672    			
;;;673    			// If FAT buffer contains wrong sector
;;;674    			if (sector != fatBufferCurSector)
;;;675    			{
;;;676    				// Load correct sector to buffer
;;;677    				fatBufferCurSector = sector;
;;;678    				disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;679    			}
;;;680    
;;;681    			// read the nextCluster value
;;;682    			nextCluster = ((u16*)fatBuffer)[offset];
;;;683    			
;;;684    			if (nextCluster >= 0xFFF7)
;;;685    			{
;;;686    				nextCluster = CLUSTER_EOF;
;;;687    			}
;;;688    			break;
;;;689    			
;;;690    		case FS_FAT32:
;;;691    			sector = filesysFAT + ((cluster << 2) / BYTE_PER_READ);
00025c  00b8                        LSL      r0,r7,#2
00025e  68e9                        LDR      r1,[r5,#&c]
000260  0a40                        LSR      r0,#9
000262  1840                        ADD      r0,r1
;;;692    			offset = cluster % (BYTE_PER_READ >> 2);
000264  067f                        LSL      r7,#25
;;;693    			
;;;694    			// If FAT buffer contains wrong sector
;;;695    			if (sector != fatBufferCurSector)
000266  6b69                        LDR      r1,[r5,#&34]
000268  0e7f                        LSR      r7,#25   ;;;692
00026a  4288                        CMP      r0,r1
00026c  d004                        BEQ      F7L39
;;;696    			{
;;;697    				// Load correct sector to buffer
;;;698    				fatBufferCurSector = sector;
;;;699    				disc_ReadSector(fatBufferCurSector, fatBuffer);
00026e  2101                        MOV      r1,#1
000270  1c32                        MOV      r2,r6
000272  6368                        STR      r0,[r5,#&34]
000274  f7ff fef4                   BL       MPCF_ReadSectors
                            F7L39
;;;700    			}
;;;701    
;;;702    			// read the nextCluster value
;;;703    			nextCluster = (((u32*)fatBuffer)[offset]) & 0x0FFFFFFF;
000278  00b8                        LSL      r0,r7,#2
00027a  5830                        LDR      r0,[r6,r0]
;;;704    			
;;;705    			if (nextCluster >= 0x0FFFFFF7)
00027c  4b26                        LDR      r3,F7L1+8
00027e  0100                        LSL      r0,#4   ;;;703
000280  0900                        LSR      r0,#4   ;;;703
000282  4298                        CMP      r0,r3
000284  d300                        BCC      F7L40
                            F7L30
;;;706    			{
;;;707    				nextCluster = CLUSTER_EOF;
000286  4825                        LDR      r0,F7L1+12
                            F7L35
                            F7L38
                            F7L40
                            F7L33
000288  bcf0                        POP      {r4-r7}
00028a  bc08                        POP      {r3}
00028c  4718                        BX       r3
                            F7L36
00028e  0079                        LSL      r1,r7,#1   ;;;634
000290  19c9                        ADD      r1,r7   ;;;634
000292  68ea                        LDR      r2,[r5,#&c]   ;;;634
000294  0a88                        LSR      r0,r1,#10   ;;;634
000296  1880                        ADD      r0,r2   ;;;634
000298  0849                        LSR      r1,#1   ;;;635
00029a  05cc                        LSL      r4,r1,#23   ;;;635
00029c  6b69                        LDR      r1,[r5,#&34]   ;;;638
00029e  0de4                        LSR      r4,#23   ;;;635
0002a0  4288                        CMP      r0,r1   ;;;638
0002a2  d004                        BEQ      F7L41   ;;;638
0002a4  2101                        MOV      r1,#1   ;;;642
0002a6  1c32                        MOV      r2,r6   ;;;642
0002a8  6368                        STR      r0,[r5,#&34]   ;;;642
0002aa  f7ff fed9                   BL       MPCF_ReadSectors   ;;;642
                            F7L41
0002ae  4a19                        LDR      r2,F7L1+4   ;;;645
0002b0  2301                        MOV      r3,#1   ;;;648
0002b2  025b                        LSL      r3,#9   ;;;648
0002b4  5d16                        LDRB     r6,[r2,r4]   ;;;645
0002b6  3401                        ADD      r4,#1   ;;;648
0002b8  429c                        CMP      r4,r3   ;;;648
0002ba  db06                        BLT      F7L42   ;;;648
0002bc  6b68                        LDR      r0,[r5,#&34]   ;;;650
0002be  2400                        MOV      r4,#0   ;;;649
0002c0  3001                        ADD      r0,#1   ;;;650
0002c2  6368                        STR      r0,[r5,#&34]   ;;;651
0002c4  2101                        MOV      r1,#1   ;;;651
0002c6  f7ff fecb                   BL       MPCF_ReadSectors   ;;;651
                            F7L42
0002ca  4a12                        LDR      r2,F7L1+4   ;;;654
0002cc  5d10                        LDRB     r0,[r2,r4]   ;;;654
0002ce  0200                        LSL      r0,#8   ;;;654
0002d0  4330                        ORR      r0,r6   ;;;654
0002d2  0879                        LSR      r1,r7,#1   ;;;656
0002d4  d301                        BCC      F7L43   ;;;656
0002d6  0900                        LSR      r0,#4   ;;;657
0002d8  e001                        B        F7L44   ;;;657
                            F7L43
0002da  0500                        LSL      r0,#20   ;;;659
0002dc  0d00                        LSR      r0,#20   ;;;659
                            F7L44
0002de  4b10                        LDR      r3,F7L1+16   ;;;662
0002e0  4298                        CMP      r0,r3   ;;;662
0002e2  d2d0                        BCS      F7L30   ;;;662
0002e4  e7d0                        B        F7L33   ;;;662
                            F7L37
0002e6  0078                        LSL      r0,r7,#1   ;;;670
0002e8  68e9                        LDR      r1,[r5,#&c]   ;;;670
0002ea  0a40                        LSR      r0,#9   ;;;670
0002ec  1840                        ADD      r0,r1   ;;;670
0002ee  063f                        LSL      r7,#24   ;;;671
0002f0  6b69                        LDR      r1,[r5,#&34]   ;;;674
0002f2  0e3f                        LSR      r7,#24   ;;;671
0002f4  4288                        CMP      r0,r1   ;;;674
0002f6  d004                        BEQ      F7L45   ;;;674
0002f8  2101                        MOV      r1,#1   ;;;678
0002fa  1c32                        MOV      r2,r6   ;;;678
0002fc  6368                        STR      r0,[r5,#&34]   ;;;678
0002fe  f7ff feaf                   BL       MPCF_ReadSectors   ;;;678
                            F7L45
000302  0078                        LSL      r0,r7,#1   ;;;682
000304  5a30                        LDRH     r0,[r6,r0]   ;;;682
000306  4b07                        LDR      r3,F7L1+20   ;;;684
000308  4298                        CMP      r0,r3   ;;;684
00030a  d2bc                        BCS      F7L30   ;;;684
00030c  e7bc                        B        F7L33   ;;;684
00030e  0000                        LSL      r0,#0   ;;;684
                            F7L1
000310  00000000                    DCD      |x$dataseg|   ;;;684
000314  00000000                    DCD      fatBuffer   ;;;684
000318  0ffffff7                    DCD      0x0ffffff7   ;;;684
00031c  0fffffff                    DCD      0x0fffffff   ;;;684
000320  00000ff7                    DCD      0x00000ff7   ;;;684
000324  0000fff7                    DCD      0x0000fff7   ;;;684

;;;708    			}
;;;709    			break;
;;;710    			
;;;711    		default:
;;;712    			nextCluster = CLUSTER_FREE;
;;;713    			break;
;;;714    	}
;;;715    	
;;;716    	return nextCluster;
;;;717    }
;;;718    
;;;719    /*-----------------------------------------------------------------
;;;720    FAT_WriteFatEntry
;;;721    Internal function - writes FAT information about a cluster
;;;722    -----------------------------------------------------------------*/
;;;723    bool FAT_WriteFatEntry (u32 cluster, u32 value)
;;;724    {
000328                      FAT_WriteFatEntry
000328  b5f0                        PUSH     {r4-r7,lr}
00032a  1c07                        MOV      r7,r0
00032c  2000                        MOV      r0,#0
;;;725    	u32 sector;
;;;726    	int offset;
;;;727    
;;;728    	if ((cluster < 0x0002) || (cluster > fatLastCluster))
00032e  1c0c                        MOV      r4,r1
000330  2f02                        CMP      r7,#2
000332  d374                        BCC      F8L35
000334  4d4b                        LDR      r5,F8L1
000336  6ae9                        LDR      r1,[r5,#&2c]
000338  428f                        CMP      r7,r1
00033a  d871                        BHI      F8L36
;;;729    	{
;;;730    		return false;
;;;731    	}
;;;732    	
;;;733    	switch (filesysType) 
00033c  1de9                        ADD      r1,r5,#7
00033e  3119                        ADD      r1,#&19
000340  7a09                        LDRB     r1,[r1,#8]
000342  2900                        CMP      r1,#0
000344  d06d                        BEQ      F8L37
000346  2901                        CMP      r1,#1
000348  d015                        BEQ      F8L38
00034a  2902                        CMP      r1,#2
00034c  d06a                        BEQ      F8L39
00034e  2903                        CMP      r1,#3
000350  d169                        BNE      F8L40
;;;734    	{
;;;735    		case FS_UNKNOWN:
;;;736    			return false;
;;;737    			break;
;;;738    			
;;;739    		case FS_FAT12:
;;;740    			sector = filesysFAT + (((cluster * 3) / 2) / BYTE_PER_READ);
;;;741    			offset = ((cluster * 3) / 2) % BYTE_PER_READ;
;;;742    
;;;743    			// If FAT buffer contains wrong sector
;;;744    			if (sector != fatBufferCurSector)
;;;745    			{
;;;746    				// Load correct sector to buffer
;;;747    				fatBufferCurSector = sector;
;;;748    				disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;749    			}
;;;750    
;;;751    			if (cluster & 0x01) {
;;;752    
;;;753    				((u8*)fatBuffer)[offset] = (((u8*)fatBuffer)[offset] & 0x0F) | ((value & 0x0F) << 4);
;;;754    
;;;755    				offset++;
;;;756    				if (offset >= BYTE_PER_READ) {
;;;757    					offset = 0;
;;;758    					// write the buffer back to disc
;;;759    					disc_WriteSector(fatBufferCurSector, fatBuffer);
;;;760    					// read the next sector	
;;;761    					fatBufferCurSector++;
;;;762    					disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;763    				}
;;;764    				
;;;765    				((u8*)fatBuffer)[offset] =  (value & 0x0FF0) >> 4;
;;;766    
;;;767    			} else {
;;;768    			
;;;769    				((u8*)fatBuffer)[offset] = value & 0xFF;
;;;770    		
;;;771    				offset++;
;;;772    				if (offset >= BYTE_PER_READ) {
;;;773    					offset = 0;
;;;774    					// write the buffer back to disc
;;;775    					disc_WriteSector(fatBufferCurSector, fatBuffer);
;;;776    					// read the next sector	
;;;777    					fatBufferCurSector++;
;;;778    					disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;779    				}
;;;780    				
;;;781    				((u8*)fatBuffer)[offset] = (((u8*)fatBuffer)[offset] & 0xF0) | ((value >> 8) & 0x0F);
;;;782    			}
;;;783    
;;;784    			break;
;;;785    			
;;;786    		case FS_FAT16:
;;;787    			sector = filesysFAT + ((cluster << 1) / BYTE_PER_READ);
;;;788    			offset = cluster % (BYTE_PER_READ >> 1);
;;;789    
;;;790    			// If FAT buffer contains wrong sector
;;;791    			if (sector != fatBufferCurSector)
;;;792    			{
;;;793    				// Load correct sector to buffer
;;;794    				fatBufferCurSector = sector;
;;;795    				disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;796    			}
;;;797    
;;;798    			// write the value to the FAT buffer
;;;799    			((u16*)fatBuffer)[offset] = (value & 0xFFFF);
;;;800    
;;;801    			break;
;;;802    			
;;;803    		case FS_FAT32:
;;;804    			sector = filesysFAT + ((cluster << 2) / BYTE_PER_READ);
000352  00b8                        LSL      r0,r7,#2
000354  68e9                        LDR      r1,[r5,#&c]
000356  0a40                        LSR      r0,#9
000358  1840                        ADD      r0,r1
;;;805    			offset = cluster % (BYTE_PER_READ >> 2);
00035a  067f                        LSL      r7,#25
;;;806    			
;;;807    			// If FAT buffer contains wrong sector
;;;808    			if (sector != fatBufferCurSector)
00035c  6b69                        LDR      r1,[r5,#&34]
00035e  0e7f                        LSR      r7,#25   ;;;805
000360  4288                        CMP      r0,r1
000362  d004                        BEQ      F8L41
;;;809    			{
;;;810    				// Load correct sector to buffer
;;;811    				fatBufferCurSector = sector;
;;;812    				disc_ReadSector(fatBufferCurSector, fatBuffer);
000364  6368                        STR      r0,[r5,#&34]
000366  4a40                        LDR      r2,F8L1+4
000368  2101                        MOV      r1,#1
00036a  f7ff fe79                   BL       MPCF_ReadSectors
                            F8L41
;;;813    			}
;;;814    
;;;815    			// write the value to the FAT buffer
;;;816    			(((u32*)fatBuffer)[offset]) =  value;
00036e  4a3e                        LDR      r2,F8L1+4
000370  00b8                        LSL      r0,r7,#2
000372  5014                        STR      r4,[r2,r0]
000374  e06c                        B        F8L42
                            F8L38
000376  0079                        LSL      r1,r7,#1   ;;;740
000378  19c9                        ADD      r1,r7   ;;;740
00037a  68ea                        LDR      r2,[r5,#&c]   ;;;740
00037c  0a88                        LSR      r0,r1,#10   ;;;740
00037e  1880                        ADD      r0,r2   ;;;740
000380  0849                        LSR      r1,#1   ;;;741
000382  05ce                        LSL      r6,r1,#23   ;;;741
000384  6b69                        LDR      r1,[r5,#&34]   ;;;744
000386  0df6                        LSR      r6,#23   ;;;741
000388  4288                        CMP      r0,r1   ;;;744
00038a  d004                        BEQ      F8L43   ;;;744
00038c  6368                        STR      r0,[r5,#&34]   ;;;748
00038e  4a36                        LDR      r2,F8L1+4   ;;;748
000390  2101                        MOV      r1,#1   ;;;748
000392  f7ff fe65                   BL       MPCF_ReadSectors   ;;;748
                            F8L43
000396  07f9                        LSL      r1,r7,#31   ;;;751
000398  0fc9                        LSR      r1,#31   ;;;751
00039a  2001                        MOV      r0,#1   ;;;751
00039c  0240                        LSL      r0,#9   ;;;751
00039e  007a                        LSL      r2,r7,#1   ;;;751
0003a0  19d2                        ADD      r2,r7   ;;;751
0003a2  0852                        LSR      r2,#1   ;;;751
0003a4  05d2                        LSL      r2,#23   ;;;751
0003a6  0dd2                        LSR      r2,#23   ;;;751
0003a8  1c57                        ADD      r7,r2,#1   ;;;751
0003aa  2900                        CMP      r1,#0   ;;;751
0003ac  d01d                        BEQ      F8L44   ;;;751
0003ae  4b2e                        LDR      r3,F8L1+4   ;;;753
0003b0  5d99                        LDRB     r1,[r3,r6]   ;;;753
0003b2  0709                        LSL      r1,#28   ;;;753
0003b4  0f09                        LSR      r1,#28   ;;;753
0003b6  0122                        LSL      r2,r4,#4   ;;;753
0003b8  4311                        ORR      r1,r2   ;;;753
0003ba  5599                        STRB     r1,[r3,r6]   ;;;753
0003bc  4287                        CMP      r7,r0   ;;;756
0003be  db0d                        BLT      F8L45   ;;;756
0003c0  4e29                        LDR      r6,F8L1+4   ;;;759
0003c2  2700                        MOV      r7,#0   ;;;757
0003c4  2101                        MOV      r1,#1   ;;;759
0003c6  1c32                        MOV      r2,r6   ;;;759
0003c8  6b68                        LDR      r0,[r5,#&34]   ;;;759
0003ca  f7ff feb5                   BL       MPCF_WriteSectors   ;;;759
0003ce  6b68                        LDR      r0,[r5,#&34]   ;;;761
0003d0  2101                        MOV      r1,#1   ;;;762
0003d2  3001                        ADD      r0,#1   ;;;761
0003d4  6368                        STR      r0,[r5,#&34]   ;;;762
0003d6  1c32                        MOV      r2,r6   ;;;762
0003d8  f7ff fe42                   BL       MPCF_ReadSectors   ;;;762
                            F8L45
0003dc  20ff                        MOV      r0,#&ff   ;;;765
0003de  0100                        LSL      r0,#4   ;;;765
0003e0  4020                        AND      r0,r4   ;;;765
0003e2  4b21                        LDR      r3,F8L1+4   ;;;765
0003e4  0900                        LSR      r0,#4   ;;;765
0003e6  55d8                        STRB     r0,[r3,r7]   ;;;765
0003e8  e032                        B        F8L42   ;;;765
                            F8L44
0003ea  4a1f                        LDR      r2,F8L1+4   ;;;769
0003ec  4287                        CMP      r7,r0   ;;;772
0003ee  5594                        STRB     r4,[r2,r6]   ;;;769
0003f0  db0d                        BLT      F8L46   ;;;772
0003f2  4e1d                        LDR      r6,F8L1+4   ;;;775
0003f4  2700                        MOV      r7,#0   ;;;773
0003f6  2101                        MOV      r1,#1   ;;;775
0003f8  1c32                        MOV      r2,r6   ;;;775
0003fa  6b68                        LDR      r0,[r5,#&34]   ;;;775
0003fc  f7ff fe9c                   BL       MPCF_WriteSectors   ;;;775
000400  6b68                        LDR      r0,[r5,#&34]   ;;;777
000402  2101                        MOV      r1,#1   ;;;778
000404  3001                        ADD      r0,#1   ;;;777
000406  6368                        STR      r0,[r5,#&34]   ;;;778
000408  1c32                        MOV      r2,r6   ;;;778
00040a  f7ff fe29                   BL       MPCF_ReadSectors   ;;;778
                            F8L46
00040e  4a16                        LDR      r2,F8L1+4   ;;;781
000410  23f0                        MOV      r3,#&f0   ;;;781
000412  5dd0                        LDRB     r0,[r2,r7]   ;;;781
000414  4018                        AND      r0,r3   ;;;781
000416  0a21                        LSR      r1,r4,#8   ;;;781
000418  0709                        LSL      r1,#28   ;;;781
00041a  0f09                        LSR      r1,#28   ;;;781
00041c  e004                        B        F8L48   ;;;781
                            F8L35
00041e  e01d                        B        F8L49   ;;;781
                            F8L36
000420  e01c                        B        F8L50   ;;;781
                            F8L37
000422  e01b                        B        F8L51   ;;;781
                            F8L39
000424  e003                        B        F8L52   ;;;781
                            F8L40
000426  e019                        B        F8L53   ;;;781
                            F8L48
000428  4308                        ORR      r0,r1   ;;;781
00042a  55d0                        STRB     r0,[r2,r7]   ;;;781
00042c  e010                        B        F8L42   ;;;781
                            F8L52
00042e  0078                        LSL      r0,r7,#1   ;;;787
000430  68e9                        LDR      r1,[r5,#&c]   ;;;787
000432  0a40                        LSR      r0,#9   ;;;787
000434  1840                        ADD      r0,r1   ;;;787
000436  063f                        LSL      r7,#24   ;;;788
000438  6b69                        LDR      r1,[r5,#&34]   ;;;791
00043a  0e3f                        LSR      r7,#24   ;;;788
00043c  4288                        CMP      r0,r1   ;;;791
00043e  d004                        BEQ      F8L54   ;;;791
000440  6368                        STR      r0,[r5,#&34]   ;;;795
000442  4a09                        LDR      r2,F8L1+4   ;;;795
000444  2101                        MOV      r1,#1   ;;;795
000446  f7ff fe0b                   BL       MPCF_ReadSectors   ;;;795
                            F8L54
00044a  4a07                        LDR      r2,F8L1+4   ;;;799
00044c  0079                        LSL      r1,r7,#1   ;;;799
00044e  5254                        STRH     r4,[r2,r1]   ;;;799
                            F8L42
;;;817    
;;;818    			break;
;;;819    			
;;;820    		default:
;;;821    			return false;
;;;822    			break;
;;;823    	}
;;;824    	
;;;825    	// write the buffer back to disc
;;;826    	disc_WriteSector(fatBufferCurSector, fatBuffer);
000450  4a05                        LDR      r2,F8L1+4
000452  2101                        MOV      r1,#1
000454  6b68                        LDR      r0,[r5,#&34]
000456  f7ff fe6f                   BL       MPCF_WriteSectors
;;;827    			
;;;828    	return true;
00045a  2001                        MOV      r0,#1
                            F8L49
                            F8L50
                            F8L51
                            F8L53
00045c  bcf0                        POP      {r4-r7}
00045e  bc08                        POP      {r3}
000460  4718                        BX       r3
000462  0000                        LSL      r0,#0
                            F8L1
000464  00000000                    DCD      |x$dataseg|
000468  00000000                    DCD      fatBuffer

;;;829    }
;;;830    
;;;831    /*-----------------------------------------------------------------
;;;832    FAT_ReadWriteFatEntryBuffered
;;;833    Internal function - writes FAT information about a cluster to a 
;;;834     buffer that should then be flushed to disc using 
;;;835     FAT_WriteFatEntryFlushBuffer()
;;;836     Call FAT_WriteFatEntry first so as not to ruin the disc.
;;;837     Also returns the entry being replaced
;;;838    -----------------------------------------------------------------*/
;;;839    u32 FAT_ReadWriteFatEntryBuffered (u32 cluster, u32 value)
;;;840    {
00046c                      FAT_ReadWriteFatEntryBuffered
00046c  b5f0                        PUSH     {r4-r7,lr}
;;;841    	u32 sector;
;;;842    	int offset;
;;;843    	u32 oldValue;
;;;844    
;;;845    	if ((cluster < 0x0002) || (cluster > fatLastCluster))
00046e  1c05                        MOV      r5,r0
000470  1c0f                        MOV      r7,r1
000472  2802                        CMP      r0,#2
000474  d373                        BCC      F9L51
000476  4a6b                        LDR      r2,F9L1
000478  6ad0                        LDR      r0,[r2,#&2c]
00047a  4285                        CMP      r5,r0
00047c  d870                        BHI      F9L52
;;;846    		return CLUSTER_FREE;
;;;847    
;;;848    	
;;;849    	switch (filesysType) 
00047e  1dd0                        ADD      r0,r2,#7
000480  3019                        ADD      r0,#&19
000482  7a00                        LDRB     r0,[r0,#8]
000484  2800                        CMP      r0,#0
000486  d06c                        BEQ      F9L53
000488  2801                        CMP      r0,#1
00048a  d029                        BEQ      F9L54
00048c  2802                        CMP      r0,#2
00048e  d069                        BEQ      F9L55
000490  2803                        CMP      r0,#3
000492  d168                        BNE      F9L56
;;;850    	{
;;;851    		case FS_UNKNOWN:
;;;852    			oldValue = CLUSTER_FREE;
;;;853    			break;
;;;854    			
;;;855    		case FS_FAT12:
;;;856    			sector = filesysFAT + (((cluster * 3) / 2) / BYTE_PER_READ);
;;;857    			offset = ((cluster * 3) / 2) % BYTE_PER_READ;
;;;858    
;;;859    			// If FAT buffer contains wrong sector
;;;860    			if (sector != fatBufferCurSector)
;;;861    			{
;;;862    				// write the old buffer to disc
;;;863    				if ((fatBufferCurSector >= filesysFAT) && (fatBufferCurSector < (filesysFAT + filesysSecPerFAT)))
;;;864    					disc_WriteSector(fatBufferCurSector, fatBuffer);
;;;865    				// Load correct sector to buffer
;;;866    				fatBufferCurSector = sector;
;;;867    				disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;868    			}
;;;869    
;;;870    			if (cluster & 0x01) {
;;;871    
;;;872    				oldValue = (((u8*)fatBuffer)[offset] & 0xF0) >> 4;
;;;873    				((u8*)fatBuffer)[offset] = (((u8*)fatBuffer)[offset] & 0x0F) | ((value & 0x0F) << 4);
;;;874    
;;;875    				offset++;
;;;876    				if (offset >= BYTE_PER_READ) {
;;;877    					offset = 0;
;;;878    					// write the buffer back to disc
;;;879    					disc_WriteSector(fatBufferCurSector, fatBuffer);
;;;880    					// read the next sector	
;;;881    					fatBufferCurSector++;
;;;882    					disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;883    				}
;;;884    				
;;;885    				oldValue |= ((((u8*)fatBuffer)[offset]) << 4) & 0x0FF0;
;;;886    				((u8*)fatBuffer)[offset] =  (value & 0x0FF0) >> 4;
;;;887    
;;;888    			} else {
;;;889    			
;;;890    				oldValue = ((u8*)fatBuffer)[offset] & 0xFF;
;;;891    				((u8*)fatBuffer)[offset] = value & 0xFF;
;;;892    		
;;;893    				offset++;
;;;894    				if (offset >= BYTE_PER_READ) {
;;;895    					offset = 0;
;;;896    					// write the buffer back to disc
;;;897    					disc_WriteSector(fatBufferCurSector, fatBuffer);
;;;898    					// read the next sector	
;;;899    					fatBufferCurSector++;
;;;900    					disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;901    				}
;;;902    				
;;;903    				oldValue |= (((u8*)fatBuffer)[offset] & 0x0F) << 8;
;;;904    				((u8*)fatBuffer)[offset] = (((u8*)fatBuffer)[offset] & 0xF0) | ((value >> 8) & 0x0F);
;;;905    			}
;;;906    
;;;907    			if (oldValue >= 0x0FF7) 
;;;908    			{
;;;909    				oldValue = CLUSTER_EOF;
;;;910    			}
;;;911    
;;;912    			break;
;;;913    			
;;;914    		case FS_FAT16:
;;;915    			sector = filesysFAT + ((cluster << 1) / BYTE_PER_READ);
;;;916    			offset = cluster % (BYTE_PER_READ >> 1);
;;;917    
;;;918    			// If FAT buffer contains wrong sector
;;;919    			if (sector != fatBufferCurSector)
;;;920    			{
;;;921    				// write the old buffer to disc
;;;922    				if ((fatBufferCurSector >= filesysFAT) && (fatBufferCurSector < (filesysFAT + filesysSecPerFAT)))
;;;923    					disc_WriteSector(fatBufferCurSector, fatBuffer);
;;;924    				// Load correct sector to buffer
;;;925    				fatBufferCurSector = sector;
;;;926    				disc_ReadSector(fatBufferCurSector, fatBuffer);
;;;927    			} 
;;;928    
;;;929    			// write the value to the FAT buffer
;;;930    			oldValue = ((u16*)fatBuffer)[offset];
;;;931    			((u16*)fatBuffer)[offset] = value;
;;;932    
;;;933    			if (oldValue >= 0xFFF7) 
;;;934    			{
;;;935    				oldValue = CLUSTER_EOF;
;;;936    			}
;;;937    
;;;938    			break;
;;;939    			
;;;940    		case FS_FAT32:
;;;941    			sector = filesysFAT + ((cluster << 2) / BYTE_PER_READ);
000494  00a8                        LSL      r0,r5,#2
000496  0a41                        LSR      r1,r0,#9
000498  68d0                        LDR      r0,[r2,#&c]
00049a  180c                        ADD      r4,r1,r0
;;;942    			offset = cluster % (BYTE_PER_READ >> 2);
00049c  066e                        LSL      r6,r5,#25
;;;943    			
;;;944    			// If FAT buffer contains wrong sector
;;;945    			if (sector != fatBufferCurSector)
00049e  6b51                        LDR      r1,[r2,#&34]
0004a0  0e76                        LSR      r6,#25   ;;;942
0004a2  428c                        CMP      r4,r1
0004a4  d011                        BEQ      F9L57
;;;946    			{
;;;947    				// write the old buffer to disc
;;;948    				if ((fatBufferCurSector >= filesysFAT) && (fatBufferCurSector < (filesysFAT + filesysSecPerFAT)))
0004a6  1c15                        MOV      r5,r2
0004a8  4281                        CMP      r1,r0
0004aa  d308                        BCC      F9L58
0004ac  692a                        LDR      r2,[r5,#&10]
0004ae  1880                        ADD      r0,r2
0004b0  4288                        CMP      r0,r1
0004b2  d904                        BLS      F9L59
;;;949    					disc_WriteSector(fatBufferCurSector, fatBuffer);
0004b4  1c08                        MOV      r0,r1
0004b6  2101                        MOV      r1,#1
0004b8  4a5b                        LDR      r2,F9L1+4
0004ba  f7ff fe3d                   BL       MPCF_WriteSectors
                            F9L58
                            F9L59
;;;950    				// Load correct sector to buffer
;;;951    				fatBufferCurSector = sector;
;;;952    				disc_ReadSector(fatBufferCurSector, fatBuffer);
0004be  1c20                        MOV      r0,r4
0004c0  2101                        MOV      r1,#1
0004c2  636c                        STR      r4,[r5,#&34]
0004c4  4a58                        LDR      r2,F9L1+4
0004c6  f7ff fdcb                   BL       MPCF_ReadSectors
                            F9L57
;;;953    			}
;;;954    
;;;955    			// write the value to the FAT buffer
;;;956    			oldValue = ((u32*)fatBuffer)[offset];
0004ca  4a57                        LDR      r2,F9L1+4
0004cc  00b1                        LSL      r1,r6,#2
0004ce  5850                        LDR      r0,[r2,r1]
;;;957    			((u32*)fatBuffer)[offset] =  value;
;;;958    
;;;959    			if (oldValue >= 0x0FFFFFF7) 
0004d0  4b56                        LDR      r3,F9L1+8
0004d2  5057                        STR      r7,[r2,r1]   ;;;957
0004d4  4298                        CMP      r0,r3
0004d6  d300                        BCC      F9L60
                            F9L45
;;;960    			{
;;;961    				oldValue = CLUSTER_EOF;
0004d8  4855                        LDR      r0,F9L1+12
                            F9L60
                            F9L49
0004da  bcf0                        POP      {r4-r7}
0004dc  bc08                        POP      {r3}
0004de  4718                        BX       r3
                            F9L54
0004e0  4850                        LDR      r0,F9L1   ;;;856
0004e2  006b                        LSL      r3,r5,#1   ;;;856
0004e4  195b                        ADD      r3,r5   ;;;856
0004e6  68c1                        LDR      r1,[r0,#&c]   ;;;856
0004e8  0a9c                        LSR      r4,r3,#10   ;;;856
0004ea  1866                        ADD      r6,r4,r1   ;;;856
0004ec  085a                        LSR      r2,r3,#1   ;;;857
0004ee  05d4                        LSL      r4,r2,#23   ;;;857
0004f0  6b40                        LDR      r0,[r0,#&34]   ;;;860
0004f2  0de4                        LSR      r4,#23   ;;;857
0004f4  4286                        CMP      r6,r0   ;;;860
0004f6  d011                        BEQ      F9L61   ;;;860
0004f8  4288                        CMP      r0,r1   ;;;863
0004fa  d308                        BCC      F9L62   ;;;863
0004fc  4a49                        LDR      r2,F9L1   ;;;863
0004fe  6912                        LDR      r2,[r2,#&10]   ;;;863
000500  1889                        ADD      r1,r2   ;;;863
000502  4281                        CMP      r1,r0   ;;;863
000504  d903                        BLS      F9L63   ;;;863
000506  4a48                        LDR      r2,F9L1+4   ;;;864
000508  2101                        MOV      r1,#1   ;;;864
00050a  f7ff fe15                   BL       MPCF_WriteSectors   ;;;864
                            F9L62
                            F9L63
00050e  4a45                        LDR      r2,F9L1   ;;;866
000510  1c30                        MOV      r0,r6   ;;;866
000512  6356                        STR      r6,[r2,#&34]   ;;;867
000514  4a44                        LDR      r2,F9L1+4   ;;;867
000516  2101                        MOV      r1,#1   ;;;867
000518  f7ff fda2                   BL       MPCF_ReadSectors   ;;;867
                            F9L61
00051c  07ea                        LSL      r2,r5,#31   ;;;870
00051e  0fd2                        LSR      r2,#31   ;;;870
000520  0068                        LSL      r0,r5,#1   ;;;870
000522  1940                        ADD      r0,r5   ;;;870
000524  0840                        LSR      r0,#1   ;;;870
000526  05c0                        LSL      r0,#23   ;;;870
000528  0dc0                        LSR      r0,#23   ;;;870
00052a  2101                        MOV      r1,#1   ;;;870
00052c  0249                        LSL      r1,#9   ;;;870
00052e  3001                        ADD      r0,#1   ;;;870
000530  2a00                        CMP      r2,#0   ;;;870
000532  d02a                        BEQ      F9L64   ;;;870
000534  4e3c                        LDR      r6,F9L1+4   ;;;872
000536  23f0                        MOV      r3,#&f0   ;;;872
000538  5d32                        LDRB     r2,[r6,r4]   ;;;872
00053a  4013                        AND      r3,r2   ;;;872
00053c  091d                        LSR      r5,r3,#4   ;;;872
00053e  0712                        LSL      r2,#28   ;;;873
000540  0f12                        LSR      r2,#28   ;;;873
000542  013b                        LSL      r3,r7,#4   ;;;873
000544  431a                        ORR      r2,r3   ;;;873
000546  5532                        STRB     r2,[r6,r4]   ;;;873
000548  1c04                        MOV      r4,r0   ;;;876
00054a  4288                        CMP      r0,r1   ;;;876
00054c  db14                        BLT      F9L65   ;;;876
00054e  4935                        LDR      r1,F9L1   ;;;879
000550  2400                        MOV      r4,#0   ;;;877
000552  1c32                        MOV      r2,r6   ;;;879
000554  6b48                        LDR      r0,[r1,#&34]   ;;;879
000556  2101                        MOV      r1,#1   ;;;879
000558  f7ff fdee                   BL       MPCF_WriteSectors   ;;;879
00055c  e004                        B        F9L67   ;;;881
                            F9L51
00055e  e05f                        B        F9L68   ;;;881
                            F9L52
000560  e05e                        B        F9L69   ;;;881
                            F9L53
000562  e05d                        B        F9L70   ;;;881
                            F9L55
000564  e038                        B        F9L71   ;;;881
                            F9L56
000566  e05b                        B        F9L72   ;;;881
                            F9L67
000568  492e                        LDR      r1,F9L1   ;;;881
00056a  6b48                        LDR      r0,[r1,#&34]   ;;;881
00056c  3001                        ADD      r0,#1   ;;;881
00056e  6348                        STR      r0,[r1,#&34]   ;;;882
000570  2101                        MOV      r1,#1   ;;;882
000572  1c32                        MOV      r2,r6   ;;;882
000574  f7ff fd74                   BL       MPCF_ReadSectors   ;;;882
                            F9L65
000578  5d30                        LDRB     r0,[r6,r4]   ;;;885
00057a  0100                        LSL      r0,#4   ;;;885
00057c  23ff                        MOV      r3,#&ff   ;;;885
00057e  011b                        LSL      r3,#4   ;;;885
000580  4018                        AND      r0,r3   ;;;885
000582  4328                        ORR      r0,r5   ;;;885
000584  401f                        AND      r7,r3   ;;;886
000586  0939                        LSR      r1,r7,#4   ;;;886
000588  e021                        B        F9L73   ;;;886
                            F9L64
00058a  4e27                        LDR      r6,F9L1+4   ;;;890
00058c  5d32                        LDRB     r2,[r6,r4]   ;;;890
00058e  5537                        STRB     r7,[r6,r4]   ;;;891
000590  0615                        LSL      r5,r2,#24   ;;;890
000592  0e2d                        LSR      r5,#24   ;;;890
000594  1c04                        MOV      r4,r0   ;;;894
000596  4288                        CMP      r0,r1   ;;;894
000598  db0e                        BLT      F9L74   ;;;894
00059a  4922                        LDR      r1,F9L1   ;;;897
00059c  2400                        MOV      r4,#0   ;;;895
00059e  1c32                        MOV      r2,r6   ;;;897
0005a0  6b48                        LDR      r0,[r1,#&34]   ;;;897
0005a2  2101                        MOV      r1,#1   ;;;897
0005a4  f7ff fdc8                   BL       MPCF_WriteSectors   ;;;897
0005a8  491e                        LDR      r1,F9L1   ;;;899
0005aa  6b48                        LDR      r0,[r1,#&34]   ;;;899
0005ac  3001                        ADD      r0,#1   ;;;899
0005ae  6348                        STR      r0,[r1,#&34]   ;;;900
0005b0  2101                        MOV      r1,#1   ;;;900
0005b2  1c32                        MOV      r2,r6   ;;;900
0005b4  f7ff fd54                   BL       MPCF_ReadSectors   ;;;900
                            F9L74
0005b8  5d31                        LDRB     r1,[r6,r4]   ;;;903
0005ba  0708                        LSL      r0,r1,#28   ;;;903
0005bc  0f00                        LSR      r0,#28   ;;;903
0005be  0200                        LSL      r0,#8   ;;;903
0005c0  4328                        ORR      r0,r5   ;;;903
0005c2  23f0                        MOV      r3,#&f0   ;;;904
0005c4  4019                        AND      r1,r3   ;;;904
0005c6  0a3a                        LSR      r2,r7,#8   ;;;904
0005c8  0712                        LSL      r2,#28   ;;;904
0005ca  0f12                        LSR      r2,#28   ;;;904
0005cc  4311                        ORR      r1,r2   ;;;904
                            F9L73
0005ce  4b19                        LDR      r3,F9L1+16   ;;;907
0005d0  5531                        STRB     r1,[r6,r4]   ;;;904
0005d2  4298                        CMP      r0,r3   ;;;907
0005d4  d280                        BCS      F9L45   ;;;907
0005d6  e780                        B        F9L49   ;;;907
                            F9L71
0005d8  0068                        LSL      r0,r5,#1   ;;;915
0005da  0a41                        LSR      r1,r0,#9   ;;;915
0005dc  68d0                        LDR      r0,[r2,#&c]   ;;;915
0005de  180c                        ADD      r4,r1,r0   ;;;915
0005e0  062e                        LSL      r6,r5,#24   ;;;916
0005e2  6b51                        LDR      r1,[r2,#&34]   ;;;919
0005e4  0e36                        LSR      r6,#24   ;;;916
0005e6  428c                        CMP      r4,r1   ;;;919
0005e8  d011                        BEQ      F9L75   ;;;919
0005ea  1c15                        MOV      r5,r2   ;;;922
0005ec  4281                        CMP      r1,r0   ;;;922
0005ee  d308                        BCC      F9L76   ;;;922
0005f0  692a                        LDR      r2,[r5,#&10]   ;;;922
0005f2  1880                        ADD      r0,r2   ;;;922
0005f4  4288                        CMP      r0,r1   ;;;922
0005f6  d904                        BLS      F9L77   ;;;922
0005f8  1c08                        MOV      r0,r1   ;;;923
0005fa  2101                        MOV      r1,#1   ;;;923
0005fc  4a0a                        LDR      r2,F9L1+4   ;;;923
0005fe  f7ff fd9b                   BL       MPCF_WriteSectors   ;;;923
                            F9L76
                            F9L77
000602  1c20                        MOV      r0,r4   ;;;926
000604  2101                        MOV      r1,#1   ;;;926
000606  636c                        STR      r4,[r5,#&34]   ;;;926
000608  4a07                        LDR      r2,F9L1+4   ;;;926
00060a  f7ff fd29                   BL       MPCF_ReadSectors   ;;;926
                            F9L75
00060e  4a06                        LDR      r2,F9L1+4   ;;;930
000610  0071                        LSL      r1,r6,#1   ;;;930
000612  5a50                        LDRH     r0,[r2,r1]   ;;;930
000614  4b08                        LDR      r3,F9L1+20   ;;;933
000616  5257                        STRH     r7,[r2,r1]   ;;;931
000618  4298                        CMP      r0,r3   ;;;933
00061a  d300                        BCC      F9L78   ;;;933
00061c  e75c                        B        F9L45   ;;;933
                            F9L78
00061e  e75c                        B        F9L49   ;;;933
                            F9L68
                            F9L69
                            F9L70
                            F9L72
;;;962    			}
;;;963    
;;;964    			break;
;;;965    			
;;;966    		default:
;;;967    			oldValue = CLUSTER_FREE;
000620  2000                        MOV      r0,#0
000622  e75a                        B        F9L49
                            F9L1
000624  00000000                    DCD      |x$dataseg|
000628  00000000                    DCD      fatBuffer
00062c  0ffffff7                    DCD      0x0ffffff7
000630  0fffffff                    DCD      0x0fffffff
000634  00000ff7                    DCD      0x00000ff7
000638  0000fff7                    DCD      0x0000fff7

;;;968    			break;
;;;969    	}
;;;970    	
;;;971    	return oldValue;
;;;972    }
;;;973    
;;;974    /*-----------------------------------------------------------------
;;;975    FAT_WriteFatEntryFlushBuffer
;;;976    Flush the FAT buffer back to the disc
;;;977    -----------------------------------------------------------------*/
;;;978    bool FAT_WriteFatEntryFlushBuffer (void)
;;;979    {
00063c                      FAT_WriteFatEntryFlushBuffer
00063c  b500                        PUSH     {lr}
;;;980    	// write the buffer disc
;;;981    	if ((fatBufferCurSector >= filesysFAT) && (fatBufferCurSector < (filesysFAT + filesysSecPerFAT)))
00063e  4a09                        LDR      r2,F10L1
000640  6b50                        LDR      r0,[r2,#&34]
000642  68d1                        LDR      r1,[r2,#&c]
000644  4288                        CMP      r0,r1
000646  d30a                        BCC      F10L12
000648  6912                        LDR      r2,[r2,#&10]
00064a  1889                        ADD      r1,r2
00064c  4281                        CMP      r1,r0
00064e  d906                        BLS      F10L13
;;;982    	{
;;;983    		disc_WriteSector(fatBufferCurSector, fatBuffer);
000650  4a05                        LDR      r2,F10L1+4
000652  2101                        MOV      r1,#1
000654  f7ff fd70                   BL       MPCF_WriteSectors
;;;984    		return true;
000658  2001                        MOV      r0,#1
                            F10L10
00065a  bc08                        POP      {r3}
00065c  4718                        BX       r3
                            F10L12
                            F10L13
;;;985    	} else {
;;;986    		return false;
00065e  2000                        MOV      r0,#0
000660  e7fb                        B        F10L10
000662  0000                        LSL      r0,#0
                            F10L1
000664  00000000                    DCD      |x$dataseg|
000668  00000000                    DCD      fatBuffer

;;;987    	}
;;;988    }
;;;989    
;;;990    
;;;991    /*-----------------------------------------------------------------
;;;992    FAT_FirstFreeCluster
;;;993    Internal function - gets the first available free cluster
;;;994    -----------------------------------------------------------------*/
;;;995    u32 FAT_FirstFreeCluster(void)
;;;996    {
00066c                      FAT_FirstFreeCluster
00066c  b580                        PUSH     {r7,lr}
;;;997    	// Start at first valid cluster
;;;998    	if (fatFirstFree < CLUSTER_FIRST)
00066e  4f0c                        LDR      r7,F11L1
000670  6b38                        LDR      r0,[r7,#&30]
000672  2802                        CMP      r0,#2
000674  d203                        BCS      F11L19
;;;999    		fatFirstFree = CLUSTER_FIRST;
000676  2002                        MOV      r0,#2
000678  e000                        B        F11L20
                            F11L6
;;;1000   
;;;1001   	while ((FAT_NextCluster(fatFirstFree) != CLUSTER_FREE) && (fatFirstFree <= fatLastCluster))
;;;1002   	{
;;;1003   		fatFirstFree++;
00067a  3001                        ADD      r0,#1
                            F11L20
00067c  6338                        STR      r0,[r7,#&30]
                            F11L19
00067e  6b38                        LDR      r0,[r7,#&30]   ;;;1001
000680  f7ff fddc                   BL       FAT_NextCluster   ;;;1001
000684  2800                        CMP      r0,#0   ;;;1001
000686  d003                        BEQ      F11L21   ;;;1001
000688  6b38                        LDR      r0,[r7,#&30]   ;;;1001
00068a  6af9                        LDR      r1,[r7,#&2c]   ;;;1001
00068c  4288                        CMP      r0,r1   ;;;1001
00068e  d9f4                        BLS      F11L6   ;;;1001
                            F11L21
;;;1004   	}
;;;1005   	if (fatFirstFree > fatLastCluster)
000690  6b38                        LDR      r0,[r7,#&30]
000692  6af9                        LDR      r1,[r7,#&2c]
000694  4288                        CMP      r0,r1
000696  d900                        BLS      F11L22
;;;1006   	{
;;;1007   		return CLUSTER_EOF;
000698  4802                        LDR      r0,F11L1+4
                            F11L22
00069a  bc80                        POP      {r7}
00069c  bc08                        POP      {r3}
00069e  4718                        BX       r3
                            F11L1
0006a0  00000000                    DCD      |x$dataseg|
0006a4  0fffffff                    DCD      0x0fffffff

;;;1008   	}
;;;1009   	return fatFirstFree;
;;;1010   }
;;;1011   
;;;1012   
;;;1013   /*-----------------------------------------------------------------
;;;1014   FAT_LinkFreeCluster
;;;1015   Internal function - gets the first available free cluster, sets it
;;;1016   to end of file, links the input cluster to it then returns the 
;;;1017   cluster number
;;;1018   -----------------------------------------------------------------*/
;;;1019   u32 FAT_LinkFreeCluster(u32 cluster)
;;;1020   {
0006a8                      FAT_LinkFreeCluster
0006a8  b5f0                        PUSH     {r4-r7,lr}
;;;1021   	u32 firstFree;
;;;1022   	u32 curLink;
;;;1023   
;;;1024   	if (cluster > fatLastCluster)
0006aa  4d13                        LDR      r5,F12L1
0006ac  1c04                        MOV      r4,r0
0006ae  6ae8                        LDR      r0,[r5,#&2c]
0006b0  2600                        MOV      r6,#0
0006b2  4284                        CMP      r4,r0
0006b4  d80d                        BHI      F12L18
;;;1025   	{
;;;1026   		return CLUSTER_FREE;
;;;1027   	}
;;;1028   
;;;1029   	// Check if the cluster already has a link, and return it if so
;;;1030   	curLink = FAT_NextCluster (cluster);
0006b6  1c20                        MOV      r0,r4
0006b8  f7ff fdc0                   BL       FAT_NextCluster
;;;1031   	if ((curLink >= CLUSTER_FIRST) && (curLink < fatLastCluster))
0006bc  2802                        CMP      r0,#2
0006be  d302                        BCC      F12L19
0006c0  6ae9                        LDR      r1,[r5,#&2c]
0006c2  4288                        CMP      r0,r1
0006c4  d306                        BCC      F12L20
                            F12L19
;;;1032   	{
;;;1033   		return curLink;	// Return the current link - don't allocate a new one
;;;1034   	}
;;;1035   	
;;;1036   	// Get a free cluster
;;;1037   	firstFree = FAT_FirstFreeCluster();
0006c6  f7ff ffd1                   BL       FAT_FirstFreeCluster
;;;1038   
;;;1039   	// If couldn't get a free cluster then return
;;;1040   	if (firstFree == CLUSTER_EOF)
0006ca  4b0c                        LDR      r3,F12L1+4
0006cc  1c07                        MOV      r7,r0
0006ce  4298                        CMP      r0,r3
0006d0  d103                        BNE      F12L21
                            F12L18
;;;1041   	{
;;;1042   		return CLUSTER_FREE;
0006d2  1c30                        MOV      r0,r6
                            F12L20
                            F12L16
0006d4  bcf0                        POP      {r4-r7}
0006d6  bc08                        POP      {r3}
0006d8  4718                        BX       r3
                            F12L21
;;;1043   	}
;;;1044   
;;;1045   	if ((cluster >= CLUSTER_FIRST) && (cluster < fatLastCluster))
0006da  2c02                        CMP      r4,#2
0006dc  d306                        BCC      F12L22
0006de  6ae8                        LDR      r0,[r5,#&2c]
0006e0  4284                        CMP      r4,r0
0006e2  d203                        BCS      F12L23
;;;1046   	{
;;;1047   		// Update the linked from FAT entry
;;;1048   		FAT_WriteFatEntry (cluster, firstFree);
0006e4  1c20                        MOV      r0,r4
0006e6  1c39                        MOV      r1,r7
0006e8  f7ff fe1e                   BL       FAT_WriteFatEntry
                            F12L22
                            F12L23
;;;1049   	}
;;;1050   	// Create the linked to FAT entry
;;;1051   	FAT_WriteFatEntry (firstFree, CLUSTER_EOF);
0006ec  1c38                        MOV      r0,r7
0006ee  4903                        LDR      r1,F12L1+4
0006f0  f7ff fe1a                   BL       FAT_WriteFatEntry
;;;1052   
;;;1053   	return firstFree;
0006f4  1c38                        MOV      r0,r7
0006f6  e7ed                        B        F12L16
                            F12L1
0006f8  00000000                    DCD      |x$dataseg|
0006fc  0fffffff                    DCD      0x0fffffff

;;;1054   }
;;;1055   
;;;1056   
;;;1057   /*-----------------------------------------------------------------
;;;1058   FAT_ClearLinks
;;;1059   Internal function - frees any cluster used by a file
;;;1060   -----------------------------------------------------------------*/
;;;1061   bool FAT_ClearLinks (u32 cluster)
;;;1062   {
000700                      FAT_ClearLinks
000700  b590                        PUSH     {r4,r7,lr}
;;;1063   	u32 nextCluster;
;;;1064   	
;;;1065   	if ((cluster < 0x0002) || (cluster > fatLastCluster))
000702  1c07                        MOV      r7,r0
000704  2802                        CMP      r0,#2
000706  d303                        BCC      F13L18
000708  480e                        LDR      r0,F13L1
00070a  6ac0                        LDR      r0,[r0,#&2c]
00070c  4287                        CMP      r7,r0
00070e  d903                        BLS      F13L19
                            F13L18
;;;1066   		return false;
000710  2000                        MOV      r0,#0
                            F13L16
000712  bc90                        POP      {r4,r7}
000714  bc08                        POP      {r3}
000716  4718                        BX       r3
                            F13L19
;;;1067   
;;;1068   	// Store next cluster before erasing the link
;;;1069   	nextCluster = FAT_NextCluster (cluster);
000718  1c38                        MOV      r0,r7
00071a  f7ff fd8f                   BL       FAT_NextCluster
;;;1070   
;;;1071   	// Erase the link
;;;1072   	FAT_WriteFatEntry (cluster, CLUSTER_FREE);
00071e  1c04                        MOV      r4,r0
000720  2100                        MOV      r1,#0
000722  1c38                        MOV      r0,r7
000724  f7ff fe00                   BL       FAT_WriteFatEntry
;;;1073   
;;;1074   	// Move onto next cluster
;;;1075   	cluster = nextCluster;
000728  1c20                        MOV      r0,r4
00072a  4f07                        LDR      r7,F13L1+4
00072c  e002                        B        F13L20
                            F13L8
;;;1076   
;;;1077   	while ((cluster != CLUSTER_EOF) && (cluster != CLUSTER_FREE))
;;;1078   	{
;;;1079   		cluster = FAT_ReadWriteFatEntryBuffered (cluster, CLUSTER_FREE);
00072e  2100                        MOV      r1,#0
000730  f7ff fe9c                   BL       FAT_ReadWriteFatEntryBuffered
                            F13L20
000734  42b8                        CMP      r0,r7   ;;;1077
000736  d001                        BEQ      F13L21   ;;;1077
000738  2800                        CMP      r0,#0   ;;;1077
00073a  d1f8                        BNE      F13L8   ;;;1077
                            F13L21
;;;1080   	} 
;;;1081   
;;;1082   	// Flush fat write buffer
;;;1083   	FAT_WriteFatEntryFlushBuffer ();
00073c  f7ff ff7e                   BL       FAT_WriteFatEntryFlushBuffer
;;;1084   
;;;1085   	return true;
000740  2001                        MOV      r0,#1
000742  e7e6                        B        F13L16
                            F13L1
000744  00000000                    DCD      |x$dataseg|
000748  0fffffff                    DCD      0x0fffffff

;;;1086   }
;;;1087   
;;;1088   
;;;1089   /*-----------------------------------------------------------------
;;;1090   FAT_InitFiles
;;;1091   Reads the FAT information from the CF card.
;;;1092   You need to call this before reading any files.
;;;1093   bool return OUT: true if successful.
;;;1094   -----------------------------------------------------------------*/
;;;1095   bool FAT_InitFiles (void)
;;;1096   {
00074c                      FAT_InitFiles
00074c  b5f0                        PUSH     {r4-r7,lr}
;;;1097   	int i;
;;;1098   	int bootSector;
;;;1099   	BOOT_SEC* bootSec;
;;;1100   	
;;;1101   	if (!disc_Init())
00074e  f7ff fd5f                   BL       MPCF_StartUp
000752  2800                        CMP      r0,#0
000754  d102                        BNE      F14L63
                            F14L61
;;;1102   	{
;;;1103   		return (false);
000756  bcf0                        POP      {r4-r7}
000758  bc08                        POP      {r3}
00075a  4718                        BX       r3
                            F14L63
;;;1104   	}
;;;1105   	
;;;1106   	// Read first sector of CF card
;;;1107   	disc_ReadSector (0, globalBuffer);
00075c  4f6c                        LDR      r7,F14L1
00075e  2101                        MOV      r1,#1
000760  2000                        MOV      r0,#0
000762  1c3a                        MOV      r2,r7
000764  f7ff fc7c                   BL       MPCF_ReadSectors
;;;1108   	// Check if there is a FAT string, which indicates this is a boot sector
;;;1109   	if ((globalBuffer[0x36] == 'F') && (globalBuffer[0x37] == 'A') && (globalBuffer[0x38] == 'T'))
000768  1df8                        ADD      r0,r7,#7
00076a  3029                        ADD      r0,#&29
00076c  7981                        LDRB     r1,[r0,#6]
00076e  2946                        CMP      r1,#&46
000770  d105                        BNE      F14L64
000772  79c1                        LDRB     r1,[r0,#7]
000774  2941                        CMP      r1,#&41
000776  d102                        BNE      F14L64
000778  7a00                        LDRB     r0,[r0,#8]
00077a  2854                        CMP      r0,#&54
00077c  d02c                        BEQ      F14L65
                            F14L64
;;;1110   	{
;;;1111   		bootSector = 0;
;;;1112   	}
;;;1113   	// Check for FAT32
;;;1114   	else if ((globalBuffer[0x52] == 'F') && (globalBuffer[0x53] == 'A') && (globalBuffer[0x54] == 'T'))
00077e  1df8                        ADD      r0,r7,#7
000780  3049                        ADD      r0,#&49
000782  7881                        LDRB     r1,[r0,#2]
000784  2946                        CMP      r1,#&46
000786  d105                        BNE      F14L66
000788  78c1                        LDRB     r1,[r0,#3]
00078a  2941                        CMP      r1,#&41
00078c  d102                        BNE      F14L66
00078e  7900                        LDRB     r0,[r0,#4]
000790  2854                        CMP      r0,#&54
000792  d021                        BEQ      F14L65
                            F14L66
;;;1115   	{
;;;1116   		bootSector = 0;
;;;1117   	}
;;;1118   	else	// This is an MBR
;;;1119   	{
;;;1120   		// Find first valid partition from MBR
;;;1121   		// First check for an active partition
;;;1122   		for (i=0x1BE; (i < 0x1FE) && (globalBuffer[i] != 0x80); i+= 0x10);
000794  20ff                        MOV      r0,#&ff
000796  30bf                        ADD      r0,#&bf
000798  21ff                        MOV      r1,#&ff
00079a  31ff                        ADD      r1,#&ff
00079c  e002                        B        F14L67
                            F14L16
00079e  3010                        ADD      r0,#&10
0007a0  4288                        CMP      r0,r1
0007a2  da02                        BGE      F14L68
                            F14L67
0007a4  5c3a                        LDRB     r2,[r7,r0]
0007a6  2a80                        CMP      r2,#&80
0007a8  d1f9                        BNE      F14L16
                            F14L68
;;;1123   		// If it didn't find an active partition, search for any valid partition
;;;1124   		if (i == 0x1FE) 
0007aa  4288                        CMP      r0,r1
0007ac  d10b                        BNE      F14L69
;;;1125   			for (i=0x1BE; (i < 0x1FE) && (globalBuffer[i+0x04] == 0x00); i+= 0x10);
0007ae  20ff                        MOV      r0,#&ff
0007b0  30bf                        ADD      r0,#&bf
0007b2  e002                        B        F14L70
                            F14L23
0007b4  3010                        ADD      r0,#&10
0007b6  4288                        CMP      r0,r1
0007b8  da03                        BGE      F14L71
                            F14L70
0007ba  183a                        ADD      r2,r7,r0
0007bc  7912                        LDRB     r2,[r2,#4]
0007be  2a00                        CMP      r2,#0
0007c0  d0f8                        BEQ      F14L23
                            F14L71
;;;1126   		
;;;1127   		// Go to first valid partition
;;;1128   		if ( i != 0x1FE)	// Make sure it found a partition
0007c2  4288                        CMP      r0,r1
0007c4  d008                        BEQ      F14L65
                            F14L69
;;;1129   		{
;;;1130   			bootSector = globalBuffer[0x8 + i] + (globalBuffer[0x9 + i] << 8) + (globalBuffer[0xA + i] << 16) + ((globalBuffer[0xB + i] << 24) & 0x0F);
0007c6  1838                        ADD      r0,r7,r0
0007c8  7a42                        LDRB     r2,[r0,#9]
0007ca  7a01                        LDRB     r1,[r0,#8]
0007cc  7a80                        LDRB     r0,[r0,#&a]
0007ce  0212                        LSL      r2,#8
0007d0  1889                        ADD      r1,r2
0007d2  0400                        LSL      r0,#16
0007d4  180c                        ADD      r4,r1,r0
0007d6  e000                        B        F14L72
                            F14L65
;;;1131   		} else {
;;;1132   			bootSector = 0;	// No partition found, assume this is a MBR free disk
0007d8  2400                        MOV      r4,#0
                            F14L72
;;;1133   		}
;;;1134   	}
;;;1135   
;;;1136   	// Read in boot sector
;;;1137   	bootSec = (BOOT_SEC*) globalBuffer;
;;;1138   	disc_ReadSector (bootSector,  (void*)bootSec);
0007da  2101                        MOV      r1,#1
0007dc  1c20                        MOV      r0,r4
0007de  1c3a                        MOV      r2,r7
0007e0  f7ff fc3e                   BL       MPCF_ReadSectors
;;;1139   	
;;;1140   	// Store required information about the file system
;;;1141   	if (bootSec->sectorsPerFAT != 0)
0007e4  7db8                        LDRB     r0,[r7,#&16]
0007e6  7dfb                        LDRB     r3,[r7,#&17]
0007e8  4e4a                        LDR      r6,F14L1+4
0007ea  021b                        LSL      r3,#8
0007ec  4318                        ORR      r0,r3
0007ee  d103                        BNE      F14L73
;;;1142   	{
;;;1143   		filesysSecPerFAT = bootSec->sectorsPerFAT;
;;;1144   	}
;;;1145   	else
;;;1146   	{
;;;1147   		filesysSecPerFAT = bootSec->extBlock.fat32.sectorsPerFAT32;
0007f0  1df8                        ADD      r0,r7,#7
0007f2  301d                        ADD      r0,#&1d
0007f4  f7ff fc04                   BL       __16_uread4
                            F14L73
;;;1148   	}
;;;1149   	
;;;1150   	if (bootSec->numSectorsSmall != 0)
0007f8  6130                        STR      r0,[r6,#&10]
0007fa  7cf8                        LDRB     r0,[r7,#&13]
0007fc  7d3b                        LDRB     r3,[r7,#&14]
0007fe  4d46                        LDR      r5,F14L1+8
000800  021b                        LSL      r3,#8
000802  4318                        ORR      r0,r3
000804  d102                        BNE      F14L74
;;;1151   	{
;;;1152   		filesysNumSec = bootSec->numSectorsSmall;
;;;1153   	}
;;;1154   	else
;;;1155   	{
;;;1156   		filesysNumSec = bootSec->numSectors;
000806  1c28                        MOV      r0,r5
000808  f7ff fbfa                   BL       __16_uread4
                            F14L74
;;;1157   	}
;;;1158   
;;;1159   	filesysBytePerSec = BYTE_PER_READ;	// Sector size is redefined to be 512 bytes
00080c  6170                        STR      r0,[r6,#&14]
00080e  2001                        MOV      r0,#1
000810  4e40                        LDR      r6,F14L1+4
000812  0240                        LSL      r0,#9
;;;1160   	filesysSecPerClus = bootSec->sectorsPerCluster * bootSec->bytesPerSector / BYTE_PER_READ;
000814  61f0                        STR      r0,[r6,#&1c]
000816  7b7e                        LDRB     r6,[r7,#&d]
000818  7afa                        LDRB     r2,[r7,#&b]
00081a  7b3b                        LDRB     r3,[r7,#&c]
00081c  021b                        LSL      r3,#8
00081e  431a                        ORR      r2,r3
000820  1c31                        MOV      r1,r6
000822  4351                        MUL      r1,r2
000824  d502                        BPL      F14L75
000826  31ff                        ADD      r1,#&ff
000828  31ff                        ADD      r1,#&ff
00082a  3101                        ADD      r1,#1
                            F14L75
00082c  4b39                        LDR      r3,F14L1+4
00082e  1249                        ASR      r1,#9
;;;1161   	filesysBytePerClus = filesysBytePerSec * filesysSecPerClus;
000830  6219                        STR      r1,[r3,#&20]
000832  0249                        LSL      r1,#9
;;;1162   	filesysFAT = bootSector + bootSec->reservedSectors;
000834  6259                        STR      r1,[r3,#&24]
000836  7bfb                        LDRB     r3,[r7,#&f]
000838  7bb9                        LDRB     r1,[r7,#&e]
00083a  021b                        LSL      r3,#8
00083c  4319                        ORR      r1,r3
00083e  4b35                        LDR      r3,F14L1+4
000840  1909                        ADD      r1,r4
;;;1163   
;;;1164   	filesysRootDir = filesysFAT + (bootSec->numFATs * filesysSecPerFAT);
000842  60d9                        STR      r1,[r3,#&c]
000844  7c3a                        LDRB     r2,[r7,#&10]
000846  691b                        LDR      r3,[r3,#&10]
000848  435a                        MUL      r2,r3
00084a  4b32                        LDR      r3,F14L1+4
00084c  1854                        ADD      r4,r2,r1
;;;1165   	filesysData = filesysRootDir + ((bootSec->rootEntries * sizeof(DIR_ENT)) / filesysBytePerSec);
00084e  605c                        STR      r4,[r3,#4]
000850  7c79                        LDRB     r1,[r7,#&11]
000852  7cbb                        LDRB     r3,[r7,#&12]
000854  021b                        LSL      r3,#8
000856  4319                        ORR      r1,r3
000858  0149                        LSL      r1,#5
00085a  f7ff fbd1                   BL       __16__rt_udiv
00085e  4b2d                        LDR      r3,F14L1+4
000860  1900                        ADD      r0,r4
;;;1166   
;;;1167   	// Store info about FAT
;;;1168   	fatLastCluster = (filesysNumSec - filesysData) / bootSec->sectorsPerCluster;
000862  6198                        STR      r0,[r3,#&18]
000864  6959                        LDR      r1,[r3,#&14]
000866  1a09                        SUB      r1,r0
000868  1c30                        MOV      r0,r6
00086a  f7ff fbc9                   BL       __16__rt_sdiv
00086e  4b29                        LDR      r3,F14L1+4
;;;1169   	fatFirstFree = CLUSTER_FIRST;
000870  2402                        MOV      r4,#2
000872  62d8                        STR      r0,[r3,#&2c]
;;;1170   	fatBufferCurSector = 0;
000874  2600                        MOV      r6,#0
000876  1c30                        MOV      r0,r6
000878  631c                        STR      r4,[r3,#&30]
;;;1171   	disc_ReadSector(fatBufferCurSector, fatBuffer);
00087a  635e                        STR      r6,[r3,#&34]
00087c  2101                        MOV      r1,#1
00087e  4a27                        LDR      r2,F14L1+12
000880  f7ff fbee                   BL       MPCF_ReadSectors
;;;1172   
;;;1173   	if (fatLastCluster < 4085)
000884  4b23                        LDR      r3,F14L1+4
000886  6ad9                        LDR      r1,[r3,#&2c]
000888  1dd8                        ADD      r0,r3,#7
00088a  4b25                        LDR      r3,F14L1+16
00088c  3019                        ADD      r0,#&19
00088e  4299                        CMP      r1,r3
000890  d201                        BCS      F14L76
;;;1174   	{
;;;1175   		filesysType = FS_FAT12;	// FAT12 volume - unsupported
000892  2101                        MOV      r1,#1
000894  e005                        B        F14L77
                            F14L76
;;;1176   	}
;;;1177   	else if (fatLastCluster < 65525)
000896  4b23                        LDR      r3,F14L1+20
000898  4299                        CMP      r1,r3
00089a  d201                        BCS      F14L78
;;;1178   	{
;;;1179   		filesysType = FS_FAT16;	// FAT16 volume
00089c  7204                        STRB     r4,[r0,#8]
00089e  e001                        B        F14L79
                            F14L78
;;;1180   	}
;;;1181   	else
;;;1182   	{
;;;1183   		filesysType = FS_FAT32;	// FAT32 volume
0008a0  2103                        MOV      r1,#3
                            F14L77
0008a2  7201                        STRB     r1,[r0,#8]
                            F14L79
;;;1184   	}
;;;1185   
;;;1186   	if (filesysType != FS_FAT32)
0008a4  7a00                        LDRB     r0,[r0,#8]
0008a6  4c1b                        LDR      r4,F14L1+4
0008a8  2803                        CMP      r0,#3
0008aa  d001                        BEQ      F14L80
;;;1187   	{
;;;1188   		filesysRootDirClus = FAT16_ROOT_DIR_CLUSTER;
0008ac  60a6                        STR      r6,[r4,#8]
0008ae  e011                        B        F14L81
                            F14L80
;;;1189   	}
;;;1190   	else	// Set up for the FAT32 way
;;;1191   	{
;;;1192   		filesysRootDirClus = bootSec->extBlock.fat32.rootClus;
0008b0  1df8                        ADD      r0,r7,#7
0008b2  3025                        ADD      r0,#&25
0008b4  f7ff fba4                   BL       __16_uread4
;;;1193   		// Check if FAT mirroring is enabled
;;;1194   		if (!(bootSec->extBlock.fat32.extFlags & 0x80))
0008b8  60a0                        STR      r0,[r4,#8]
0008ba  7a28                        LDRB     r0,[r5,#8]
0008bc  7a6b                        LDRB     r3,[r5,#9]
0008be  021b                        LSL      r3,#8
0008c0  4318                        ORR      r0,r3
0008c2  0a01                        LSR      r1,r0,#8
0008c4  d206                        BCS      F14L81
;;;1195   		{
;;;1196   			// Use the active FAT
;;;1197   			filesysFAT = filesysFAT + ( filesysSecPerFAT * (bootSec->extBlock.fat32.extFlags & 0x0F));
0008c6  0700                        LSL      r0,#28
0008c8  6921                        LDR      r1,[r4,#&10]
0008ca  0f00                        LSR      r0,#28
0008cc  4348                        MUL      r0,r1
0008ce  68e1                        LDR      r1,[r4,#&c]
0008d0  1840                        ADD      r0,r1
0008d2  60e0                        STR      r0,[r4,#&c]
                            F14L81
;;;1198   		}
;;;1199   	}
;;;1200   
;;;1201   	// Set current directory to the root
;;;1202   	curWorkDirCluster = filesysRootDirClus;
0008d4  68a0                        LDR      r0,[r4,#8]
;;;1203   	wrkDirCluster = filesysRootDirClus;
;;;1204   	wrkDirSector = 0;
;;;1205   	wrkDirOffset = 0;
;;;1206   
;;;1207   	// Set all files to free
;;;1208   	for (i=0; i < MAX_FILES_OPEN; i++)
0008d6  4914                        LDR      r1,F14L1+24
0008d8  63a0                        STR      r0,[r4,#&38]   ;;;1203
0008da  63e0                        STR      r0,[r4,#&3c]   ;;;1205
0008dc  6426                        STR      r6,[r4,#&40]   ;;;1205
0008de  6466                        STR      r6,[r4,#&44]
0008e0  2000                        MOV      r0,#0
                            F14L50
;;;1209   	{
;;;1210   		openFiles[i].inUse = false;
0008e2  228f                        MOV      r2,#&8f
0008e4  0092                        LSL      r2,#2
0008e6  4342                        MUL      r2,r0
0008e8  1852                        ADD      r2,r1
0008ea  32ff                        ADD      r2,#&ff
0008ec  32ff                        ADD      r2,#&ff
0008ee  3202                        ADD      r2,#2
0008f0  3001                        ADD      r0,#1   ;;;1208
0008f2  2802                        CMP      r0,#2   ;;;1208
0008f4  6316                        STR      r6,[r2,#&30]   ;;;1208
0008f6  dbf4                        BLT      F14L50   ;;;1208
;;;1211   	}
;;;1212   
;;;1213   	// No long filenames so far
;;;1214   	lfnExists = false;
;;;1215   	for (i = 0; i < MAX_FILENAME_LENGTH; i++)
0008f8  2000                        MOV      r0,#0
0008fa  22ff                        MOV      r2,#&ff
0008fc  490b                        LDR      r1,F14L1+28
0008fe  3201                        ADD      r2,#1
000900  6026                        STR      r6,[r4,#0]
                            F14L52
;;;1216   	{
;;;1217   		lfnName[i] = '\0';
000902  540e                        STRB     r6,[r1,r0]
000904  3001                        ADD      r0,#1   ;;;1215
000906  4290                        CMP      r0,r2   ;;;1215
000908  dbfb                        BLT      F14L52   ;;;1215
;;;1218   	}
;;;1219   
;;;1220   	return (true);
00090a  2001                        MOV      r0,#1
00090c  e723                        B        F14L61
00090e  0000                        LSL      r0,#0
                            F14L1
000910  00000000                    DCD      globalBuffer
000914  00000000                    DCD      |x$dataseg|
000918  00000020                    DCD      globalBuffer+32
00091c  00000000                    DCD      fatBuffer
000920  00000ff5                    DCD      0x00000ff5
000924  0000fff5                    DCD      0x0000fff5
000928  00000000                    DCD      openFiles
00092c  00000000                    DCD      lfnName

;;;1221   }
;;;1222   
;;;1223   /*-----------------------------------------------------------------
;;;1224   FAT_FreeFiles
;;;1225   Closes all open files then resets the CF card.
;;;1226   Call this before exiting back to the GBAMP
;;;1227   bool return OUT: true if successful.
;;;1228   -----------------------------------------------------------------*/
;;;1229   bool FAT_FreeFiles (void)
;;;1230   {
000930                      FAT_FreeFiles
000930  b590                        PUSH     {r4,r7,lr}
;;;1231   	int i;
;;;1232   
;;;1233   	// Close all open files
;;;1234   	for (i=0; i < MAX_FILES_OPEN; i++)
000932  4c0c                        LDR      r4,F15L1
000934  2700                        MOV      r7,#0
                            F15L4
;;;1235   	{
;;;1236   		if (openFiles[i].inUse == true)
000936  208f                        MOV      r0,#&8f
000938  0080                        LSL      r0,#2
00093a  4378                        MUL      r0,r7
00093c  1900                        ADD      r0,r4
00093e  1dc1                        ADD      r1,r0,#7
000940  31ff                        ADD      r1,#&ff
000942  31fa                        ADD      r1,#&fa
000944  6b09                        LDR      r1,[r1,#&30]
000946  2901                        CMP      r1,#1
000948  d101                        BNE      F15L13
;;;1237   		{
;;;1238   			FAT_fclose(&openFiles[i]);
00094a  f7ff fb59                   BL       FAT_fclose
                            F15L13
00094e  3701                        ADD      r7,#1   ;;;1234
000950  2f02                        CMP      r7,#2   ;;;1234
000952  dbf0                        BLT      F15L4   ;;;1234
;;;1239   		}
;;;1240   	}
;;;1241   
;;;1242   	// Clear card status
;;;1243   	disc_ClearStatus();
000954  f7ff fb60                   BL       MPCF_ClearStatus
;;;1244   
;;;1245   	// Return status of card
;;;1246   	return disc_IsInserted();
000958  f7ff fb52                   BL       MPCF_IsInserted
00095c  bc90                        POP      {r4,r7}
00095e  bc08                        POP      {r3}
000960  4718                        BX       r3
000962  0000                        LSL      r0,#0
                            F15L1
000964  00000000                    DCD      openFiles

;;;1247   }
;;;1248   
;;;1249   
;;;1250   /*-----------------------------------------------------------------
;;;1251   FAT_GetDirEntry
;;;1252   Return the file info structure of the next valid file entry
;;;1253   u32 dirCluster: IN cluster of subdirectory table
;;;1254   int entry: IN the desired file entry
;;;1255   int origin IN: relative position of the entry
;;;1256   DIR_ENT return OUT: desired dirEntry. First char will be FILE_FREE if 
;;;1257   	the entry does not exist.
;;;1258   -----------------------------------------------------------------*/
;;;1259   DIR_ENT FAT_GetDirEntry ( u32 dirCluster, int entry, int origin)
;;;1260   {
000968                      FAT_GetDirEntry
000968  b5ff                        PUSH     {r0-r7,lr}
00096a  b096                        SUB      sp,#&58
;;;1261   	DIR_ENT dir;
;;;1262   	DIR_ENT_LFN lfn;
;;;1263   	int firstSector = 0;
;;;1264   	bool notFound = false;
;;;1265   	bool found = false;
00096c  2000                        MOV      r0,#0
00096e  9005                        STR      r0,[sp,#&14]
;;;1266   	int maxSectors;
;;;1267   	int lfnPos, aliasPos;
;;;1268   	u8 lfnChkSum, chkSum;
;;;1269   
;;;1270   	dir.name[0] = FILE_FREE; // default to no file found
000970  20e5                        MOV      r0,#&e5
000972  ab0e                        ADD      r3,sp,#&38
000974  7018                        STRB     r0,[r3,#0]
;;;1271   	dir.attrib = 0x00;
000976  2000                        MOV      r0,#0
000978  72d8                        STRB     r0,[r3,#&b]
;;;1272   
;;;1273   	// Check if fat has been initialised
;;;1274   	if (filesysBytePerSec == 0)
00097a  4887                        LDR      r0,F16L1
00097c  1c17                        MOV      r7,r2
00097e  69c2                        LDR      r2,[r0,#&1c]
000980  3308                        ADD      r3,#8
000982  2400                        MOV      r4,#0   ;;;1264
000984  2a00                        CMP      r2,#0
000986  d073                        BEQ      F16L85
;;;1275   	{
;;;1276   		return (dir);
;;;1277   	}
;;;1278   	
;;;1279   	switch (origin) 
000988  9b19                        LDR      r3,[sp,#&64]
00098a  43e2                        MVN      r2,r4
00098c  2b00                        CMP      r3,#0
00098e  d011                        BEQ      F16L86
000990  2b01                        CMP      r3,#1
000992  d013                        BEQ      F16L87
000994  2b02                        CMP      r3,#2
000996  d16c                        BNE      F16L88
;;;1280   	{
;;;1281   	case SEEK_SET:
;;;1282   		wrkDirCluster = dirCluster;
;;;1283   		wrkDirSector = 0;
;;;1284   		wrkDirOffset = -1;
;;;1285   		break;
;;;1286   	case SEEK_CUR:	// Don't change anything
;;;1287   		break;
;;;1288   	case SEEK_END:	// Find entry signifying end of directory
;;;1289   		// Subtraction will never reach 0, so it keeps going 
;;;1290   		// until reaches end of directory
;;;1291   		wrkDirCluster = dirCluster;
;;;1292   		wrkDirSector = 0;
000998  63c1                        STR      r1,[r0,#&3c]
00099a  2100                        MOV      r1,#0
;;;1293   		wrkDirOffset = -1;
00099c  6401                        STR      r1,[r0,#&40]
;;;1294   		entry = -1;
00099e  6442                        STR      r2,[r0,#&44]
0009a0  43cf                        MVN      r7,r1
0009a2  e00b                        B        F16L89
                            F16L6
0009a4  2220                        MOV      r2,#&20   ;;;1276
0009a6  9816                        LDR      r0,[sp,#&58]   ;;;1276
0009a8  f7ff fb2a                   BL       memcpy   ;;;1276
0009ac  b01a                        ADD      sp,#&68   ;;;1276
0009ae  bcf0                        POP      {r4-r7}   ;;;1276
0009b0  bc08                        POP      {r3}   ;;;1276
0009b2  4718                        BX       r3   ;;;1276
                            F16L86
0009b4  63c1                        STR      r1,[r0,#&3c]   ;;;1283
0009b6  2100                        MOV      r1,#0   ;;;1283
0009b8  6401                        STR      r1,[r0,#&40]   ;;;1284
0009ba  6442                        STR      r2,[r0,#&44]   ;;;1284
                            F16L87
                            F16L89
;;;1295   		break;
;;;1296   	default:
;;;1297   		return dir;
;;;1298   	}
;;;1299   
;;;1300   	lfnChkSum = 0;
;;;1301   	maxSectors = (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? (filesysData - filesysRootDir) : filesysSecPerClus);
;;;1302   
;;;1303   	// Scan Dir for correct entry
;;;1304   	firstSector = (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster));
0009bc  6bc1                        LDR      r1,[r0,#&3c]
0009be  2600                        MOV      r6,#0   ;;;1300
0009c0  6a02                        LDR      r2,[r0,#&20]
0009c2  6845                        LDR      r5,[r0,#4]
0009c4  2900                        CMP      r1,#0
0009c6  d003                        BEQ      F16L90
0009c8  3902                        SUB      r1,#2
0009ca  4351                        MUL      r1,r2
0009cc  6982                        LDR      r2,[r0,#&18]
0009ce  188d                        ADD      r5,r1,r2
                            F16L90
;;;1305   	disc_ReadSector (firstSector + wrkDirSector, globalBuffer);
0009d0  4871                        LDR      r0,F16L1
0009d2  4a72                        LDR      r2,F16L1+4
0009d4  6c00                        LDR      r0,[r0,#&40]
0009d6  1828                        ADD      r0,r5,r0
0009d8  2101                        MOV      r1,#1
0009da  f7ff fb41                   BL       MPCF_ReadSectors
                            F16L21
;;;1306   	found = false;
;;;1307   	notFound = false;
;;;1308   	do {
;;;1309   		wrkDirOffset++;
0009de  496e                        LDR      r1,F16L1
0009e0  6c48                        LDR      r0,[r1,#&44]
0009e2  3001                        ADD      r0,#1
;;;1310   		if (wrkDirOffset == BYTE_PER_READ / sizeof (DIR_ENT))
0009e4  6448                        STR      r0,[r1,#&44]
0009e6  2810                        CMP      r0,#&10
0009e8  d12c                        BNE      F16L91
;;;1311   		{
;;;1312   			wrkDirOffset = 0;
0009ea  4b6b                        LDR      r3,F16L1
0009ec  2200                        MOV      r2,#0
;;;1313   			wrkDirSector++;
0009ee  645a                        STR      r2,[r3,#&44]
0009f0  6c18                        LDR      r0,[r3,#&40]
0009f2  1c41                        ADD      r1,r0,#1
;;;1314   			if ((wrkDirSector == filesysSecPerClus) && (wrkDirCluster != FAT16_ROOT_DIR_CLUSTER))
0009f4  6419                        STR      r1,[r3,#&40]
0009f6  6a18                        LDR      r0,[r3,#&20]
0009f8  4281                        CMP      r1,r0
0009fa  d111                        BNE      F16L92
0009fc  6bd8                        LDR      r0,[r3,#&3c]
0009fe  2800                        CMP      r0,#0
000a00  d012                        BEQ      F16L93
;;;1315   			{
;;;1316   				wrkDirSector = 0;
;;;1317   				wrkDirCluster = FAT_NextCluster(wrkDirCluster);
000a02  641a                        STR      r2,[r3,#&40]
000a04  1c1d                        MOV      r5,r3
000a06  f7ff fc19                   BL       FAT_NextCluster
;;;1318   				if (wrkDirCluster == CLUSTER_EOF)
000a0a  4b65                        LDR      r3,F16L1+8
000a0c  63e8                        STR      r0,[r5,#&3c]
000a0e  4298                        CMP      r0,r3
000a10  d100                        BNE      F16L94
;;;1319   				{
;;;1320   					notFound = true;
000a12  2401                        MOV      r4,#1
                            F16L94
;;;1321   				}
;;;1322   				firstSector = FAT_ClustToSect(wrkDirCluster);		
000a14  6a29                        LDR      r1,[r5,#&20]
000a16  3802                        SUB      r0,#2
000a18  4348                        MUL      r0,r1
000a1a  69a9                        LDR      r1,[r5,#&18]
000a1c  1845                        ADD      r5,r0,r1
000a1e  e00a                        B        F16L95
                            F16L92
;;;1323   			}
;;;1324   			else if ((wrkDirCluster == FAT16_ROOT_DIR_CLUSTER) && (wrkDirSector == (filesysData - filesysRootDir)))
000a20  4b5d                        LDR      r3,F16L1
000a22  6bd8                        LDR      r0,[r3,#&3c]
000a24  2800                        CMP      r0,#0
000a26  d106                        BNE      F16L95
                            F16L93
000a28  4b5b                        LDR      r3,F16L1
000a2a  6998                        LDR      r0,[r3,#&18]
000a2c  685a                        LDR      r2,[r3,#4]
000a2e  1a80                        SUB      r0,r2
000a30  4288                        CMP      r0,r1
000a32  d100                        BNE      F16L96
;;;1325   			{
;;;1326   				notFound = true;	// Got to end of root dir
000a34  2401                        MOV      r4,#1
                            F16L95
                            F16L96
;;;1327   			}
;;;1328   			disc_ReadSector (firstSector + wrkDirSector, globalBuffer);
000a36  4b58                        LDR      r3,F16L1
000a38  4a58                        LDR      r2,F16L1+4
000a3a  6c18                        LDR      r0,[r3,#&40]
000a3c  1828                        ADD      r0,r5,r0
000a3e  2101                        MOV      r1,#1
000a40  f7ff fb0e                   BL       MPCF_ReadSectors
                            F16L91
;;;1329   		}
;;;1330   		dir = ((DIR_ENT*) globalBuffer)[wrkDirOffset];
000a44  4854                        LDR      r0,F16L1
000a46  4955                        LDR      r1,F16L1+4
000a48  6c40                        LDR      r0,[r0,#&44]
000a4a  0140                        LSL      r0,#5
000a4c  1841                        ADD      r1,r0,r1
000a4e  a80e                        ADD      r0,sp,#&38
000a50  2220                        MOV      r2,#&20
000a52  f7ff fad5                   BL       memcpy
;;;1331   		if ((dir.name[0] != FILE_FREE) && (dir.name[0] > 0x20) && ((dir.attrib & ATTRIB_VOL) != ATTRIB_VOL))
000a56  a80e                        ADD      r0,sp,#&38
000a58  7800                        LDRB     r0,[r0,#0]
000a5a  28e5                        CMP      r0,#&e5
000a5c  d048                        BEQ      F16L97
000a5e  a80e                        ADD      r0,sp,#&38
000a60  7800                        LDRB     r0,[r0,#0]
000a62  2820                        CMP      r0,#&20
000a64  dd3b                        BLE      F16L98
000a66  a810                        ADD      r0,sp,#&40
000a68  78c0                        LDRB     r0,[r0,#3]
000a6a  2308                        MOV      r3,#8
000a6c  4018                        AND      r0,r3
000a6e  e001                        B        F16L100
                            F16L85
000a70  e090                        B        F16L101
                            F16L88
000a72  e08f                        B        F16L102
                            F16L100
000a74  2808                        CMP      r0,#8
000a76  d032                        BEQ      F16L103
;;;1332   		{
;;;1333   			entry--;
;;;1334   			if (lfnExists)
000a78  4847                        LDR      r0,F16L1
000a7a  3f01                        SUB      r7,#1
000a7c  6800                        LDR      r0,[r0,#0]
000a7e  2800                        CMP      r0,#0
000a80  d017                        BEQ      F16L104
;;;1335   			{
;;;1336   				// Calculate file checksum
;;;1337   				chkSum = 0;
000a82  2100                        MOV      r1,#0
;;;1338   				for (aliasPos=0; aliasPos < 11; aliasPos++)
000a84  2000                        MOV      r0,#0
                            F16L39
;;;1339   				{
;;;1340   					// NOTE: The operation is an unsigned char rotate right
;;;1341   					chkSum = ((chkSum & 1) ? 0x80 : 0) + (chkSum >> 1) + (aliasPos < 8 ? dir.name[aliasPos] : dir.ext[aliasPos - 8]);
000a86  2280                        MOV      r2,#&80
000a88  084b                        LSR      r3,r1,#1
000a8a  d200                        BCS      F16L105
000a8c  2200                        MOV      r2,#0
                            F16L105
000a8e  1049                        ASR      r1,#1
000a90  1851                        ADD      r1,r2,r1
000a92  aa0e                        ADD      r2,sp,#&38
000a94  1812                        ADD      r2,r0
000a96  7812                        LDRB     r2,[r2,#0]
000a98  1889                        ADD      r1,r2
000a9a  0609                        LSL      r1,#24
000a9c  0e09                        LSR      r1,#24
000a9e  3001                        ADD      r0,#1   ;;;1338
000aa0  280b                        CMP      r0,#&b   ;;;1338
000aa2  dbf0                        BLT      F16L39   ;;;1338
;;;1342   				}
;;;1343   				if (chkSum != lfnChkSum)
000aa4  42b1                        CMP      r1,r6
000aa6  d004                        BEQ      F16L104
;;;1344   				{
;;;1345   					lfnExists = false;
000aa8  483b                        LDR      r0,F16L1
000aaa  2200                        MOV      r2,#0
;;;1346   					lfnName[0] = '\0';
000aac  493d                        LDR      r1,F16L1+12
000aae  6002                        STR      r2,[r0,#0]
000ab0  700a                        STRB     r2,[r1,#0]
                            F16L104
;;;1347   				}
;;;1348   			}
;;;1349   			if (entry == 0) 
000ab2  2f00                        CMP      r7,#0
000ab4  d161                        BNE      F16L106
;;;1350   			{
;;;1351   				if (!lfnExists)
000ab6  4838                        LDR      r0,F16L1
000ab8  6800                        LDR      r0,[r0,#0]
000aba  2800                        CMP      r0,#0
000abc  d164                        BNE      F16L107
;;;1352   				{
;;;1353   					FAT_GetFilename (dir, lfnName);
000abe  4a39                        LDR      r2,F16L1+12
000ac0  a912                        ADD      r1,sp,#&48
000ac2  9204                        STR      r2,[sp,#&10]
000ac4  c90c                        LDMIA    r1!,{r2,r3}
000ac6  4668                        MOV      r0,sp
000ac8  c00c                        STMIA    r0!,{r2,r3}
000aca  c90c                        LDMIA    r1!,{r2,r3}
000acc  c00c                        STMIA    r0!,{r2,r3}
000ace  af0e                        ADD      r7,sp,#&38
000ad0  cf83                        LDMIA    r7!,{r0,r1,r7}
000ad2  9d11                        LDR      r5,[sp,#&44]
000ad4  1c3a                        MOV      r2,r7
000ad6  1c2b                        MOV      r3,r5
000ad8  f7ff fa92                   BL       FAT_GetFilename
000adc  e055                        B        F16L108
                            F16L98
                            F16L103
;;;1354   				}
;;;1355   				found = true;
;;;1356   			}
;;;1357   		}
;;;1358   		else if (dir.name[0] == FILE_LAST)
000ade  a80e                        ADD      r0,sp,#&38
000ae0  7800                        LDRB     r0,[r0,#0]
000ae2  2800                        CMP      r0,#0
000ae4  d104                        BNE      F16L109
;;;1359   		{
;;;1360   			if (origin == SEEK_END)
000ae6  9b19                        LDR      r3,[sp,#&64]
000ae8  2b02                        CMP      r3,#2
000aea  d04e                        BEQ      F16L108
;;;1361   			{
;;;1362   				found = true;
;;;1363   			}
;;;1364   			else
;;;1365   			{
;;;1366   				notFound = true;
000aec  2401                        MOV      r4,#1
000aee  e044                        B        F16L110
                            F16L97
                            F16L109
;;;1367   			}
;;;1368   		}
;;;1369   		else if (dir.attrib == ATTRIB_LFN)
000af0  a810                        ADD      r0,sp,#&40
000af2  78c0                        LDRB     r0,[r0,#3]
000af4  280f                        CMP      r0,#&f
000af6  d140                        BNE      F16L106
;;;1370   		{
;;;1371   			lfn = ((DIR_ENT_LFN*) globalBuffer)[wrkDirOffset];
000af8  4827                        LDR      r0,F16L1
000afa  4928                        LDR      r1,F16L1+4
000afc  6c40                        LDR      r0,[r0,#&44]
000afe  0140                        LSL      r0,#5
000b00  1841                        ADD      r1,r0,r1
000b02  a806                        ADD      r0,sp,#&18
000b04  2220                        MOV      r2,#&20
000b06  f7ff fa7b                   BL       memcpy
;;;1372   /*
;;;1373   			if (lfn.ordinal & LFN_END)
;;;1374   			{
;;;1375   				lfnExists = true;
;;;1376   				lfnName[(lfn.ordinal & ~LFN_END) * 13] = '\0';	// Set end of lfn to null character
;;;1377   				lfnChkSum = lfn.checkSum;
;;;1378   			}
;;;1379   			if (lfn.ordinal & LFN_DEL)
;;;1380   			{
;;;1381   				lfnExists = false;
;;;1382   			}
;;;1383   */
;;;1384   // /*
;;;1385   			if (lfn.ordinal & LFN_DEL)
000b0a  a806                        ADD      r0,sp,#&18
000b0c  7800                        LDRB     r0,[r0,#0]
000b0e  0a00                        LSR      r0,#8
000b10  d303                        BCC      F16L111
;;;1386   			{
;;;1387   				lfnExists = false;
000b12  4821                        LDR      r0,F16L1
000b14  2200                        MOV      r2,#0
000b16  6002                        STR      r2,[r0,#0]
000b18  e011                        B        F16L112
                            F16L111
;;;1388   			}
;;;1389   			else if (lfn.ordinal & LFN_END)	// Last part of LFN, make sure it isn't deleted (Thanks MoonLight)
000b1a  a806                        ADD      r0,sp,#&18
000b1c  7800                        LDRB     r0,[r0,#0]
000b1e  09c0                        LSR      r0,#7
000b20  d30d                        BCC      F16L112
;;;1390   			{
;;;1391   				lfnExists = true;
000b22  491d                        LDR      r1,F16L1
000b24  2001                        MOV      r0,#1
;;;1392   				lfnName[(lfn.ordinal & ~LFN_END) * 13] = '\0';	// Set end of lfn to null character
000b26  6008                        STR      r0,[r1,#0]
000b28  a806                        ADD      r0,sp,#&18
000b2a  7800                        LDRB     r0,[r0,#0]
000b2c  2200                        MOV      r2,#0
000b2e  2340                        MOV      r3,#&40
000b30  4398                        BIC      r0,r3
000b32  230d                        MOV      r3,#&d
000b34  4358                        MUL      r0,r3
000b36  491b                        LDR      r1,F16L1+12
;;;1393   				lfnChkSum = lfn.checkSum;
000b38  ae09                        ADD      r6,sp,#&24
000b3a  540a                        STRB     r2,[r1,r0]   ;;;1392
000b3c  7876                        LDRB     r6,[r6,#1]
                            F16L112
;;;1394   			}
;;;1395   //			*/
;;;1396   			if (lfnChkSum != lfn.checkSum)
000b3e  a809                        ADD      r0,sp,#&24
000b40  7840                        LDRB     r0,[r0,#1]
000b42  42b0                        CMP      r0,r6
000b44  d003                        BEQ      F16L113
;;;1397   			{
;;;1398   				lfnExists = false;
000b46  4814                        LDR      r0,F16L1
000b48  2200                        MOV      r2,#0
000b4a  6002                        STR      r2,[r0,#0]
000b4c  e015                        B        F16L110
                            F16L113
;;;1399   			}
;;;1400   			if (lfnExists)
000b4e  4812                        LDR      r0,F16L1
000b50  6800                        LDR      r0,[r0,#0]
000b52  2800                        CMP      r0,#0
000b54  d011                        BEQ      F16L110
;;;1401   			{
;;;1402   				int ii,jj;
;;;1403   				u8 *lfn_str = (u8*)lfnName + ((lfn.ordinal & ~LFN_END) - 1) * 13;
000b56  a806                        ADD      r0,sp,#&18
000b58  7800                        LDRB     r0,[r0,#0]
000b5a  2340                        MOV      r3,#&40
000b5c  4911                        LDR      r1,F16L1+12
000b5e  4398                        BIC      r0,r3
000b60  230d                        MOV      r3,#&d
000b62  4358                        MUL      r0,r3
000b64  1840                        ADD      r0,r1
000b66  1ac1                        SUB      r1,r0,r3
;;;1404   //				lfnPos = ((lfn.ordinal & ~LFN_END) - 1) * 13;
;;;1405   				//new code
;;;1406   				for (ii=0;ii<13;ii++)
000b68  2000                        MOV      r0,#0
                            F16L71
;;;1407   				{
;;;1408   					jj=lfn_offset_table[ii];
000b6a  4a0f                        LDR      r2,F16L1+16
000b6c  5c13                        LDRB     r3,[r2,r0]
;;;1409   					lfn_str[ii]=((u8*)&lfn)[jj];
000b6e  aa06                        ADD      r2,sp,#&18
000b70  5cd2                        LDRB     r2,[r2,r3]
000b72  540a                        STRB     r2,[r1,r0]
000b74  3001                        ADD      r0,#1   ;;;1406
000b76  280d                        CMP      r0,#&d   ;;;1406
000b78  dbf7                        BLT      F16L71   ;;;1406
                            F16L106
                            F16L110
;;;1410   				}
;;;1411   /*				
;;;1412   				lfnName[lfnPos + 0] = lfn.char0 & 0xFF;
;;;1413   				lfnName[lfnPos + 1] = lfn.char1 & 0xFF;
;;;1414   				lfnName[lfnPos + 2] = lfn.char2 & 0xFF;
;;;1415   				lfnName[lfnPos + 3] = lfn.char3 & 0xFF;
;;;1416   				lfnName[lfnPos + 4] = lfn.char4 & 0xFF;
;;;1417   				lfnName[lfnPos + 5] = lfn.char5 & 0xFF;
;;;1418   				lfnName[lfnPos + 6] = lfn.char6 & 0xFF;
;;;1419   				lfnName[lfnPos + 7] = lfn.char7 & 0xFF;
;;;1420   				lfnName[lfnPos + 8] = lfn.char8 & 0xFF;
;;;1421   				lfnName[lfnPos + 9] = lfn.char9 & 0xFF;
;;;1422   				lfnName[lfnPos + 10] = lfn.char10 & 0xFF;
;;;1423   				lfnName[lfnPos + 11] = lfn.char11 & 0xFF;
;;;1424   				lfnName[lfnPos + 12] = lfn.char12 & 0xFF;
;;;1425   */
;;;1426   			}
;;;1427   		}
;;;1428   	} while (!found && !notFound);
000b7a  9805                        LDR      r0,[sp,#&14]
000b7c  2800                        CMP      r0,#0
000b7e  d103                        BNE      F16L107
000b80  2c00                        CMP      r4,#0
000b82  d100                        BNE      F16L114
000b84  e72b                        B        F16L21
                            F16L114
000b86  e002                        B        F16L115
                            F16L107
000b88  e7ff                        B        F16L116
                            F16L108
                            F16L116
;;;1429   	
;;;1430   	// If no file is found, return FILE_FREE
;;;1431   	if (notFound)
000b8a  2c00                        CMP      r4,#0
000b8c  d002                        BEQ      F16L101
                            F16L115
;;;1432   	{
;;;1433   		dir.name[0] = FILE_FREE;
000b8e  20e5                        MOV      r0,#&e5
000b90  ab0e                        ADD      r3,sp,#&38
000b92  7018                        STRB     r0,[r3,#0]
                            F16L101
                            F16L102
;;;1434   	}
;;;1435   
;;;1436   	return (dir);
000b94  a90e                        ADD      r1,sp,#&38
000b96  e705                        B        F16L6
                            F16L1
000b98  00000000                    DCD      |x$dataseg|
000b9c  00000000                    DCD      globalBuffer
000ba0  0fffffff                    DCD      0x0fffffff
000ba4  00000000                    DCD      lfnName
000ba8  00000000                    DCD      |x$constdata|

;;;1437   }
;;;1438   
;;;1439   
;;;1440   /*-----------------------------------------------------------------
;;;1441   FAT_GetLongFilename
;;;1442   Get the long name of the last file or directory retrived with 
;;;1443   	GetDirEntry. Also works for FindFirstFile and FindNextFile.
;;;1444   	If a long name doesn't exist, it returns the short name
;;;1445   	instead.
;;;1446   char* filename: OUT will be filled with the filename, should be at
;;;1447   	least 256 bytes long
;;;1448   bool return OUT: return true if successful
;;;1449   -----------------------------------------------------------------*/
;;;1450   bool FAT_GetLongFilename (char* filename)
;;;1451   {
000bac                      FAT_GetLongFilename
000bac  b590                        PUSH     {r4,r7,lr}
000bae  2400                        MOV      r4,#0
;;;1452   	if (filename == NULL)
000bb0  1c07                        MOV      r7,r0
000bb2  2800                        CMP      r0,#0
000bb4  d103                        BNE      F17L10
;;;1453   		return false;
000bb6  1c20                        MOV      r0,r4
                            F17L8
000bb8  bc90                        POP      {r4,r7}
000bba  bc08                        POP      {r3}
000bbc  4718                        BX       r3
                            F17L10
;;;1454   
;;;1455   	strncpy (filename, lfnName, MAX_FILENAME_LENGTH - 1);
000bbe  22ff                        MOV      r2,#&ff
000bc0  1c38                        MOV      r0,r7
000bc2  4904                        LDR      r1,F17L1
000bc4  f7ff fa1c                   BL       strncpy
;;;1456   	filename[MAX_FILENAME_LENGTH - 1] = '\0';
000bc8  1df8                        ADD      r0,r7,#7
000bca  30e9                        ADD      r0,#&e9
000bcc  73c4                        STRB     r4,[r0,#&f]
;;;1457   	
;;;1458   	return true;
000bce  2001                        MOV      r0,#1
000bd0  e7f2                        B        F17L8
000bd2  0000                        LSL      r0,#0
                            F17L1
000bd4  00000000                    DCD      lfnName

;;;1459   }
;;;1460   
;;;1461   
;;;1462   /*-----------------------------------------------------------------
;;;1463   FAT_GetFilename
;;;1464   Get the alias (short name) of the file or directory stored in 
;;;1465   	dirEntry
;;;1466   DIR_ENT dirEntry: IN a valid directory table entry
;;;1467   char* alias OUT: will be filled with the alias (short filename),
;;;1468   	should be at least 13 bytes long
;;;1469   bool return OUT: return true if successful
;;;1470   -----------------------------------------------------------------*/
;;;1471   bool FAT_GetFilename (DIR_ENT dirEntry, char* alias)
;;;1472   {
000bd8                      FAT_GetFilename
000bd8  b40f                        PUSH     {r0-r3}
000bda  b590                        PUSH     {r4,r7,lr}
;;;1473   	int i=0;
;;;1474   	int j=0;
;;;1475   
;;;1476   	alias[0] = '\0';
000bdc  990b                        LDR      r1,[sp,#&2c]
000bde  2300                        MOV      r3,#0
000be0  700b                        STRB     r3,[r1,#0]
;;;1477   	if (dirEntry.name[0] != FILE_FREE)
000be2  aa03                        ADD      r2,sp,#&c
000be4  7812                        LDRB     r2,[r2,#0]
000be6  2000                        MOV      r0,#0   ;;;1473
000be8  2ae5                        CMP      r2,#&e5
000bea  d02c                        BEQ      F18L33
;;;1478   	{
;;;1479   		if (dirEntry.name[0] == '.')
000bec  af03                        ADD      r7,sp,#&c
000bee  783f                        LDRB     r7,[r7,#0]
000bf0  222e                        MOV      r2,#&2e
000bf2  2f2e                        CMP      r7,#&2e
000bf4  d10d                        BNE      F18L34
;;;1480   		{
;;;1481   			alias[0] = '.';
000bf6  700a                        STRB     r2,[r1,#0]
;;;1482   			if (dirEntry.name[1] == '.')
000bf8  a803                        ADD      r0,sp,#&c
000bfa  7840                        LDRB     r0,[r0,#1]
000bfc  282e                        CMP      r0,#&2e
000bfe  d102                        BNE      F18L35
;;;1483   			{
;;;1484   				alias[1] = '.';
000c00  704a                        STRB     r2,[r1,#1]
;;;1485   				alias[2] = '\0';
000c02  708b                        STRB     r3,[r1,#2]
000c04  e01f                        B        F18L36
                            F18L35
;;;1486   			}
;;;1487   			else
;;;1488   			{
;;;1489   				alias[1] = '\0';
000c06  704b                        STRB     r3,[r1,#1]
000c08  e01d                        B        F18L36
                            F18L12
;;;1490   			}
;;;1491   		}
;;;1492   		else
;;;1493   		{		
;;;1494   			// Copy the filename from the dirEntry to the string
;;;1495   			for (i = 0; (i < 8) && (dirEntry.name[i] != ' '); i++)
;;;1496   			{
;;;1497   				alias[i] = dirEntry.name[i];
000c0a  540f                        STRB     r7,[r1,r0]
000c0c  3001                        ADD      r0,#1   ;;;1495
000c0e  2808                        CMP      r0,#8   ;;;1495
000c10  da04                        BGE      F18L37   ;;;1495
                            F18L34
000c12  af03                        ADD      r7,sp,#&c   ;;;1495
000c14  183f                        ADD      r7,r0   ;;;1495
000c16  783f                        LDRB     r7,[r7,#0]   ;;;1495
000c18  2f20                        CMP      r7,#&20   ;;;1495
000c1a  d1f6                        BNE      F18L12   ;;;1495
                            F18L37
;;;1498   			}
;;;1499   			// Copy the extension from the dirEntry to the string
;;;1500   			if (dirEntry.ext[0] != ' ')
000c1c  af05                        ADD      r7,sp,#&14
000c1e  783f                        LDRB     r7,[r7,#0]
000c20  2f20                        CMP      r7,#&20
000c22  d00f                        BEQ      F18L38
;;;1501   			{
;;;1502   				alias[i++] = '.';
000c24  1c07                        MOV      r7,r0
000c26  55ca                        STRB     r2,[r1,r7]
;;;1503   				for ( j = 0; (j < 3) && (dirEntry.ext[j] != ' '); j++)
000c28  2200                        MOV      r2,#0
000c2a  3001                        ADD      r0,#1
000c2c  e005                        B        F18L39
                            F18L19
;;;1504   				{
;;;1505   					alias[i++] = dirEntry.ext[j];
000c2e  1c04                        MOV      r4,r0
000c30  3001                        ADD      r0,#1   ;;;1503
000c32  3201                        ADD      r2,#1   ;;;1503
000c34  2a03                        CMP      r2,#3   ;;;1503
000c36  550f                        STRB     r7,[r1,r4]
000c38  da04                        BGE      F18L40   ;;;1503
                            F18L39
000c3a  af03                        ADD      r7,sp,#&c   ;;;1503
000c3c  18bf                        ADD      r7,r2   ;;;1503
000c3e  7a3f                        LDRB     r7,[r7,#8]   ;;;1503
000c40  2f20                        CMP      r7,#&20   ;;;1503
000c42  d1f4                        BNE      F18L19   ;;;1503
                            F18L38
                            F18L40
;;;1506   				}
;;;1507   			}
;;;1508   			alias[i] = '\0';
000c44  540b                        STRB     r3,[r1,r0]
                            F18L33
                            F18L36
;;;1509   		}
;;;1510   	}
;;;1511   
;;;1512   	return (alias[0] != '\0');
000c46  7809                        LDRB     r1,[r1,#0]
000c48  2001                        MOV      r0,#1
000c4a  2900                        CMP      r1,#0
000c4c  d100                        BNE      F18L41
000c4e  2000                        MOV      r0,#0
                            F18L41
000c50  bc90                        POP      {r4,r7}
000c52  bc08                        POP      {r3}
000c54  b004                        ADD      sp,#&10
000c56  4718                        BX       r3

;;;1513   }
;;;1514   
;;;1515   /*-----------------------------------------------------------------
;;;1516   FAT_GetAlias
;;;1517   Get the alias (short name) of the last file or directory entry read
;;;1518   	using GetDirEntry. Works for FindFirstFile and FindNextFile
;;;1519   char* alias OUT: will be filled with the alias (short filename),
;;;1520   	should be at least 13 bytes long
;;;1521   bool return OUT: return true if successful
;;;1522   -----------------------------------------------------------------*/
;;;1523   bool FAT_GetAlias (char* alias)
;;;1524   {
000c58                      FAT_GetAlias
000c58  b5b0                        PUSH     {r4,r5,r7,lr}
000c5a  b08d                        SUB      sp,#&34
000c5c  1c07                        MOV      r7,r0
000c5e  d104                        BNE      F19L13
;;;1525   	if (alias == NULL)
;;;1526   	{
;;;1527   		return false;
000c60  2000                        MOV      r0,#0
                            F19L11
000c62  b00d                        ADD      sp,#&34
000c64  bcb0                        POP      {r4,r5,r7}
000c66  bc08                        POP      {r3}
000c68  4718                        BX       r3
                            F19L13
;;;1528   	}
;;;1529   	// Read in the last accessed directory entry
;;;1530   	disc_ReadSector ((wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector, globalBuffer);
000c6a  4c12                        LDR      r4,F19L1
000c6c  6860                        LDR      r0,[r4,#4]
000c6e  6be1                        LDR      r1,[r4,#&3c]
000c70  2900                        CMP      r1,#0
000c72  d004                        BEQ      F19L14
000c74  1e88                        SUB      r0,r1,#2
000c76  6a21                        LDR      r1,[r4,#&20]
000c78  4348                        MUL      r0,r1
000c7a  69a1                        LDR      r1,[r4,#&18]
000c7c  1840                        ADD      r0,r1
                            F19L14
000c7e  6c21                        LDR      r1,[r4,#&40]
000c80  4d0d                        LDR      r5,F19L1+4
000c82  1840                        ADD      r0,r1
000c84  2101                        MOV      r1,#1
000c86  1c2a                        MOV      r2,r5
000c88  f7ff f9ea                   BL       MPCF_ReadSectors
;;;1531   	
;;;1532   	return 	FAT_GetFilename (((DIR_ENT*)globalBuffer)[wrkDirOffset], alias);
000c8c  6c60                        LDR      r0,[r4,#&44]
000c8e  0140                        LSL      r0,#5
000c90  1941                        ADD      r1,r0,r5
000c92  a805                        ADD      r0,sp,#&14
000c94  2220                        MOV      r2,#&20
000c96  f7ff f9b3                   BL       memcpy
000c9a  9704                        STR      r7,[sp,#&10]
000c9c  a909                        ADD      r1,sp,#&24
000c9e  c9b8                        LDMIA    r1!,{r3-r5,r7}
000ca0  4668                        MOV      r0,sp
000ca2  c0b8                        STMIA    r0!,{r3-r5,r7}
000ca4  af05                        ADD      r7,sp,#&14
000ca6  cf83                        LDMIA    r7!,{r0,r1,r7}
000ca8  9c08                        LDR      r4,[sp,#&20]
000caa  1c3a                        MOV      r2,r7
000cac  1c23                        MOV      r3,r4
000cae  f7ff ff93                   BL       FAT_GetFilename
000cb2  e7d6                        B        F19L11
                            F19L1
000cb4  00000000                    DCD      |x$dataseg|
000cb8  00000000                    DCD      globalBuffer

;;;1533   }
;;;1534   
;;;1535   /*-----------------------------------------------------------------
;;;1536   FAT_GetFileSize
;;;1537   Get the file size of the last file found or openned.
;;;1538   This idea is based on a modification by MoonLight
;;;1539   u32 return OUT: the file size
;;;1540   -----------------------------------------------------------------*/
;;;1541   u32 FAT_GetFileSize (void)
;;;1542   {
000cbc                      FAT_GetFileSize
000cbc  b590                        PUSH     {r4,r7,lr}
;;;1543   	// Read in the last accessed directory entry
;;;1544   	disc_ReadSector ((wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector, globalBuffer);
000cbe  4f0d                        LDR      r7,F20L1
000cc0  6878                        LDR      r0,[r7,#4]
000cc2  6bf9                        LDR      r1,[r7,#&3c]
000cc4  2900                        CMP      r1,#0
000cc6  d004                        BEQ      F20L11
000cc8  1e88                        SUB      r0,r1,#2
000cca  6a39                        LDR      r1,[r7,#&20]
000ccc  4348                        MUL      r0,r1
000cce  69b9                        LDR      r1,[r7,#&18]
000cd0  1840                        ADD      r0,r1
                            F20L11
000cd2  6c39                        LDR      r1,[r7,#&40]
000cd4  4c08                        LDR      r4,F20L1+4
000cd6  1840                        ADD      r0,r1
000cd8  2101                        MOV      r1,#1
000cda  1c22                        MOV      r2,r4
000cdc  f7ff f9c0                   BL       MPCF_ReadSectors
;;;1545   	
;;;1546   	return 	((DIR_ENT*)globalBuffer)[wrkDirOffset].fileSize;
000ce0  6c78                        LDR      r0,[r7,#&44]
000ce2  0140                        LSL      r0,#5
000ce4  1900                        ADD      r0,r4
000ce6  301c                        ADD      r0,#&1c
000ce8  f7ff f98a                   BL       __16_uread4
000cec  bc90                        POP      {r4,r7}
000cee  bc08                        POP      {r3}
000cf0  4718                        BX       r3
000cf2  0000                        LSL      r0,#0
                            F20L1
000cf4  00000000                    DCD      |x$dataseg|
000cf8  00000000                    DCD      globalBuffer

;;;1547   }
;;;1548   
;;;1549   /*-----------------------------------------------------------------
;;;1550   FAT_GetFileCluster
;;;1551   Get the first cluster of the last file found or openned.
;;;1552   u32 return OUT: the file start cluster
;;;1553   -----------------------------------------------------------------*/
;;;1554   u32 FAT_GetFileCluster (void)
;;;1555   {
000cfc                      FAT_GetFileCluster
000cfc  b590                        PUSH     {r4,r7,lr}
;;;1556   	// Read in the last accessed directory entry
;;;1557   	disc_ReadSector ((wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector, globalBuffer);
000cfe  4f10                        LDR      r7,F21L1
000d00  6878                        LDR      r0,[r7,#4]
000d02  6bf9                        LDR      r1,[r7,#&3c]
000d04  2900                        CMP      r1,#0
000d06  d004                        BEQ      F21L11
000d08  1e88                        SUB      r0,r1,#2
000d0a  6a39                        LDR      r1,[r7,#&20]
000d0c  4348                        MUL      r0,r1
000d0e  69b9                        LDR      r1,[r7,#&18]
000d10  1840                        ADD      r0,r1
                            F21L11
000d12  6c39                        LDR      r1,[r7,#&40]
000d14  4c0b                        LDR      r4,F21L1+4
000d16  1840                        ADD      r0,r1
000d18  2101                        MOV      r1,#1
000d1a  1c22                        MOV      r2,r4
000d1c  f7ff f9a0                   BL       MPCF_ReadSectors
;;;1558   	
;;;1559   	return 	(((DIR_ENT*)globalBuffer)[wrkDirOffset].startCluster) | (((DIR_ENT*)globalBuffer)[wrkDirOffset].startClusterHigh << 16);
000d20  6c78                        LDR      r0,[r7,#&44]
000d22  0140                        LSL      r0,#5
000d24  1900                        ADD      r0,r4
000d26  7ec3                        LDRB     r3,[r0,#&1b]
000d28  7e81                        LDRB     r1,[r0,#&1a]
000d2a  021b                        LSL      r3,#8
000d2c  4319                        ORR      r1,r3
000d2e  7d43                        LDRB     r3,[r0,#&15]
000d30  7d00                        LDRB     r0,[r0,#&14]
000d32  bc90                        POP      {r4,r7}
000d34  021b                        LSL      r3,#8
000d36  4318                        ORR      r0,r3
000d38  0400                        LSL      r0,#16
000d3a  bc08                        POP      {r3}
000d3c  4308                        ORR      r0,r1
000d3e  4718                        BX       r3
                            F21L1
000d40  00000000                    DCD      |x$dataseg|
000d44  00000000                    DCD      globalBuffer

;;;1560   }
;;;1561   
;;;1562   
;;;1563   
;;;1564   /*-----------------------------------------------------------------
;;;1565   FAT_DirEntFromPath
;;;1566   Finds the directory entry for a file or directory from a path
;;;1567   Path separator is a forward slash /
;;;1568   const char* path: IN null terminated string of path.
;;;1569   DIR_ENT return OUT: dirEntry of found file. First char will be FILE_FREE
;;;1570   	if the file was not found
;;;1571   -----------------------------------------------------------------*/
;;;1572   DIR_ENT FAT_DirEntFromPath (const char* path)
;;;1573   {
000d48                      FAT_DirEntFromPath
000d48  b5f3                        PUSH     {r0,r1,r4-r7,lr}
000d4a  b0d4                        SUB      sp,#&150
;;;1574   	int pathPos;
;;;1575   	char name[MAX_FILENAME_LENGTH];
;;;1576   	char alias[13];
;;;1577   	int namePos;
;;;1578   	bool found, notFound;
;;;1579   	DIR_ENT dirEntry;
;;;1580   	u32 dirCluster;
;;;1581   	bool flagLFN;
;;;1582   	
;;;1583   	// Start at beginning of path
;;;1584   	pathPos = 0;
;;;1585   	
;;;1586   	if (path[pathPos] == '/') 
000d4c  7808                        LDRB     r0,[r1,#0]
000d4e  1c0f                        MOV      r7,r1
000d50  2400                        MOV      r4,#0   ;;;1584
000d52  282f                        CMP      r0,#&2f
000d54  4970                        LDR      r1,F22L1
000d56  d101                        BNE      F22L112
;;;1587   	{
;;;1588   		dirCluster = filesysRootDirClus;	// Start at root directory
000d58  6889                        LDR      r1,[r1,#8]
000d5a  e000                        B        F22L113
                            F22L112
;;;1589   	}
;;;1590   	else
;;;1591   	{
;;;1592   		dirCluster = curWorkDirCluster;	// Start at current working dir
000d5c  6b89                        LDR      r1,[r1,#&38]
                            F22L113
000d5e  9105                        STR      r1,[sp,#&14]
000d60  e000                        B        F22L114
                            F22L7
;;;1593   	}
;;;1594   	
;;;1595   	// Eat any slash /
;;;1596   	while ((path[pathPos] == '/') && (path[pathPos] != '\0'))
;;;1597   	{
;;;1598   		pathPos++;
000d62  3401                        ADD      r4,#1
                            F22L114
000d64  5d38                        LDRB     r0,[r7,r4]   ;;;1596
000d66  282f                        CMP      r0,#&2f   ;;;1596
000d68  d0fb                        BEQ      F22L7   ;;;1596
;;;1599   	}
;;;1600   	
;;;1601   	// Search until can't continue
;;;1602   	found = false;
000d6a  2500                        MOV      r5,#0
;;;1603   	notFound = false;
000d6c  2000                        MOV      r0,#0
000d6e  900e                        STR      r0,[sp,#&38]
000d70  a80a                        ADD      r0,sp,#&28
000d72  9053                        STR      r0,[sp,#&14c]
                            F22L12
;;;1604   	while (!notFound && !found)
;;;1605   	{
;;;1606   		flagLFN = false;
;;;1607   		// Copy name from path
;;;1608   		namePos = 0;
;;;1609   		if (path[pathPos] == '.')
000d74  5d38                        LDRB     r0,[r7,r4]
000d76  2600                        MOV      r6,#0   ;;;1608
000d78  282e                        CMP      r0,#&2e
000d7a  d117                        BNE      F22L115
;;;1610   		{
;;;1611   			// Dot entry or double dot entry
;;;1612   			name[namePos] = '.';
000d7c  ab13                        ADD      r3,sp,#&4c
;;;1613   			namePos++;
000d7e  2601                        MOV      r6,#1
;;;1614   			pathPos++;
000d80  19a4                        ADD      r4,r6
000d82  7018                        STRB     r0,[r3,#0]   ;;;1612
;;;1615   			if (path[pathPos] == '.')
000d84  5d39                        LDRB     r1,[r7,r4]
000d86  292e                        CMP      r1,#&2e
000d88  d115                        BNE      F22L116
;;;1616   			{
;;;1617   				name[namePos] = '.';
;;;1618   				namePos++;
000d8a  2602                        MOV      r6,#2
;;;1619   				pathPos++;
000d8c  3401                        ADD      r4,#1
000d8e  7058                        STRB     r0,[r3,#1]   ;;;1617
000d90  e011                        B        F22L117
                            F22L19
;;;1620   			}
;;;1621   		}
;;;1622   		else
;;;1623   		{
;;;1624   			// Copy name from path
;;;1625   			namePos = 0;
;;;1626   			while ((namePos < MAX_FILENAME_LENGTH - 1) && (path[pathPos] != '\0') && (path[pathPos] != '/'))
;;;1627   			{
;;;1628   				name[namePos] = ucase(path[pathPos]);
000d92  f7ff fa4b                   BL       ucase
000d96  a913                        ADD      r1,sp,#&4c
000d98  5588                        STRB     r0,[r1,r6]
;;;1629   				if ((name[namePos] <= ' ') || ((name[namePos] >= ':') && (name[namePos] <= '?'))) // Invalid character
000d9a  a813                        ADD      r0,sp,#&4c
000d9c  5d80                        LDRB     r0,[r0,r6]
000d9e  2820                        CMP      r0,#&20
000da0  dd00                        BLE      F22L118
000da2  383a                        SUB      r0,#&3a
                            F22L118
000da4  3401                        ADD      r4,#1   ;;;1626
000da6  3601                        ADD      r6,#1   ;;;1626
000da8  2eff                        CMP      r6,#&ff   ;;;1626
000daa  da04                        BGE      F22L117   ;;;1626
                            F22L115
000dac  5d38                        LDRB     r0,[r7,r4]   ;;;1626
000dae  2800                        CMP      r0,#0   ;;;1626
000db0  d001                        BEQ      F22L119   ;;;1626
000db2  282f                        CMP      r0,#&2f   ;;;1626
000db4  d1ed                        BNE      F22L19   ;;;1626
                            F22L116
                            F22L117
                            F22L119
;;;1630   				{
;;;1631   					flagLFN = true;
;;;1632   				}
;;;1633   				namePos++;
;;;1634   				pathPos++;
;;;1635   			}
;;;1636   			// Check if a long filename was specified
;;;1637   			if (namePos > 12)
;;;1638   			{
;;;1639   				flagLFN = true;
;;;1640   			}
;;;1641   		}
;;;1642   		
;;;1643   		// Add end of string char
;;;1644   		name[namePos] = '\0';
000db6  2100                        MOV      r1,#0
000db8  a813                        ADD      r0,sp,#&4c
000dba  5581                        STRB     r1,[r0,r6]
000dbc  e000                        B        F22L120
                            F22L33
;;;1645   
;;;1646   		// Move through path to correct place
;;;1647   		while ((path[pathPos] != '/') && (path[pathPos] != '\0'))
;;;1648   			pathPos++;
000dbe  3401                        ADD      r4,#1
                            F22L120
000dc0  5d38                        LDRB     r0,[r7,r4]   ;;;1647
000dc2  282f                        CMP      r0,#&2f   ;;;1647
000dc4  d002                        BEQ      F22L121   ;;;1647
000dc6  2800                        CMP      r0,#0   ;;;1647
000dc8  d1f9                        BNE      F22L33   ;;;1647
000dca  e003                        B        F22L122   ;;;1647
                            F22L121
                            F22L38
;;;1649   		// Eat any slash /
;;;1650   		while ((path[pathPos] == '/') && (path[pathPos] != '\0'))
000dcc  3401                        ADD      r4,#1
000dce  5d38                        LDRB     r0,[r7,r4]
000dd0  282f                        CMP      r0,#&2f
000dd2  d0fb                        BEQ      F22L38
                            F22L122
;;;1651   		{
;;;1652   			pathPos++;
;;;1653   		}
;;;1654   
;;;1655   		// Search current Dir for correct entry
;;;1656   		dirEntry = FAT_GetDirEntry (dirCluster, 1, SEEK_SET);
000dd4  2300                        MOV      r3,#0
000dd6  2201                        MOV      r2,#1
000dd8  9905                        LDR      r1,[sp,#&14]
000dda  a806                        ADD      r0,sp,#&18
000ddc  f7ff fdc4                   BL       FAT_GetDirEntry
;;;1657   		while ( !found && !notFound)
000de0  2d00                        CMP      r5,#0
000de2  d170                        BNE      F22L123
000de4  980e                        LDR      r0,[sp,#&38]
000de6  2800                        CMP      r0,#0
000de8  d16e                        BNE      F22L124
                            F22L43
;;;1658   		{
;;;1659   			// Match filename
;;;1660   			found = true;
000dea  2501                        MOV      r5,#1
;;;1661   			for (namePos = 0; (namePos < MAX_FILENAME_LENGTH) && found && (name[namePos] != '\0') && (lfnName[namePos] != '\0'); namePos++)
000dec  2600                        MOV      r6,#0
000dee  e00d                        B        F22L125
                            F22L45
;;;1662   			{
;;;1663   				if (name[namePos] != ucase(lfnName[namePos]))
000df0  f7ff fa1c                   BL       ucase
000df4  a913                        ADD      r1,sp,#&4c
000df6  5d89                        LDRB     r1,[r1,r6]
000df8  4288                        CMP      r0,r1
000dfa  d000                        BEQ      F22L126
;;;1664   				{
;;;1665   					found = false;
000dfc  2500                        MOV      r5,#0
                            F22L126
000dfe  23ff                        MOV      r3,#&ff   ;;;1661
000e00  3301                        ADD      r3,#1   ;;;1661
000e02  3601                        ADD      r6,#1   ;;;1661
000e04  429e                        CMP      r6,r3   ;;;1661
000e06  da09                        BGE      F22L127   ;;;1661
000e08  2d00                        CMP      r5,#0   ;;;1661
000e0a  d007                        BEQ      F22L128   ;;;1661
                            F22L125
000e0c  a813                        ADD      r0,sp,#&4c   ;;;1661
000e0e  5d80                        LDRB     r0,[r0,r6]   ;;;1661
000e10  2800                        CMP      r0,#0   ;;;1661
000e12  d003                        BEQ      F22L128   ;;;1661
000e14  4841                        LDR      r0,F22L1+4   ;;;1661
000e16  5d80                        LDRB     r0,[r0,r6]   ;;;1661
000e18  2800                        CMP      r0,#0   ;;;1661
000e1a  d1e9                        BNE      F22L45   ;;;1661
                            F22L127
                            F22L128
;;;1666   				}
;;;1667   			}
;;;1668   			if ((name[namePos] == '\0') != (lfnName[namePos] == '\0'))
000e1c  a913                        ADD      r1,sp,#&4c
000e1e  5d89                        LDRB     r1,[r1,r6]
000e20  2201                        MOV      r2,#1
000e22  1c10                        MOV      r0,r2
000e24  2900                        CMP      r1,#0
000e26  d000                        BEQ      F22L129
000e28  2000                        MOV      r0,#0
                            F22L129
000e2a  4a3c                        LDR      r2,F22L1+4
000e2c  2101                        MOV      r1,#1
000e2e  5d92                        LDRB     r2,[r2,r6]
000e30  2a00                        CMP      r2,#0
000e32  d000                        BEQ      F22L130
000e34  2100                        MOV      r1,#0
                            F22L130
000e36  4288                        CMP      r0,r1
000e38  d101                        BNE      F22L131
;;;1669   			{
;;;1670   				found = false;
;;;1671   			}
;;;1672   
;;;1673   			// Check against alias as well.
;;;1674   			if (!found)
000e3a  2d00                        CMP      r5,#0
000e3c  d133                        BNE      F22L132
                            F22L131
;;;1675   			{
;;;1676   				FAT_GetFilename(dirEntry, alias);
000e3e  aa0f                        ADD      r2,sp,#&3c
000e40  9853                        LDR      r0,[sp,#&14c]
000e42  9204                        STR      r2,[sp,#&10]
000e44  c80c                        LDMIA    r0!,{r2,r3}
000e46  4669                        MOV      r1,sp
000e48  c10c                        STMIA    r1!,{r2,r3}
000e4a  c80c                        LDMIA    r0!,{r2,r3}
000e4c  c10c                        STMIA    r1!,{r2,r3}
000e4e  ae06                        ADD      r6,sp,#&18
000e50  ce63                        LDMIA    r6!,{r0,r1,r5,r6}
000e52  1c2a                        MOV      r2,r5
000e54  1c33                        MOV      r3,r6
000e56  f7ff febf                   BL       FAT_GetFilename
;;;1677   				found = true;
000e5a  2501                        MOV      r5,#1
;;;1678   				for (namePos = 0; (namePos < 13) && found && (name[namePos] != '\0') && (alias[namePos] != '\0'); namePos++)
000e5c  2600                        MOV      r6,#0
000e5e  e00b                        B        F22L133
                            F22L64
;;;1679   				{
;;;1680   					if (name[namePos] != ucase(alias[namePos]))
000e60  f7ff f9e4                   BL       ucase
000e64  a913                        ADD      r1,sp,#&4c
000e66  5d89                        LDRB     r1,[r1,r6]
000e68  4288                        CMP      r0,r1
000e6a  d000                        BEQ      F22L134
;;;1681   					{
;;;1682   						found = false;
000e6c  2500                        MOV      r5,#0
                            F22L134
000e6e  3601                        ADD      r6,#1   ;;;1678
000e70  2e0d                        CMP      r6,#&d   ;;;1678
000e72  da09                        BGE      F22L135   ;;;1678
000e74  2d00                        CMP      r5,#0   ;;;1678
000e76  d007                        BEQ      F22L136   ;;;1678
                            F22L133
000e78  a813                        ADD      r0,sp,#&4c   ;;;1678
000e7a  5d80                        LDRB     r0,[r0,r6]   ;;;1678
000e7c  2800                        CMP      r0,#0   ;;;1678
000e7e  d003                        BEQ      F22L136   ;;;1678
000e80  a80f                        ADD      r0,sp,#&3c   ;;;1678
000e82  5d80                        LDRB     r0,[r0,r6]   ;;;1678
000e84  2800                        CMP      r0,#0   ;;;1678
000e86  d1eb                        BNE      F22L64   ;;;1678
                            F22L135
                            F22L136
;;;1683   					}
;;;1684   				}
;;;1685   				if ((name[namePos] == '\0') != (alias[namePos] == '\0'))
000e88  aa13                        ADD      r2,sp,#&4c
000e8a  5d92                        LDRB     r2,[r2,r6]
000e8c  2001                        MOV      r0,#1
000e8e  1c01                        MOV      r1,r0
000e90  2a00                        CMP      r2,#0
000e92  d000                        BEQ      F22L137
000e94  2100                        MOV      r1,#0
                            F22L137
000e96  aa0f                        ADD      r2,sp,#&3c
000e98  5d92                        LDRB     r2,[r2,r6]
000e9a  2a00                        CMP      r2,#0
000e9c  d000                        BEQ      F22L138
000e9e  2000                        MOV      r0,#0
                            F22L138
000ea0  4281                        CMP      r1,r0
000ea2  d000                        BEQ      F22L139
;;;1686   				{
;;;1687   					found = false;
000ea4  2500                        MOV      r5,#0
                            F22L132
                            F22L139
;;;1688   				}
;;;1689   			}
;;;1690   
;;;1691   			if (dirEntry.name[0] == FILE_FREE)
000ea6  a806                        ADD      r0,sp,#&18
000ea8  7800                        LDRB     r0,[r0,#0]
000eaa  28e5                        CMP      r0,#&e5
000eac  d025                        BEQ      F22L140
;;;1692   				// Couldn't find specified file
;;;1693   			{
;;;1694   				found = false;
;;;1695   				notFound = true;
;;;1696   			}
;;;1697   			if (!found && !notFound)
000eae  2d00                        CMP      r5,#0
000eb0  d109                        BNE      F22L123
000eb2  980e                        LDR      r0,[sp,#&38]
000eb4  2800                        CMP      r0,#0
000eb6  d107                        BNE      F22L124
;;;1698   			{
;;;1699   				dirEntry = FAT_GetDirEntry (dirCluster, 1, SEEK_CUR);
000eb8  2301                        MOV      r3,#1
000eba  2201                        MOV      r2,#1
000ebc  9905                        LDR      r1,[sp,#&14]
000ebe  a806                        ADD      r0,sp,#&18
000ec0  f7ff fd52                   BL       FAT_GetDirEntry
000ec4  e791                        B        F22L43
                            F22L123
000ec6  e000                        B        F22L141
                            F22L124
000ec8  e017                        B        F22L142
                            F22L141
;;;1700   			}
;;;1701   		}
;;;1702   		
;;;1703   		if (found && ((dirEntry.attrib & ATTRIB_DIR) == ATTRIB_DIR) && (path[pathPos] != '\0'))
000eca  a808                        ADD      r0,sp,#&20
000ecc  78c0                        LDRB     r0,[r0,#3]
000ece  2310                        MOV      r3,#&10
000ed0  4018                        AND      r0,r3
000ed2  2810                        CMP      r0,#&10
000ed4  d10a                        BNE      F22L143
000ed6  5d38                        LDRB     r0,[r7,r4]
000ed8  2800                        CMP      r0,#0
000eda  d007                        BEQ      F22L144
;;;1704   			// It has found a directory from within the path that needs to be followed
;;;1705   		{
;;;1706   			found = false;
;;;1707   			dirCluster = dirEntry.startCluster | (dirEntry.startClusterHigh << 16);
000edc  a80c                        ADD      r0,sp,#&30
000ede  8840                        LDRH     r0,[r0,#2]
000ee0  a90b                        ADD      r1,sp,#&2c
000ee2  8809                        LDRH     r1,[r1,#0]
000ee4  2500                        MOV      r5,#0   ;;;1706
000ee6  0409                        LSL      r1,#16
000ee8  4301                        ORR      r1,r0
000eea  9105                        STR      r1,[sp,#&14]
                            F22L143
                            F22L144
000eec  980e                        LDR      r0,[sp,#&38]   ;;;1604
000eee  2800                        CMP      r0,#0   ;;;1604
000ef0  d103                        BNE      F22L142   ;;;1604
000ef2  2d00                        CMP      r5,#0   ;;;1604
000ef4  d100                        BNE      F22L145   ;;;1604
000ef6  e73d                        B        F22L12   ;;;1604
                            F22L145
000ef8  e005                        B        F22L146   ;;;1604
                            F22L140
                            F22L142
;;;1708   		}
;;;1709   	}
;;;1710   	
;;;1711   	if (notFound)
;;;1712   	{
;;;1713   		dirEntry.name[0] = FILE_FREE;
000efa  20e5                        MOV      r0,#&e5
000efc  ab06                        ADD      r3,sp,#&18
000efe  7018                        STRB     r0,[r3,#0]
;;;1714   		dirEntry.attrib = 0x00;
000f00  2100                        MOV      r1,#0
000f02  72d9                        STRB     r1,[r3,#&b]
000f04  3308                        ADD      r3,#8
                            F22L146
;;;1715   	}
;;;1716   
;;;1717   	return (dirEntry);
000f06  2220                        MOV      r2,#&20
000f08  9854                        LDR      r0,[sp,#&150]
000f0a  a906                        ADD      r1,sp,#&18
000f0c  f7ff f878                   BL       memcpy
000f10  b056                        ADD      sp,#&158
000f12  bcf0                        POP      {r4-r7}
000f14  bc08                        POP      {r3}
000f16  4718                        BX       r3
                            F22L1
000f18  00000000                    DCD      |x$dataseg|
000f1c  00000000                    DCD      lfnName

;;;1718   }
;;;1719   
;;;1720   
;;;1721   /*-----------------------------------------------------------------
;;;1722   FAT_AddDirEntry
;;;1723   Creates a new dir entry for a file
;;;1724   Path separator is a forward slash /
;;;1725   const char* path: IN null terminated string of path to file.
;;;1726   DIR_ENT newDirEntry IN: The directory entry to use.
;;;1727   int file IN: The file being added (optional, use -1 if not used)
;;;1728   bool return OUT: true if successful
;;;1729   -----------------------------------------------------------------*/
;;;1730   bool FAT_AddDirEntry (const char* path, DIR_ENT newDirEntry)
;;;1731   {
000f20                      FAT_AddDirEntry
000f20  b40f                        PUSH     {r0-r3}
000f22  b5f0                        PUSH     {r4-r7,lr}
000f24  b0e1                        SUB      sp,#&184
;;;1732   	char filename[MAX_FILENAME_LENGTH];
;;;1733   	int filePos, pathPos, aliasPos;
;;;1734   	char tempChar;
;;;1735   	bool flagLFN;
;;;1736   	char fileAlias[13];
;;;1737   	int tailNum;
;;;1738   	
;;;1739   	unsigned char chkSum = 0;
000f26  1c06                        MOV      r6,r0
000f28  2000                        MOV      r0,#0
;;;1740   	
;;;1741   	u32 oldWorkDirCluster;
;;;1742   	
;;;1743   	DIR_ENT* dirEntries = (DIR_ENT*)globalBuffer;
;;;1744   	u32 dirCluster;
;;;1745   	int secOffset;
;;;1746   	int entryOffset;
;;;1747   	int maxSectors;
;;;1748   	u32 firstSector;
;;;1749   
;;;1750   	DIR_ENT_LFN lfnEntry;
;;;1751   	DIR_ENT tempentry;
;;;1752   	int lfnPos = 0;
;;;1753   
;;;1754   	int dirEntryLength = 0;
;;;1755   	int dirEntryRemain = 0;
;;;1756   	u32 tempDirCluster;
;;;1757   	int tempSecOffset;
;;;1758   	int tempEntryOffset;
;;;1759   	bool dirEndFlag = false;
;;;1760   
;;;1761   	// Store current working directory
;;;1762   	oldWorkDirCluster = curWorkDirCluster;
000f2a  4afa                        LDR      r2,F23L1+4
000f2c  901b                        STR      r0,[sp,#&6c]   ;;;1739
000f2e  9001                        STR      r0,[sp,#4]   ;;;1759
000f30  6b90                        LDR      r0,[r2,#&38]
000f32  4cf7                        LDR      r4,F23L1   ;;;1743
000f34  901a                        STR      r0,[sp,#&68]
;;;1763   
;;;1764   	// Find filename within path and change to correct directory
;;;1765   	if (path[0] == '/')
000f36  7830                        LDRB     r0,[r6,#0]
000f38  282f                        CMP      r0,#&2f
000f3a  d101                        BNE      F23L214
;;;1766   	{
;;;1767   		curWorkDirCluster = filesysRootDirClus;
000f3c  6890                        LDR      r0,[r2,#8]
000f3e  6390                        STR      r0,[r2,#&38]
                            F23L214
;;;1768   	}
;;;1769   	
;;;1770   	pathPos = 0;
000f40  2700                        MOV      r7,#0
;;;1771   	filePos = 0;
000f42  2000                        MOV      r0,#0
;;;1772   	flagLFN = false;
000f44  2100                        MOV      r1,#0
000f46  9120                        STR      r1,[sp,#&80]
000f48  e014                        B        F23L215
                            F23L6
;;;1773   
;;;1774   	while (path[pathPos + filePos] != '\0')
;;;1775   	{
;;;1776   		if (path[pathPos + filePos] == '/')
000f4a  292f                        CMP      r1,#&2f
000f4c  d10d                        BNE      F23L216
;;;1777   		{
;;;1778   			filename[filePos] = '\0';
000f4e  2200                        MOV      r2,#0
000f50  a921                        ADD      r1,sp,#&84
000f52  540a                        STRB     r2,[r1,r0]
;;;1779   			if (FAT_chdir(filename) == false) 
000f54  a821                        ADD      r0,sp,#&84
000f56  f7ff f853                   BL       FAT_chdir
000f5a  2800                        CMP      r0,#0
000f5c  d103                        BNE      F23L217
;;;1780   			{
;;;1781   				curWorkDirCluster = oldWorkDirCluster;
000f5e  981a                        LDR      r0,[sp,#&68]
000f60  4aec                        LDR      r2,F23L1+4
000f62  6390                        STR      r0,[r2,#&38]
000f64  e029                        B        F23L218
                            F23L217
;;;1782   				return false; // Couldn't change directory
;;;1783   			}
;;;1784   			pathPos += filePos + 1;
;;;1785   			filePos = 0;
000f66  2000                        MOV      r0,#0
000f68  1c6f                        ADD      r7,r5,#1
                            F23L216
;;;1786   		}
;;;1787   		filename[filePos] = path[pathPos + filePos];
000f6a  1839                        ADD      r1,r7,r0
000f6c  5c72                        LDRB     r2,[r6,r1]
000f6e  a921                        ADD      r1,sp,#&84
000f70  540a                        STRB     r2,[r1,r0]
;;;1788   		filePos++;
000f72  3001                        ADD      r0,#1
                            F23L215
000f74  183d                        ADD      r5,r7,r0   ;;;1774
000f76  5d71                        LDRB     r1,[r6,r5]   ;;;1774
000f78  2900                        CMP      r1,#0   ;;;1774
000f7a  d1e6                        BNE      F23L6   ;;;1774
000f7c  e000                        B        F23L219   ;;;1774
                            F23L13
;;;1789   	}
;;;1790   	
;;;1791   	// Skip over last slashes
;;;1792   	while (path[pathPos] == '/')
;;;1793   		pathPos++;
000f7e  3701                        ADD      r7,#1
                            F23L219
000f80  5df0                        LDRB     r0,[r6,r7]   ;;;1792
000f82  282f                        CMP      r0,#&2f   ;;;1792
000f84  d0fb                        BEQ      F23L13   ;;;1792
;;;1794   	
;;;1795   	// Copy name from path
;;;1796   	filePos = 0;
000f86  2500                        MOV      r5,#0
000f88  e00e                        B        F23L220
                            F23L16
;;;1797   	while ((filePos < MAX_FILENAME_LENGTH - 1) && (path[pathPos] != '\0'))
;;;1798   	{
;;;1799   		filename[filePos] = path[pathPos];
000f8a  a921                        ADD      r1,sp,#&84
000f8c  5548                        STRB     r0,[r1,r5]
;;;1800   		if ((filename[filePos] <= ' ') || ((filename[filePos] >= ':') && (filename[filePos] <= '?'))) // Invalid character
000f8e  a821                        ADD      r0,sp,#&84
000f90  5d40                        LDRB     r0,[r0,r5]
000f92  2820                        CMP      r0,#&20
000f94  dd02                        BLE      F23L221
000f96  383a                        SUB      r0,#&3a
000f98  2805                        CMP      r0,#5
000f9a  d801                        BHI      F23L222
                            F23L221
;;;1801   		{
;;;1802   			flagLFN = true;
000f9c  2001                        MOV      r0,#1
000f9e  9020                        STR      r0,[sp,#&80]
                            F23L222
000fa0  3501                        ADD      r5,#1   ;;;1797
000fa2  3701                        ADD      r7,#1   ;;;1797
000fa4  2dff                        CMP      r5,#&ff   ;;;1797
000fa6  da02                        BGE      F23L223   ;;;1797
                            F23L220
000fa8  5df0                        LDRB     r0,[r6,r7]   ;;;1797
000faa  2800                        CMP      r0,#0   ;;;1797
000fac  d1ed                        BNE      F23L16   ;;;1797
                            F23L223
;;;1803   		}
;;;1804   		filePos++;
;;;1805   		pathPos++;
;;;1806   	}
;;;1807   	
;;;1808   	// Check if a long filename was specified
;;;1809   	if (filePos > 12)
000fae  2d0c                        CMP      r5,#&c
000fb0  dd01                        BLE      F23L224
;;;1810   	{
;;;1811   		flagLFN = true;
000fb2  2001                        MOV      r0,#1
000fb4  9020                        STR      r0,[sp,#&80]
                            F23L224
;;;1812   	}
;;;1813   	
;;;1814   	if (filePos == 0)	// No filename
000fb6  2d00                        CMP      r5,#0
000fb8  d101                        BNE      F23L225
                            F23L218
                            F23L30
;;;1815   	{
;;;1816   		return false;
000fba  2000                        MOV      r0,#0
000fbc  e21b                        B        F23L226
                            F23L225
;;;1817   	}
;;;1818   	
;;;1819   	lfnPos = (filePos - 1) / 13;
000fbe  200d                        MOV      r0,#&d
000fc0  1e69                        SUB      r1,r5,#1
000fc2  f7ff f81d                   BL       __16__rt_sdiv
000fc6  9007                        STR      r0,[sp,#&1c]
;;;1820   
;;;1821   	// Add end of string char
;;;1822   	filename[filePos++] = '\0';
000fc8  2600                        MOV      r6,#0
000fca  a921                        ADD      r1,sp,#&84
000fcc  554e                        STRB     r6,[r1,r5]
000fce  21ff                        MOV      r1,#&ff
000fd0  1c68                        ADD      r0,r5,#1
000fd2  3101                        ADD      r1,#1
000fd4  e004                        B        F23L227
                            F23L31
;;;1823   	// Clear remaining chars
;;;1824   	while (filePos < MAX_FILENAME_LENGTH)
;;;1825   		filename[filePos++] = 0x01;	// Set for LFN compatibility
000fd6  2301                        MOV      r3,#1
000fd8  1c02                        MOV      r2,r0
000fda  ad21                        ADD      r5,sp,#&84
000fdc  54ab                        STRB     r3,[r5,r2]
000fde  18c0                        ADD      r0,r3
                            F23L227
000fe0  4288                        CMP      r0,r1   ;;;1824
000fe2  dbf8                        BLT      F23L31   ;;;1824
;;;1826   	
;;;1827   	
;;;1828   	if (flagLFN)
000fe4  9820                        LDR      r0,[sp,#&80]
000fe6  2800                        CMP      r0,#0
000fe8  d06e                        BEQ      F23L228
;;;1829   	{
;;;1830   		// Generate short filename - always a 2 digit number for tail
;;;1831   		// Get first 5 chars of alias from LFN
;;;1832   		aliasPos = 0;
000fea  2600                        MOV      r6,#0
;;;1833   		for (filePos = 0; (aliasPos < 5) && (filename[filePos] != '\0') ; filePos++)
000fec  2500                        MOV      r5,#0
000fee  e00f                        B        F23L229
                            F23L36
;;;1834   		{
;;;1835   			tempChar = ucase(filename[filePos]);
000ff0  f7ff f91c                   BL       ucase
;;;1836   			if ((tempChar > ' ' && tempChar < ':') || tempChar > '?')
000ff4  1fc1                        SUB      r1,r0,#7
000ff6  391a                        SUB      r1,#&1a
000ff8  2919                        CMP      r1,#&19
000ffa  d301                        BCC      F23L230
000ffc  283f                        CMP      r0,#&3f
000ffe  dd04                        BLE      F23L231
                            F23L230
;;;1837   				fileAlias[aliasPos++] = tempChar;
001000  1c01                        MOV      r1,r0
001002  1c30                        MOV      r0,r6
001004  aa1c                        ADD      r2,sp,#&70
001006  5411                        STRB     r1,[r2,r0]
001008  3601                        ADD      r6,#1
                            F23L231
00100a  3501                        ADD      r5,#1   ;;;1833
00100c  2e05                        CMP      r6,#5   ;;;1833
00100e  da0b                        BGE      F23L232   ;;;1833
                            F23L229
001010  a821                        ADD      r0,sp,#&84   ;;;1833
001012  5d40                        LDRB     r0,[r0,r5]   ;;;1833
001014  2800                        CMP      r0,#0   ;;;1833
001016  d1eb                        BNE      F23L36   ;;;1833
001018  215f                        MOV      r1,#&5f   ;;;1833
00101a  e003                        B        F23L233   ;;;1833
                            F23L47
;;;1838   		}
;;;1839   		// Pad Alias with underscores
;;;1840   		while (aliasPos < 5)
;;;1841   			fileAlias[aliasPos++] = '_';
00101c  1c30                        MOV      r0,r6
00101e  aa1c                        ADD      r2,sp,#&70
001020  5411                        STRB     r1,[r2,r0]
001022  3601                        ADD      r6,#1
                            F23L233
001024  2e05                        CMP      r6,#5   ;;;1840
001026  dbf9                        BLT      F23L47   ;;;1840
                            F23L232
;;;1842   		
;;;1843   		fileAlias[5] = '~';
001028  207e                        MOV      r0,#&7e
00102a  ab1d                        ADD      r3,sp,#&74
00102c  7058                        STRB     r0,[r3,#1]
;;;1844   		fileAlias[8] = '.';
00102e  202e                        MOV      r0,#&2e
001030  7118                        STRB     r0,[r3,#4]
;;;1845   		fileAlias[9] = ' ';
001032  ab1e                        ADD      r3,sp,#&78
001034  2620                        MOV      r6,#&20
001036  705e                        STRB     r6,[r3,#1]
;;;1846   		fileAlias[10] = ' ';
001038  709e                        STRB     r6,[r3,#2]
;;;1847   		fileAlias[11] = ' ';
00103a  70de                        STRB     r6,[r3,#3]
00103c  e006                        B        F23L234
                            F23L50
;;;1848   		while(filename[filePos] != '\0')
;;;1849   		{
;;;1850   			filePos++;
;;;1851   			if (filename[filePos] == '.')
00103e  a821                        ADD      r0,sp,#&84
001040  3501                        ADD      r5,#1
001042  5d40                        LDRB     r0,[r0,r5]
001044  282e                        CMP      r0,#&2e
001046  d101                        BNE      F23L234
;;;1852   			{
;;;1853   				pathPos = filePos;
001048  1c2f                        MOV      r7,r5
00104a  e7f8                        B        F23L50
                            F23L234
00104c  a821                        ADD      r0,sp,#&84   ;;;1848
00104e  5d40                        LDRB     r0,[r0,r5]   ;;;1848
001050  2800                        CMP      r0,#0   ;;;1848
001052  d1f4                        BNE      F23L50   ;;;1848
;;;1854   			}
;;;1855   		}
;;;1856   		filePos = pathPos + 1;	//pathPos is used as a temporary variable
;;;1857   		// Copy first 3 characters of extension
;;;1858   		for (aliasPos = 9; (aliasPos < 12) && (filename[filePos] != '\0'); filePos++)
001054  1c7d                        ADD      r5,r7,#1
001056  2709                        MOV      r7,#9
001058  e00e                        B        F23L235
                            F23L55
;;;1859   		{
;;;1860   			tempChar = ucase(filename[filePos]);
00105a  f7ff f8e7                   BL       ucase
;;;1861   			if ((tempChar > ' ' && tempChar < ':') || tempChar > '?')
00105e  1fc1                        SUB      r1,r0,#7
001060  391a                        SUB      r1,#&1a
001062  2919                        CMP      r1,#&19
001064  d301                        BCC      F23L236
001066  283f                        CMP      r0,#&3f
001068  dd03                        BLE      F23L237
                            F23L236
;;;1862   				fileAlias[aliasPos++] = tempChar;
00106a  1c39                        MOV      r1,r7
00106c  aa1c                        ADD      r2,sp,#&70
00106e  5450                        STRB     r0,[r2,r1]
001070  3701                        ADD      r7,#1
                            F23L237
001072  3501                        ADD      r5,#1   ;;;1858
001074  2f0c                        CMP      r7,#&c   ;;;1858
001076  da0a                        BGE      F23L238   ;;;1858
                            F23L235
001078  a821                        ADD      r0,sp,#&84   ;;;1858
00107a  5d40                        LDRB     r0,[r0,r5]   ;;;1858
00107c  2800                        CMP      r0,#0   ;;;1858
00107e  d1ec                        BNE      F23L55   ;;;1858
001080  e003                        B        F23L239   ;;;1858
                            F23L66
;;;1863   		}
;;;1864   		
;;;1865   		// Pad Alias extension with spaces
;;;1866   		while (aliasPos < 12)
;;;1867   			fileAlias[aliasPos++] = ' ';
001082  1c38                        MOV      r0,r7
001084  a91c                        ADD      r1,sp,#&70
001086  540e                        STRB     r6,[r1,r0]
001088  3701                        ADD      r7,#1
                            F23L239
00108a  2f0c                        CMP      r7,#&c   ;;;1866
00108c  dbf9                        BLT      F23L66   ;;;1866
                            F23L238
;;;1868   		
;;;1869   		fileAlias[12] = '\0';
00108e  2600                        MOV      r6,#0
001090  ab1f                        ADD      r3,sp,#&7c
001092  701e                        STRB     r6,[r3,#0]
;;;1870   		
;;;1871   		
;;;1872   		// Get a valid tail number
;;;1873   		tailNum = 0;
001094  2500                        MOV      r5,#0
                            F23L69
;;;1874   		do {
;;;1875   			tailNum++;
;;;1876   			fileAlias[6] = 0x30 + ((tailNum / 10) % 10);	// 10's digit
001096  3501                        ADD      r5,#1
001098  1c28                        MOV      r0,r5
00109a  f7fe ffb1                   BL       __16__rt_sdiv10
00109e  1c0f                        MOV      r7,r1
0010a0  f7fe ffae                   BL       __16__rt_sdiv10
0010a4  1dc8                        ADD      r0,r1,#7
0010a6  3029                        ADD      r0,#&29
0010a8  ab1d                        ADD      r3,sp,#&74
0010aa  7098                        STRB     r0,[r3,#2]
;;;1877   			fileAlias[7] = 0x30 + (tailNum % 10);	// 1's digit
0010ac  1df8                        ADD      r0,r7,#7
0010ae  3029                        ADD      r0,#&29
0010b0  70d8                        STRB     r0,[r3,#3]
;;;1878   			tempentry=FAT_DirEntFromPath(fileAlias);
0010b2  a808                        ADD      r0,sp,#&20
0010b4  a91c                        ADD      r1,sp,#&70
0010b6  f7ff fe47                   BL       FAT_DirEntFromPath
;;;1879   		} while ((tempentry.name[0] != FILE_FREE) && (tailNum < 100));
0010ba  a808                        ADD      r0,sp,#&20
0010bc  7800                        LDRB     r0,[r0,#0]
0010be  28e5                        CMP      r0,#&e5
0010c0  d003                        BEQ      F23L240
0010c2  2d64                        CMP      r5,#&64
0010c4  dbe7                        BLT      F23L69
0010c6  e01e                        B        F23L241
                            F23L228
0010c8  e01f                        B        F23L242
                            F23L240
;;;1880   		
;;;1881   		if (tailNum < 100)	// Found an alias not being used
0010ca  2d64                        CMP      r5,#&64
0010cc  da1b                        BGE      F23L241
;;;1882   		{
;;;1883   			// Calculate file checksum
;;;1884   			chkSum = 0;
0010ce  2000                        MOV      r0,#0
0010d0  901b                        STR      r0,[sp,#&6c]
;;;1885   			for (aliasPos=0; aliasPos < 12; aliasPos++)
0010d2  2280                        MOV      r2,#&80
                            F23L75
;;;1886   			{
;;;1887   				// Skip '.'
;;;1888   				if (fileAlias[aliasPos] == '.')
0010d4  a91c                        ADD      r1,sp,#&70
0010d6  5c09                        LDRB     r1,[r1,r0]
0010d8  292e                        CMP      r1,#&2e
0010da  d100                        BNE      F23L243
;;;1889   					aliasPos++;
0010dc  3001                        ADD      r0,#1
                            F23L243
;;;1890   				// NOTE: The operation is an unsigned char rotate right
;;;1891   				chkSum = ((chkSum & 1) ? 0x80 : 0) + (chkSum >> 1) + fileAlias[aliasPos];
0010de  9b1b                        LDR      r3,[sp,#&6c]
0010e0  1c11                        MOV      r1,r2
0010e2  085b                        LSR      r3,#1
0010e4  d200                        BCS      F23L244
0010e6  2100                        MOV      r1,#0
                            F23L244
0010e8  9b1b                        LDR      r3,[sp,#&6c]
0010ea  105b                        ASR      r3,#1
0010ec  18cb                        ADD      r3,r1,r3
0010ee  a91c                        ADD      r1,sp,#&70
0010f0  5c09                        LDRB     r1,[r1,r0]
0010f2  1859                        ADD      r1,r3,r1
0010f4  060b                        LSL      r3,r1,#24
0010f6  0e1b                        LSR      r3,#24
0010f8  3001                        ADD      r0,#1   ;;;1885
0010fa  280c                        CMP      r0,#&c   ;;;1885
0010fc  931b                        STR      r3,[sp,#&6c]
0010fe  dbe9                        BLT      F23L75   ;;;1885
;;;1892   			}
;;;1893   		}
;;;1894   		else	// Couldn't find a valid alias
;;;1895   		{
;;;1896   			return false;
;;;1897   		}
;;;1898   		
;;;1899   		dirEntryLength = lfnPos + 2;
001100  9807                        LDR      r0,[sp,#&1c]
001102  3002                        ADD      r0,#2
001104  e017                        B        F23L245
                            F23L241
001106  1c30                        MOV      r0,r6   ;;;1896
001108  e175                        B        F23L226   ;;;1896
                            F23L242
;;;1900   	}
;;;1901   	else	// Its not a long file name
;;;1902   	{
;;;1903   		// Just copy alias straight from filename
;;;1904   		for (aliasPos = 0; aliasPos < 13; aliasPos++)
00110a  2700                        MOV      r7,#0
                            F23L84
;;;1905   		{
;;;1906   			tempChar = ucase(filename[aliasPos]);
00110c  a821                        ADD      r0,sp,#&84
00110e  5dc0                        LDRB     r0,[r0,r7]
001110  f7ff f88c                   BL       ucase
;;;1907   			if ((tempChar > ' ' && tempChar < ':') || tempChar > '?')
001114  1fc1                        SUB      r1,r0,#7
001116  391a                        SUB      r1,#&1a
001118  2919                        CMP      r1,#&19
00111a  d301                        BCC      F23L246
00111c  283f                        CMP      r0,#&3f
00111e  dd01                        BLE      F23L247
                            F23L246
;;;1908   				fileAlias[aliasPos] = tempChar;
001120  a91c                        ADD      r1,sp,#&70
001122  55c8                        STRB     r0,[r1,r7]
                            F23L247
001124  3701                        ADD      r7,#1   ;;;1904
001126  2f0d                        CMP      r7,#&d   ;;;1904
001128  dbf0                        BLT      F23L84   ;;;1904
;;;1909   		}
;;;1910   		fileAlias[12] = '\0';
00112a  2600                        MOV      r6,#0
00112c  ab1f                        ADD      r3,sp,#&7c
00112e  701e                        STRB     r6,[r3,#0]
;;;1911   
;;;1912   		lfnPos = -1;
001130  43f0                        MVN      r0,r6
001132  9007                        STR      r0,[sp,#&1c]
;;;1913   
;;;1914   		dirEntryLength = 1;
001134  2001                        MOV      r0,#1
                            F23L245
001136  9006                        STR      r0,[sp,#&18]
;;;1915   	}
;;;1916   	
;;;1917   	// Change dirEntry name to match alias
;;;1918   	for (aliasPos = 0; ((fileAlias[aliasPos] != '.') && (fileAlias[aliasPos] != '\0') && (aliasPos < 8)); aliasPos++)
001138  2000                        MOV      r0,#0
00113a  e003                        B        F23L248
                            F23L92
;;;1919   	{
;;;1920   		newDirEntry.name[aliasPos] = fileAlias[aliasPos];
00113c  aa67                        ADD      r2,sp,#&19c
00113e  1812                        ADD      r2,r0
001140  7011                        STRB     r1,[r2,#0]
001142  3001                        ADD      r0,#1   ;;;1918
                            F23L248
001144  a91c                        ADD      r1,sp,#&70   ;;;1918
001146  5c09                        LDRB     r1,[r1,r0]   ;;;1918
001148  292e                        CMP      r1,#&2e   ;;;1918
00114a  d101                        BNE      F23L249   ;;;1918
                            F23L200
00114c  2620                        MOV      r6,#&20   ;;;1918
00114e  e009                        B        F23L250   ;;;1918
                            F23L249
001150  2900                        CMP      r1,#0   ;;;1918
001152  d0fb                        BEQ      F23L200   ;;;1918
001154  2808                        CMP      r0,#8   ;;;1918
001156  dbf1                        BLT      F23L92   ;;;1918
001158  e006                        B        F23L251   ;;;1918
                            F23L98
;;;1921   	}
;;;1922   	while (aliasPos < 8)
;;;1923   	{
;;;1924   		newDirEntry.name[aliasPos++] = ' ';
00115a  1c01                        MOV      r1,r0
00115c  aa67                        ADD      r2,sp,#&19c
00115e  1889                        ADD      r1,r2
001160  700e                        STRB     r6,[r1,#0]
001162  3001                        ADD      r0,#1
                            F23L250
001164  2808                        CMP      r0,#8   ;;;1922
001166  dbf8                        BLT      F23L98   ;;;1922
                            F23L251
;;;1925   	}
;;;1926   	aliasPos = 0;
001168  2000                        MOV      r0,#0
00116a  e000                        B        F23L252
                            F23L101
;;;1927   	while ((fileAlias[aliasPos] != '.') && (fileAlias[aliasPos] != '\0'))
;;;1928   		aliasPos++;
00116c  3001                        ADD      r0,#1
                            F23L252
00116e  a91c                        ADD      r1,sp,#&70   ;;;1927
001170  5c09                        LDRB     r1,[r1,r0]   ;;;1927
001172  292e                        CMP      r1,#&2e   ;;;1927
001174  d001                        BEQ      F23L253   ;;;1927
001176  2900                        CMP      r1,#0   ;;;1927
001178  d1f8                        BNE      F23L101   ;;;1927
                            F23L253
;;;1929   	filePos = 0;
00117a  2100                        MOV      r1,#0
00117c  e013                        B        F23L254
                            F23L106
;;;1930   	while (( filePos < 3 ) && (fileAlias[aliasPos] != '\0'))
;;;1931   	{
;;;1932   		tempChar = fileAlias[aliasPos++];
00117e  1c02                        MOV      r2,r0
001180  ab1c                        ADD      r3,sp,#&70
001182  5c9b                        LDRB     r3,[r3,r2]
;;;1933   		if ((tempChar > ' ' && tempChar < ':' && tempChar!='.') || tempChar > '?')
001184  3001                        ADD      r0,#1
001186  1fda                        SUB      r2,r3,#7
001188  3a1a                        SUB      r2,#&1a
00118a  2a19                        CMP      r2,#&19
00118c  d202                        BCS      F23L255
00118e  2b2e                        CMP      r3,#&2e
001190  d007                        BEQ      F23L256
001192  e001                        B        F23L257
                            F23L255
001194  2b3f                        CMP      r3,#&3f
001196  dd04                        BLE      F23L258
                            F23L257
;;;1934   			newDirEntry.ext[filePos++] = tempChar;
001198  1c0a                        MOV      r2,r1
00119a  af67                        ADD      r7,sp,#&19c
00119c  19d2                        ADD      r2,r7
00119e  7213                        STRB     r3,[r2,#8]
0011a0  3101                        ADD      r1,#1
                            F23L256
                            F23L258
0011a2  2903                        CMP      r1,#3   ;;;1930
0011a4  da0c                        BGE      F23L259   ;;;1930
                            F23L254
0011a6  aa1c                        ADD      r2,sp,#&70   ;;;1930
0011a8  5c12                        LDRB     r2,[r2,r0]   ;;;1930
0011aa  2a00                        CMP      r2,#0   ;;;1930
0011ac  d1e7                        BNE      F23L106   ;;;1930
0011ae  2620                        MOV      r6,#&20   ;;;1930
0011b0  e004                        B        F23L260   ;;;1930
                            F23L119
;;;1935   	}
;;;1936   	while (filePos < 3)
;;;1937   	{
;;;1938   		newDirEntry.ext[filePos++] = ' ';
0011b2  1c08                        MOV      r0,r1
0011b4  aa67                        ADD      r2,sp,#&19c
0011b6  1880                        ADD      r0,r2
0011b8  7206                        STRB     r6,[r0,#8]
0011ba  3101                        ADD      r1,#1
                            F23L260
0011bc  2903                        CMP      r1,#3   ;;;1936
0011be  dbf8                        BLT      F23L119   ;;;1936
                            F23L259
;;;1939   	}
;;;1940   
;;;1941   	// Scan Dir for free entry
;;;1942   	dirCluster = curWorkDirCluster;
0011c0  4a54                        LDR      r2,F23L1+4
;;;1943   	secOffset = 0;
0011c2  2700                        MOV      r7,#0
;;;1944   	entryOffset = 0;
;;;1945   	maxSectors = (dirCluster == FAT16_ROOT_DIR_CLUSTER ? (filesysData - filesysRootDir) : filesysSecPerClus);
;;;1946   	firstSector = (dirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(dirCluster));
0011c4  6b95                        LDR      r5,[r2,#&38]
0011c6  2600                        MOV      r6,#0   ;;;1944
0011c8  6a11                        LDR      r1,[r2,#&20]
0011ca  6850                        LDR      r0,[r2,#4]
0011cc  2d00                        CMP      r5,#0
0011ce  d003                        BEQ      F23L261
0011d0  1ea8                        SUB      r0,r5,#2
0011d2  4348                        MUL      r0,r1
0011d4  6991                        LDR      r1,[r2,#&18]
0011d6  1840                        ADD      r0,r1
                            F23L261
;;;1947   	disc_ReadSector (firstSector + secOffset, (void*)dirEntries);
0011d8  2101                        MOV      r1,#1
0011da  1c22                        MOV      r2,r4
0011dc  9018                        STR      r0,[sp,#&60]   ;;;1946
0011de  f7fe ff3f                   BL       MPCF_ReadSectors
0011e2  e03e                        B        F23L262
                            F23L128
;;;1948   	
;;;1949   	dirEntryRemain = dirEntryLength;
;;;1950   	tempDirCluster = dirCluster;
;;;1951   	tempSecOffset = secOffset;
;;;1952   	tempEntryOffset = entryOffset;
;;;1953   		
;;;1954   	// Search for a large enough space to fit in new directory entry
;;;1955   	while ((dirEntries[entryOffset].name[0] != FILE_LAST) && (dirEntryRemain > 0))
;;;1956   	{
;;;1957   
;;;1958   		entryOffset++;
;;;1959   
;;;1960   		if (entryOffset == BYTE_PER_READ / sizeof (DIR_ENT))
0011e4  3601                        ADD      r6,#1
0011e6  2e10                        CMP      r6,#&10
0011e8  d130                        BNE      F23L263
;;;1961   		{
;;;1962   			entryOffset = 0;
;;;1963   			secOffset++;
;;;1964   			if ((secOffset == filesysSecPerClus) && (dirCluster != FAT16_ROOT_DIR_CLUSTER))
0011ea  494a                        LDR      r1,F23L1+4
0011ec  2600                        MOV      r6,#0   ;;;1962
0011ee  6a08                        LDR      r0,[r1,#&20]
0011f0  3701                        ADD      r7,#1
0011f2  4287                        CMP      r7,r0
0011f4  d11b                        BNE      F23L264
0011f6  2d00                        CMP      r5,#0
0011f8  d01b                        BEQ      F23L265
;;;1965   			{
;;;1966   				secOffset = 0;
0011fa  2700                        MOV      r7,#0
;;;1967   				if (FAT_NextCluster(dirCluster) == CLUSTER_EOF)
0011fc  1c28                        MOV      r0,r5
0011fe  f7ff f81d                   BL       FAT_NextCluster
001202  4b45                        LDR      r3,F23L1+8
001204  4298                        CMP      r0,r3
001206  d106                        BNE      F23L266
;;;1968   				{
;;;1969   					dirCluster = FAT_LinkFreeCluster(dirCluster);
001208  1c28                        MOV      r0,r5
00120a  f7ff fa4d                   BL       FAT_LinkFreeCluster
;;;1970   					dirEntries[0].name[0] = FILE_LAST;
00120e  1c05                        MOV      r5,r0
001210  2000                        MOV      r0,#0
001212  7020                        STRB     r0,[r4,#0]
001214  e003                        B        F23L267
                            F23L266
;;;1971   				}
;;;1972   				else
;;;1973   				{
;;;1974   					dirCluster = FAT_NextCluster(dirCluster);
001216  1c28                        MOV      r0,r5
001218  f7ff f810                   BL       FAT_NextCluster
00121c  1c05                        MOV      r5,r0
                            F23L267
;;;1975   				}
;;;1976   				firstSector = FAT_ClustToSect(dirCluster);		
00121e  493d                        LDR      r1,F23L1+4
001220  1ea8                        SUB      r0,r5,#2
001222  6a0a                        LDR      r2,[r1,#&20]
001224  6989                        LDR      r1,[r1,#&18]
001226  4350                        MUL      r0,r2
001228  1840                        ADD      r0,r1
00122a  9018                        STR      r0,[sp,#&60]
00122c  e008                        B        F23L268
                            F23L264
;;;1977   			}
;;;1978   			else if ((dirCluster == FAT16_ROOT_DIR_CLUSTER) && (secOffset == (filesysData - filesysRootDir)))
00122e  2d00                        CMP      r5,#0
001230  d106                        BNE      F23L268
                            F23L265
001232  4938                        LDR      r1,F23L1+4
001234  6988                        LDR      r0,[r1,#&18]
001236  6849                        LDR      r1,[r1,#4]
001238  1a40                        SUB      r0,r1
00123a  42b8                        CMP      r0,r7
00123c  d100                        BNE      F23L269
                            F23L282
00123e  e6bc                        B        F23L30
                            F23L269
                            F23L268
;;;1979   			{
;;;1980   				return false;	// Got to end of root dir - can't fit in more files
;;;1981   			}
;;;1982   			disc_ReadSector (firstSector + secOffset, (void*)dirEntries);
001240  9818                        LDR      r0,[sp,#&60]
001242  2101                        MOV      r1,#1
001244  19c0                        ADD      r0,r7
001246  1c22                        MOV      r2,r4
001248  f7fe ff0a                   BL       MPCF_ReadSectors
                            F23L263
;;;1983   		}
;;;1984   
;;;1985   		if ((dirEntries[entryOffset].name[0] == FILE_FREE) || (dirEntries[entryOffset].name[0] == FILE_LAST) )
00124c  0170                        LSL      r0,r6,#5
00124e  1900                        ADD      r0,r4
001250  7800                        LDRB     r0,[r0,#0]
001252  28e5                        CMP      r0,#&e5
001254  d001                        BEQ      F23L270
001256  2800                        CMP      r0,#0
001258  d103                        BNE      F23L262
                            F23L270
;;;1986   		{
;;;1987   			dirEntryRemain--;
00125a  9805                        LDR      r0,[sp,#&14]
00125c  3801                        SUB      r0,#1
00125e  9005                        STR      r0,[sp,#&14]
001260  e004                        B        F23L271
                            F23L262
;;;1988   		} else {
;;;1989   			dirEntryRemain = dirEntryLength;
001262  9806                        LDR      r0,[sp,#&18]
;;;1990   			tempDirCluster = dirCluster;
001264  9504                        STR      r5,[sp,#&10]
;;;1991   			tempSecOffset = secOffset;
001266  9703                        STR      r7,[sp,#&c]
;;;1992   			tempEntryOffset = entryOffset;
001268  9602                        STR      r6,[sp,#8]
00126a  9005                        STR      r0,[sp,#&14]   ;;;1989
                            F23L271
00126c  0170                        LSL      r0,r6,#5   ;;;1955
00126e  1900                        ADD      r0,r4   ;;;1955
001270  7800                        LDRB     r0,[r0,#0]   ;;;1955
001272  2800                        CMP      r0,#0   ;;;1955
001274  d002                        BEQ      F23L272   ;;;1955
001276  9805                        LDR      r0,[sp,#&14]   ;;;1955
001278  2800                        CMP      r0,#0   ;;;1955
00127a  dcb3                        BGT      F23L128   ;;;1955
                            F23L272
;;;1993   		}
;;;1994   	}
;;;1995   
;;;1996   	// Modifying the last directory is a special case - have to erase following entries
;;;1997   	if (dirEntries[entryOffset].name[0] == FILE_LAST) 
00127c  0170                        LSL      r0,r6,#5
00127e  1900                        ADD      r0,r4
001280  7800                        LDRB     r0,[r0,#0]
001282  2800                        CMP      r0,#0
001284  d101                        BNE      F23L273
;;;1998   	{
;;;1999   		dirEndFlag = true;
001286  2001                        MOV      r0,#1
001288  9001                        STR      r0,[sp,#4]
                            F23L273
;;;2000   	}
;;;2001   
;;;2002   	// Recall last used entry
;;;2003   	dirCluster = tempDirCluster;
;;;2004   	secOffset = tempSecOffset;
;;;2005   	entryOffset = tempEntryOffset;
00128a  af02                        ADD      r7,sp,#8
00128c  cfa1                        LDMIA    r7!,{r0,r5,r7}
00128e  9019                        STR      r0,[sp,#&64]
;;;2006   	dirEntryRemain = dirEntryLength;
001290  9806                        LDR      r0,[sp,#&18]
001292  9005                        STR      r0,[sp,#&14]
001294  e0a1                        B        F23L274
                            F23L152
;;;2007   		
;;;2008   	// Add new directory entry
;;;2009   	while (dirEntryRemain > 0)	
;;;2010   	{
;;;2011   		// Move to next entry, first pass advances from last used entry
;;;2012   		entryOffset++;
001296  9819                        LDR      r0,[sp,#&64]
001298  3001                        ADD      r0,#1
00129a  9019                        STR      r0,[sp,#&64]
;;;2013   		if (entryOffset == BYTE_PER_READ / sizeof (DIR_ENT))
00129c  2810                        CMP      r0,#&10
00129e  d14a                        BNE      F23L275
;;;2014   		{
;;;2015   			// Write out the current sector if we need to
;;;2016   			entryOffset = 0;
0012a0  2000                        MOV      r0,#0
;;;2017   			if (dirEntryRemain < dirEntryLength) // Don't write out sector on first pass
0012a2  9b05                        LDR      r3,[sp,#&14]
0012a4  9e06                        LDR      r6,[sp,#&18]
0012a6  9019                        STR      r0,[sp,#&64]   ;;;2016
0012a8  42b3                        CMP      r3,r6
0012aa  da05                        BGE      F23L276
;;;2018   			{
;;;2019   				disc_WriteSector (firstSector + secOffset, (void*)dirEntries);
0012ac  9818                        LDR      r0,[sp,#&60]
0012ae  2101                        MOV      r1,#1
0012b0  1940                        ADD      r0,r5
0012b2  1c22                        MOV      r2,r4
0012b4  f7fe ff40                   BL       MPCF_WriteSectors
                            F23L276
;;;2020   			}
;;;2021   			secOffset++;
;;;2022   			if ((secOffset == filesysSecPerClus) && (dirCluster != FAT16_ROOT_DIR_CLUSTER))
0012b8  4e16                        LDR      r6,F23L1+4
0012ba  3501                        ADD      r5,#1
0012bc  6a30                        LDR      r0,[r6,#&20]
0012be  4285                        CMP      r5,r0
0012c0  d11a                        BNE      F23L277
0012c2  2f00                        CMP      r7,#0
0012c4  d01a                        BEQ      F23L278
;;;2023   			{
;;;2024   				secOffset = 0;
0012c6  2500                        MOV      r5,#0
;;;2025   				if (FAT_NextCluster(dirCluster) == CLUSTER_EOF)
0012c8  1c38                        MOV      r0,r7
0012ca  f7fe ffb7                   BL       FAT_NextCluster
0012ce  4b12                        LDR      r3,F23L1+8
0012d0  4298                        CMP      r0,r3
0012d2  d106                        BNE      F23L279
;;;2026   				{
;;;2027   					dirCluster = FAT_LinkFreeCluster(dirCluster);
0012d4  1c38                        MOV      r0,r7
0012d6  f7ff f9e7                   BL       FAT_LinkFreeCluster
;;;2028   					dirEntries[0].name[0] = FILE_LAST;
0012da  1c07                        MOV      r7,r0
0012dc  2000                        MOV      r0,#0
0012de  7020                        STRB     r0,[r4,#0]
0012e0  e003                        B        F23L280
                            F23L279
;;;2029   				}
;;;2030   				else
;;;2031   				{
;;;2032   					dirCluster = FAT_NextCluster(dirCluster);
0012e2  1c38                        MOV      r0,r7
0012e4  f7fe ffaa                   BL       FAT_NextCluster
0012e8  1c07                        MOV      r7,r0
                            F23L280
;;;2033   				}
;;;2034   				firstSector = FAT_ClustToSect(dirCluster);		
0012ea  6a32                        LDR      r2,[r6,#&20]
0012ec  1eb8                        SUB      r0,r7,#2
0012ee  4350                        MUL      r0,r2
0012f0  69b1                        LDR      r1,[r6,#&18]
0012f2  1840                        ADD      r0,r1
0012f4  9018                        STR      r0,[sp,#&60]
0012f6  e006                        B        F23L281
                            F23L277
;;;2035   			}
;;;2036   			else if ((dirCluster == FAT16_ROOT_DIR_CLUSTER) && (secOffset == (filesysData - filesysRootDir)))
0012f8  2f00                        CMP      r7,#0
0012fa  d104                        BNE      F23L281
                            F23L278
0012fc  69b0                        LDR      r0,[r6,#&18]
0012fe  6871                        LDR      r1,[r6,#4]
001300  1a40                        SUB      r0,r1
001302  42a8                        CMP      r0,r5
001304  d09b                        BEQ      F23L282
                            F23L281
;;;2037   			{
;;;2038   				return false;	// Got to end of root dir - can't fit in more files
;;;2039   			}
;;;2040   			if (dirEndFlag)
001306  9801                        LDR      r0,[sp,#4]
001308  2800                        CMP      r0,#0
00130a  d00e                        BEQ      F23L283
;;;2041   			{
;;;2042   				memset ((void*)dirEntries, FILE_LAST, BYTE_PER_READ);
00130c  e006                        B        F23L285
00130e  0000                        LSL      r0,#0
                            F23L1
001310  00000000                    DCD      globalBuffer
001314  00000000                    DCD      |x$dataseg|
001318  0fffffff                    DCD      0x0fffffff
                            F23L285
00131c  2201                        MOV      r2,#1
00131e  0252                        LSL      r2,#9
001320  2100                        MOV      r1,#0
001322  1c20                        MOV      r0,r4
001324  f7fe fe6c                   BL       memset
001328  e005                        B        F23L287
                            F23L283
;;;2043   			} else {
;;;2044   				disc_ReadSector (firstSector + secOffset, (void*)dirEntries);
00132a  9818                        LDR      r0,[sp,#&60]
00132c  2101                        MOV      r1,#1
00132e  1940                        ADD      r0,r5
001330  1c22                        MOV      r2,r4
001332  f7fe fe95                   BL       MPCF_ReadSectors
                            F23L275
                            F23L287
;;;2045   			}
;;;2046   		}
;;;2047   
;;;2048   		// Generate LFN entries
;;;2049   		if (lfnPos >= 0)
001336  9807                        LDR      r0,[sp,#&1c]
001338  2800                        CMP      r0,#0
00133a  db39                        BLT      F23L288
;;;2050   		{
;;;2051   			int ii,jj;
;;;2052   			u8*filename_pos=(u8*)filename+lfnPos*13;
00133c  9807                        LDR      r0,[sp,#&1c]
00133e  230d                        MOV      r3,#&d
001340  4358                        MUL      r0,r3
001342  a921                        ADD      r1,sp,#&84
001344  1843                        ADD      r3,r0,r1
;;;2053   			u8*lfn_str=(u8*)&lfnEntry;
;;;2054   			lfnEntry.ordinal = (lfnPos + 1) | (dirEntryRemain == dirEntryLength ? LFN_END : 0);
001346  9907                        LDR      r1,[sp,#&1c]
001348  9300                        STR      r3,[sp,#0]   ;;;2052
00134a  9b05                        LDR      r3,[sp,#&14]
00134c  9e06                        LDR      r6,[sp,#&18]
00134e  1c4a                        ADD      r2,r1,#1
001350  2140                        MOV      r1,#&40
001352  42b3                        CMP      r3,r6
001354  a810                        ADD      r0,sp,#&40
001356  d000                        BEQ      F23L289
001358  2100                        MOV      r1,#0
                            F23L289
00135a  4311                        ORR      r1,r2
00135c  ab10                        ADD      r3,sp,#&40
00135e  7019                        STRB     r1,[r3,#0]
;;;2055   			
;;;2056   			for (ii=0;ii<13;ii++)
001360  2100                        MOV      r1,#0
001362  2600                        MOV      r6,#0
                            F23L176
;;;2057   			{
;;;2058   				jj=lfn_offset_table[ii];
001364  4a26                        LDR      r2,F23L286
001366  5c52                        LDRB     r2,[r2,r1]
;;;2059   				if (filename_pos[ii]==0x01)
001368  9b00                        LDR      r3,[sp,#0]
00136a  5c5b                        LDRB     r3,[r3,r1]
00136c  2b01                        CMP      r3,#1
00136e  d102                        BNE      F23L290
;;;2060   				{
;;;2061   					lfn_str[jj]=0xFF;
001370  23ff                        MOV      r3,#&ff
001372  5483                        STRB     r3,[r0,r2]
001374  e001                        B        F23L291
                            F23L290
;;;2062   					lfn_str[jj+1]=0xFF;
;;;2063   				}
;;;2064   				else
;;;2065   				{
;;;2066   					lfn_str[jj]=filename_pos[ii];
001376  5483                        STRB     r3,[r0,r2]
;;;2067   					lfn_str[jj+1]=0x00;
001378  1c33                        MOV      r3,r6
                            F23L291
00137a  1882                        ADD      r2,r0,r2
00137c  3101                        ADD      r1,#1   ;;;2056
00137e  290d                        CMP      r1,#&d   ;;;2056
001380  7053                        STRB     r3,[r2,#1]
001382  dbef                        BLT      F23L176   ;;;2056
;;;2068   				}
;;;2069   			}
;;;2070   /*			
;;;2071   			lfnEntry.char0 = filename [lfnPos * 13 + 0];
;;;2072   			lfnEntry.char1 = (filename [lfnPos * 13 + 1] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 1]);
;;;2073   			lfnEntry.char2 = (filename [lfnPos * 13 + 2] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 2]);
;;;2074   			lfnEntry.char3 = (filename [lfnPos * 13 + 3] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 3]);
;;;2075   			lfnEntry.char4 = (filename [lfnPos * 13 + 4] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 4]);
;;;2076   			lfnEntry.char5 = (filename [lfnPos * 13 + 5] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 5]);
;;;2077   			lfnEntry.char6 = (filename [lfnPos * 13 + 6] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 6]);
;;;2078   			lfnEntry.char7 = (filename [lfnPos * 13 + 7] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 7]);
;;;2079   			lfnEntry.char8 = (filename [lfnPos * 13 + 8] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 8]);
;;;2080   			lfnEntry.char9 = (filename [lfnPos * 13 + 9] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 9]);
;;;2081   			lfnEntry.char10 = (filename [lfnPos * 13 + 10] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 10]);
;;;2082   			lfnEntry.char11 = (filename [lfnPos * 13 + 11] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 11]);
;;;2083   			lfnEntry.char12 = (filename [lfnPos * 13 + 12] == 0x01 ? 0xFFFF : filename [lfnPos * 13 + 12]);
;;;2084   			*/
;;;2085   			lfnEntry.checkSum = chkSum;
001384  981b                        LDR      r0,[sp,#&6c]
001386  ab13                        ADD      r3,sp,#&4c
001388  7058                        STRB     r0,[r3,#1]
;;;2086   			lfnEntry.flag = ATTRIB_LFN;
00138a  200f                        MOV      r0,#&f
00138c  3b04                        SUB      r3,#4
00138e  70d8                        STRB     r0,[r3,#3]
;;;2087   			lfnEntry.reserved1 = 0;
001390  ab13                        ADD      r3,sp,#&4c
001392  701e                        STRB     r6,[r3,#0]
;;;2088   			lfnEntry.reserved2 = 0;
001394  81de                        STRH     r6,[r3,#&e]
;;;2089   			
;;;2090   			*((DIR_ENT_LFN*)&dirEntries[entryOffset]) = lfnEntry;
001396  9819                        LDR      r0,[sp,#&64]
001398  a910                        ADD      r1,sp,#&40
00139a  0140                        LSL      r0,#5
00139c  1900                        ADD      r0,r4
00139e  2220                        MOV      r2,#&20
0013a0  f7fe fe2e                   BL       memcpy
;;;2091   			lfnPos --;
0013a4  9807                        LDR      r0,[sp,#&1c]
;;;2092   			lfnEntry.ordinal = 0;
0013a6  ab10                        ADD      r3,sp,#&40
0013a8  3801                        SUB      r0,#1   ;;;2091
0013aa  9007                        STR      r0,[sp,#&1c]   ;;;2091
0013ac  701e                        STRB     r6,[r3,#0]
0013ae  e011                        B        F23L292
                            F23L288
;;;2093   		}	// end writing long filename entries
;;;2094   		else
;;;2095   		{
;;;2096   			dirEntries[entryOffset] = newDirEntry;
0013b0  9819                        LDR      r0,[sp,#&64]
0013b2  a967                        ADD      r1,sp,#&19c
0013b4  0140                        LSL      r0,#5
0013b6  1900                        ADD      r0,r4
0013b8  2220                        MOV      r2,#&20
0013ba  1c06                        MOV      r6,r0
0013bc  f7fe fe20                   BL       memcpy
;;;2097   			if (dirEndFlag && (entryOffset < (BYTE_PER_READ / sizeof (DIR_ENT))) )
0013c0  9801                        LDR      r0,[sp,#4]
0013c2  2800                        CMP      r0,#0
0013c4  d006                        BEQ      F23L292
0013c6  9819                        LDR      r0,[sp,#&64]
0013c8  2810                        CMP      r0,#&10
0013ca  d203                        BCS      F23L293
;;;2098   				dirEntries[entryOffset+1].name[0] = FILE_LAST;
0013cc  2000                        MOV      r0,#0
0013ce  1df1                        ADD      r1,r6,#7
0013d0  3119                        ADD      r1,#&19
0013d2  7008                        STRB     r0,[r1,#0]
                            F23L292
                            F23L293
;;;2099   		}
;;;2100   
;;;2101   		dirEntryRemain--;
0013d4  9b05                        LDR      r3,[sp,#&14]
0013d6  3b01                        SUB      r3,#1
0013d8  9305                        STR      r3,[sp,#&14]
                            F23L274
0013da  9b05                        LDR      r3,[sp,#&14]   ;;;2009
0013dc  2b00                        CMP      r3,#0   ;;;2009
0013de  dd00                        BLE      F23L294   ;;;2009
0013e0  e759                        B        F23L152   ;;;2009
                            F23L294
;;;2102   	}
;;;2103   	
;;;2104   	// Write directory back to disk
;;;2105   	disc_WriteSector (firstSector + secOffset, (void*)dirEntries);
0013e2  9818                        LDR      r0,[sp,#&60]
0013e4  2101                        MOV      r1,#1
0013e6  1940                        ADD      r0,r5
0013e8  1c22                        MOV      r2,r4
0013ea  f7fe fea5                   BL       MPCF_WriteSectors
;;;2106   
;;;2107   	// Change back to Working DIR
;;;2108   	curWorkDirCluster = oldWorkDirCluster;
0013ee  981a                        LDR      r0,[sp,#&68]
0013f0  4904                        LDR      r1,F23L286+4
;;;2109   
;;;2110   	return true;
0013f2  6388                        STR      r0,[r1,#&38]
0013f4  2001                        MOV      r0,#1
                            F23L226
0013f6  b061                        ADD      sp,#&184
0013f8  bcf0                        POP      {r4-r7}
0013fa  bc08                        POP      {r3}
0013fc  b004                        ADD      sp,#&10
0013fe  4718                        BX       r3
                            F23L286
001400  00000000                    DCD      |x$constdata|
001404  00000000                    DCD      |x$dataseg|

;;;2111   }
;;;2112   
;;;2113   
;;;2114   
;;;2115   /*-----------------------------------------------------------------
;;;2116   FAT_FindNextFile
;;;2117   Gets the name of the next directory entry
;;;2118   	(can be a file or subdirectory)
;;;2119   char* filename: OUT filename, must be at least 13 chars long
;;;2120   FILE_TYPE return: OUT returns FT_NONE if failed, 
;;;2121   	FT_FILE if it found a file and FT_DIR if it found a directory
;;;2122   -----------------------------------------------------------------*/
;;;2123   FILE_TYPE FAT_FindNextFile(char* filename)
;;;2124   {
001408                      FAT_FindNextFile
001408  b590                        PUSH     {r4,r7,lr}
00140a  b08d                        SUB      sp,#&34
;;;2125   	// Get the next directory entry
;;;2126   	DIR_ENT file;
;;;2127   	file = FAT_GetDirEntry (curWorkDirCluster, 1, SEEK_CUR);
00140c  1c07                        MOV      r7,r0
00140e  4813                        LDR      r0,F24L1
001410  2301                        MOV      r3,#1
001412  6b81                        LDR      r1,[r0,#&38]
001414  a805                        ADD      r0,sp,#&14
001416  2201                        MOV      r2,#1
001418  f7ff faa6                   BL       FAT_GetDirEntry
;;;2128   
;;;2129   	if (file.name[0] == FILE_FREE)
00141c  a805                        ADD      r0,sp,#&14
00141e  7800                        LDRB     r0,[r0,#0]
001420  28e5                        CMP      r0,#&e5
001422  d101                        BNE      F24L16
;;;2130   	{
;;;2131   		return FT_NONE;	// Did not find a file
001424  2000                        MOV      r0,#0
001426  e014                        B        F24L17
                            F24L16
;;;2132   	}
;;;2133   
;;;2134   	// Get the filename
;;;2135   	if (filename != NULL)
001428  2f00                        CMP      r7,#0
00142a  d00b                        BEQ      F24L18
;;;2136   		FAT_GetFilename (file, filename);
00142c  9704                        STR      r7,[sp,#&10]
00142e  a909                        ADD      r1,sp,#&24
001430  c98e                        LDMIA    r1!,{r1-r3,r7}
001432  4668                        MOV      r0,sp
001434  c08e                        STMIA    r0!,{r1-r3,r7}
001436  af05                        ADD      r7,sp,#&14
001438  cf83                        LDMIA    r7!,{r0,r1,r7}
00143a  9c08                        LDR      r4,[sp,#&20]
00143c  1c3a                        MOV      r2,r7
00143e  1c23                        MOV      r3,r4
001440  f7ff fbca                   BL       FAT_GetFilename
                            F24L18
;;;2137   
;;;2138   	if ((file.attrib & ATTRIB_DIR) != 0)
001444  a807                        ADD      r0,sp,#&1c
001446  78c0                        LDRB     r0,[r0,#3]
001448  0940                        LSR      r0,#5
00144a  d301                        BCC      F24L19
;;;2139   	{
;;;2140   		return FT_DIR;	// Found a directory
00144c  2002                        MOV      r0,#2
00144e  e000                        B        F24L17
                            F24L19
;;;2141   	}
;;;2142   	else
;;;2143   	{
;;;2144   		return FT_FILE;	// Found a file
001450  2001                        MOV      r0,#1
                            F24L17
001452  b00d                        ADD      sp,#&34
001454  bc90                        POP      {r4,r7}
001456  bc08                        POP      {r3}
001458  4718                        BX       r3
00145a  0000                        LSL      r0,#0
                            F24L1
00145c  00000000                    DCD      |x$dataseg|

;;;2145   	}
;;;2146   }
;;;2147   
;;;2148   /*-----------------------------------------------------------------
;;;2149   FAT_FindFirstFile
;;;2150   Gets the name of the first directory entry and resets the count
;;;2151   	(can be a file or subdirectory)
;;;2152   char* filename: OUT filename, must be at least 13 chars long
;;;2153   FILE_TYPE return: OUT returns FT_NONE if failed, 
;;;2154   	FT_FILE if it found a file and FT_DIR if it found a directory
;;;2155   -----------------------------------------------------------------*/
;;;2156   FILE_TYPE FAT_FindFirstFile(char* filename)
;;;2157   {
001460                      FAT_FindFirstFile
001460  b590                        PUSH     {r4,r7,lr}
001462  b08d                        SUB      sp,#&34
;;;2158   	// Get the first directory entry
;;;2159   	DIR_ENT file;
;;;2160   	file = FAT_GetDirEntry (curWorkDirCluster, 1, SEEK_SET);
001464  1c07                        MOV      r7,r0
001466  4813                        LDR      r0,F25L1
001468  2300                        MOV      r3,#0
00146a  6b81                        LDR      r1,[r0,#&38]
00146c  a805                        ADD      r0,sp,#&14
00146e  2201                        MOV      r2,#1
001470  f7ff fa7a                   BL       FAT_GetDirEntry
;;;2161   	
;;;2162   	if (file.name[0] == FILE_FREE)
001474  a805                        ADD      r0,sp,#&14
001476  7800                        LDRB     r0,[r0,#0]
001478  28e5                        CMP      r0,#&e5
00147a  d101                        BNE      F25L16
;;;2163   	{
;;;2164   		return FT_NONE;	// Did not find a file
00147c  2000                        MOV      r0,#0
00147e  e014                        B        F25L17
                            F25L16
;;;2165   	}
;;;2166   
;;;2167   	// Get the filename
;;;2168   	if (filename != NULL)
001480  2f00                        CMP      r7,#0
001482  d00b                        BEQ      F25L18
;;;2169   		FAT_GetFilename (file, filename);
001484  9704                        STR      r7,[sp,#&10]
001486  a909                        ADD      r1,sp,#&24
001488  c98e                        LDMIA    r1!,{r1-r3,r7}
00148a  4668                        MOV      r0,sp
00148c  c08e                        STMIA    r0!,{r1-r3,r7}
00148e  af05                        ADD      r7,sp,#&14
001490  cf83                        LDMIA    r7!,{r0,r1,r7}
001492  9c08                        LDR      r4,[sp,#&20]
001494  1c3a                        MOV      r2,r7
001496  1c23                        MOV      r3,r4
001498  f7ff fb9e                   BL       FAT_GetFilename
                            F25L18
;;;2170   
;;;2171   	if ((file.attrib & ATTRIB_DIR) != 0)
00149c  a807                        ADD      r0,sp,#&1c
00149e  78c0                        LDRB     r0,[r0,#3]
0014a0  0940                        LSR      r0,#5
0014a2  d301                        BCC      F25L19
;;;2172   	{
;;;2173   		return FT_DIR;	// Found a directory
0014a4  2002                        MOV      r0,#2
0014a6  e000                        B        F25L17
                            F25L19
;;;2174   	}
;;;2175   	else
;;;2176   	{
;;;2177   		return FT_FILE;	// Found a file
0014a8  2001                        MOV      r0,#1
                            F25L17
0014aa  b00d                        ADD      sp,#&34
0014ac  bc90                        POP      {r4,r7}
0014ae  bc08                        POP      {r3}
0014b0  4718                        BX       r3
0014b2  0000                        LSL      r0,#0
                            F25L1
0014b4  00000000                    DCD      |x$dataseg|

;;;2178   	}
;;;2179   }
;;;2180   
;;;2181   /*-----------------------------------------------------------------
;;;2182   FAT_FindFirstFileLFN
;;;2183   Gets the long file name of the first directory entry and resets
;;;2184   	the count (can be a file or subdirectory)
;;;2185   char* lfn: OUT long file name, must be at least 256 chars long
;;;2186   FILE_TYPE return: OUT returns FT_NONE if failed, 
;;;2187   	FT_FILE if it found a file and FT_DIR if it found a directory
;;;2188   -----------------------------------------------------------------*/
;;;2189   FILE_TYPE FAT_FindFirstFileLFN(char* lfn)
;;;2190   {
0014b8                      FAT_FindFirstFileLFN
0014b8  b590                        PUSH     {r4,r7,lr}
;;;2191   	FILE_TYPE type;
;;;2192   	type = FAT_FindFirstFile(NULL);
0014ba  1c04                        MOV      r4,r0
0014bc  2000                        MOV      r0,#0
0014be  f7ff ffcf                   BL       FAT_FindFirstFile
;;;2193   	FAT_GetLongFilename (lfn);
0014c2  1c07                        MOV      r7,r0
0014c4  1c20                        MOV      r0,r4
0014c6  f7ff fb71                   BL       FAT_GetLongFilename
;;;2194   	return type;
0014ca  1c38                        MOV      r0,r7
0014cc  bc90                        POP      {r4,r7}
0014ce  bc08                        POP      {r3}
0014d0  4718                        BX       r3

;;;2195   }
;;;2196   
;;;2197   /*-----------------------------------------------------------------
;;;2198   FAT_FindNextFileLFN
;;;2199   Gets the long file name of the next directory entry
;;;2200   	(can be a file or subdirectory)
;;;2201   char* lfn: OUT long file name, must be at least 256 chars long
;;;2202   FILE_TYPE return: OUT returns FT_NONE if failed, 
;;;2203   	FT_FILE if it found a file and FT_DIR if it found a directory
;;;2204   -----------------------------------------------------------------*/
;;;2205   FILE_TYPE FAT_FindNextFileLFN(char* lfn)
;;;2206   {
0014d2                      FAT_FindNextFileLFN
0014d2  b590                        PUSH     {r4,r7,lr}
;;;2207   	FILE_TYPE type;
;;;2208   	type = FAT_FindNextFile(NULL);
0014d4  1c04                        MOV      r4,r0
0014d6  2000                        MOV      r0,#0
0014d8  f7ff ff96                   BL       FAT_FindNextFile
;;;2209   	FAT_GetLongFilename (lfn);
0014dc  1c07                        MOV      r7,r0
0014de  1c20                        MOV      r0,r4
0014e0  f7ff fb64                   BL       FAT_GetLongFilename
;;;2210   	return type;
0014e4  1c38                        MOV      r0,r7
0014e6  bc90                        POP      {r4,r7}
0014e8  bc08                        POP      {r3}
0014ea  4718                        BX       r3

;;;2211   }
;;;2212   
;;;2213   
;;;2214   /*-----------------------------------------------------------------
;;;2215   FAT_FileExists
;;;2216   Returns the type of file 
;;;2217   char* filename: IN filename of the file to look for
;;;2218   FILE_TYPE return: OUT returns FT_NONE if there is now file with 
;;;2219   	that name, FT_FILE if it is a file and FT_DIR if it is a directory
;;;2220   -----------------------------------------------------------------*/
;;;2221   FILE_TYPE FAT_FileExists(const char* filename)
;;;2222   {
0014ec                      FAT_FileExists
0014ec  b500                        PUSH     {lr}
0014ee  b088                        SUB      sp,#&20
;;;2223       DIR_ENT dirEntry; 
;;;2224       // Get the dirEntry for the path specified 
;;;2225       dirEntry = FAT_DirEntFromPath (filename); 
0014f0  1c01                        MOV      r1,r0
0014f2  4668                        MOV      r0,sp
0014f4  f7ff fc28                   BL       FAT_DirEntFromPath
;;;2226   
;;;2227       if (dirEntry.name[0] == FILE_FREE) 
0014f8  a800                        ADD      r0,sp,#0
0014fa  7800                        LDRB     r0,[r0,#0]
0014fc  28e5                        CMP      r0,#&e5
0014fe  d101                        BNE      F28L15
;;;2228       { 
;;;2229           return FT_NONE; 
001500  2000                        MOV      r0,#0
001502  e006                        B        F28L16
                            F28L15
;;;2230       } 
;;;2231       else if (dirEntry.attrib & ATTRIB_DIR) 
001504  a802                        ADD      r0,sp,#8
001506  78c0                        LDRB     r0,[r0,#3]
001508  0940                        LSR      r0,#5
00150a  d301                        BCC      F28L17
;;;2232       { 
;;;2233           return FT_DIR; 
00150c  2002                        MOV      r0,#2
00150e  e000                        B        F28L16
                            F28L17
;;;2234       } 
;;;2235       else 
;;;2236       { 
;;;2237            return FT_FILE; 
001510  2001                        MOV      r0,#1
                            F28L16
001512  b008                        ADD      sp,#&20
001514  bc08                        POP      {r3}
001516  4718                        BX       r3

;;;2238       } 
;;;2239   }
;;;2240   
;;;2241   /*-----------------------------------------------------------------
;;;2242   FAT_chdir
;;;2243   Changes the current working directory
;;;2244   const char* path: IN null terminated string of directory separated by 
;;;2245   	forward slashes, / is root
;;;2246   bool return: OUT returns true if successful
;;;2247   -----------------------------------------------------------------*/
;;;2248   bool FAT_chdir (const char* path)
;;;2249   {
001518                      FAT_chdir
001518  b590                        PUSH     {r4,r7,lr}
00151a  b088                        SUB      sp,#&20
;;;2250   	DIR_ENT dir;
;;;2251   	if (path[0] == '/' && path[1] == '\0')
00151c  7801                        LDRB     r1,[r0,#0]
00151e  2701                        MOV      r7,#1
001520  4c18                        LDR      r4,F29L1
001522  292f                        CMP      r1,#&2f
001524  d105                        BNE      F29L19
001526  7842                        LDRB     r2,[r0,#1]
001528  2a00                        CMP      r2,#0
00152a  d102                        BNE      F29L19
;;;2252   	{
;;;2253   		curWorkDirCluster = filesysRootDirClus;
00152c  68a0                        LDR      r0,[r4,#8]
00152e  63a0                        STR      r0,[r4,#&38]
001530  e001                        B        F29L20
                            F29L19
;;;2254   		return true;
;;;2255   	}
;;;2256   	if (path[0] == '\0')	// Return true if changing relative to nothing
001532  2900                        CMP      r1,#0
001534  d101                        BNE      F29L21
                            F29L20
                            F29L8
;;;2257   	{
;;;2258   		return true;
001536  1c38                        MOV      r0,r7
001538  e01f                        B        F29L22
                            F29L21
;;;2259   	}
;;;2260   	
;;;2261   	dir = FAT_DirEntFromPath (path);
00153a  1c01                        MOV      r1,r0
00153c  4668                        MOV      r0,sp
00153e  f7ff fc03                   BL       FAT_DirEntFromPath
;;;2262   
;;;2263   	if (((dir.attrib & ATTRIB_DIR) == ATTRIB_DIR) && (dir.name[0] != FILE_FREE))
001542  a802                        ADD      r0,sp,#8
001544  78c0                        LDRB     r0,[r0,#3]
001546  2110                        MOV      r1,#&10
001548  4001                        AND      r1,r0
00154a  2000                        MOV      r0,#0
00154c  2910                        CMP      r1,#&10
00154e  d114                        BNE      F29L22
001550  a900                        ADD      r1,sp,#0
001552  7809                        LDRB     r1,[r1,#0]
001554  29e5                        CMP      r1,#&e5
001556  d010                        BEQ      F29L23
;;;2264   	{
;;;2265   		// Change directory
;;;2266   		curWorkDirCluster = dir.startCluster | (dir.startClusterHigh << 16);
001558  aa05                        ADD      r2,sp,#&14
00155a  8812                        LDRH     r2,[r2,#0]
00155c  a906                        ADD      r1,sp,#&18
00155e  8849                        LDRH     r1,[r1,#2]
001560  0412                        LSL      r2,#16
001562  4311                        ORR      r1,r2
;;;2267   
;;;2268   		// Move to correct cluster for root directory
;;;2269   		if (curWorkDirCluster == FAT16_ROOT_DIR_CLUSTER)
001564  63a1                        STR      r1,[r4,#&38]
001566  d101                        BNE      F29L24
;;;2270   		{
;;;2271   			curWorkDirCluster = filesysRootDirClus;
001568  68a1                        LDR      r1,[r4,#8]
00156a  63a1                        STR      r1,[r4,#&38]
                            F29L24
;;;2272   		}
;;;2273   
;;;2274   		// Reset file position in directory
;;;2275   		wrkDirCluster = curWorkDirCluster;
00156c  6ba1                        LDR      r1,[r4,#&38]
;;;2276   		wrkDirSector = 0;
;;;2277   		wrkDirOffset = -1;
00156e  6420                        STR      r0,[r4,#&40]
001570  2000                        MOV      r0,#0
001572  43c0                        MVN      r0,r0
001574  63e1                        STR      r1,[r4,#&3c]
001576  6460                        STR      r0,[r4,#&44]
001578  e7dd                        B        F29L8
                            F29L22
                            F29L23
00157a  b008                        ADD      sp,#&20
00157c  bc90                        POP      {r4,r7}
00157e  bc08                        POP      {r3}
001580  4718                        BX       r3
001582  0000                        LSL      r0,#0
                            F29L1
001584  00000000                    DCD      |x$dataseg|

;;;2278   		return true;
;;;2279   	}
;;;2280   	else
;;;2281   	{ 
;;;2282   		// Couldn't change directory - wrong path specified
;;;2283   		return false;
;;;2284   	}
;;;2285   }
;;;2286   
;;;2287   /*-----------------------------------------------------------------
;;;2288   FAT_fopen(filename, mode)
;;;2289   Opens a file
;;;2290   const char* path: IN null terminated string of filename and path 
;;;2291   	separated by forward slashes, / is root
;;;2292   const char* mode: IN mode to open file in
;;;2293   	Supported modes: "r", "r+", "w", "w+", "a", "a+", don't use
;;;2294   	"b" or "t" in any mode, as all files are openned in binary mode
;;;2295   FAT_FILE* return: OUT handle to open file, returns NULL if the file 
;;;2296   	couldn't be openned
;;;2297   -----------------------------------------------------------------*/
;;;2298   FAT_FILE* FAT_fopen(const char* path, const char* mode)
;;;2299   {
001588                      FAT_fopen
001588  b5f3                        PUSH     {r0,r1,r4-r7,lr}
00158a  b08f                        SUB      sp,#&3c
;;;2300   	int fileNum;
;;;2301   	FAT_FILE* file;
;;;2302   	DIR_ENT dirEntry;
;;;2303   	u32 startCluster;
;;;2304   	int clusCount;
;;;2305   
;;;2306   	char* pchTemp;
;;;2307   	// Check that a valid mode was specified
;;;2308   	pchTemp = strpbrk ( mode, "rRwWaA" );
00158c  9810                        LDR      r0,[sp,#&40]
00158e  a1fa                        ADR      r1,F30L1
001590  f7fe fd36                   BL       strpbrk
;;;2309   	if (pchTemp == NULL)
001594  2800                        CMP      r0,#0
001596  d00d                        BEQ      F30L91
;;;2310   	{
;;;2311   		return NULL;
;;;2312   	}
;;;2313   	if (strpbrk ( pchTemp+1, "rRwWaA" ) != NULL)
001598  3001                        ADD      r0,#1
00159a  a1f7                        ADR      r1,F30L1
00159c  f7fe fd30                   BL       strpbrk
0015a0  2800                        CMP      r0,#0
0015a2  d107                        BNE      F30L92
;;;2314   	{
;;;2315   		return NULL;
;;;2316   	}
;;;2317   		
;;;2318   	// Get the dirEntry for the path specified
;;;2319   	dirEntry = FAT_DirEntFromPath (path);
0015a4  990f                        LDR      r1,[sp,#&3c]
0015a6  a806                        ADD      r0,sp,#&18
0015a8  f7ff fbce                   BL       FAT_DirEntFromPath
;;;2320   	
;;;2321   	// Check that it is not a directory
;;;2322   	if (dirEntry.attrib & ATTRIB_DIR)
0015ac  a808                        ADD      r0,sp,#&20
0015ae  78c0                        LDRB     r0,[r0,#3]
0015b0  0940                        LSR      r0,#5
0015b2  d301                        BCC      F30L93
                            F30L91
                            F30L92
                            F30L5
0015b4  2000                        MOV      r0,#0   ;;;2311
0015b6  e207                        B        F30L94   ;;;2311
                            F30L93
;;;2323   	{
;;;2324   		return NULL;
;;;2325   	}
;;;2326   
;;;2327   	// Check that it is not a read only file being openned in a writing mode
;;;2328   	if ( (strpbrk(mode, "wWaA+") != NULL) && (dirEntry.attrib & ATTRIB_RO))
0015b8  9810                        LDR      r0,[sp,#&40]
0015ba  a1f1                        ADR      r1,F30L1+8
0015bc  f7fe fd20                   BL       strpbrk
0015c0  2800                        CMP      r0,#0
0015c2  d003                        BEQ      F30L95
0015c4  a808                        ADD      r0,sp,#&20
0015c6  78c0                        LDRB     r0,[r0,#3]
0015c8  0840                        LSR      r0,#1
0015ca  d2f3                        BCS      F30L5
                            F30L95
;;;2329   	{
;;;2330   		return NULL;
;;;2331   	}
;;;2332   	
;;;2333   	// Find a free file buffer
;;;2334   	for (fileNum = 0; (fileNum < MAX_FILES_OPEN) && (openFiles[fileNum].inUse == true); fileNum++);
0015cc  2000                        MOV      r0,#0
0015ce  49ee                        LDR      r1,F30L1+16
0015d0  e002                        B        F30L96
                            F30L13
0015d2  3001                        ADD      r0,#1
0015d4  2802                        CMP      r0,#2
0015d6  da09                        BGE      F30L97
                            F30L96
0015d8  228f                        MOV      r2,#&8f
0015da  0092                        LSL      r2,#2
0015dc  4342                        MUL      r2,r0
0015de  1852                        ADD      r2,r1
0015e0  32ff                        ADD      r2,#&ff
0015e2  32ff                        ADD      r2,#&ff
0015e4  3202                        ADD      r2,#2
0015e6  6b12                        LDR      r2,[r2,#&30]
0015e8  2a01                        CMP      r2,#1
0015ea  d0f2                        BEQ      F30L13
                            F30L97
;;;2335   	
;;;2336   	if (fileNum == MAX_FILES_OPEN) // No free files
0015ec  2802                        CMP      r0,#2
0015ee  d0e1                        BEQ      F30L5
;;;2337   	{
;;;2338   		return NULL;
;;;2339   	}
;;;2340   
;;;2341   	file = &openFiles[fileNum];
0015f0  238f                        MOV      r3,#&8f
0015f2  009b                        LSL      r3,#2
0015f4  4358                        MUL      r0,r3
;;;2342   	// Remember where directory entry was
;;;2343   	file->dirEntSector = (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector;
0015f6  4ee5                        LDR      r6,F30L1+20
0015f8  1847                        ADD      r7,r0,r1   ;;;2341
0015fa  6870                        LDR      r0,[r6,#4]
0015fc  6bf1                        LDR      r1,[r6,#&3c]
0015fe  2900                        CMP      r1,#0
001600  d004                        BEQ      F30L98
001602  1e88                        SUB      r0,r1,#2
001604  6a31                        LDR      r1,[r6,#&20]
001606  4348                        MUL      r0,r1
001608  69b1                        LDR      r1,[r6,#&18]
00160a  1840                        ADD      r0,r1
                            F30L98
00160c  4edf                        LDR      r6,F30L1+20
00160e  1dfc                        ADD      r4,r7,#7
001610  6c31                        LDR      r1,[r6,#&40]
001612  34ff                        ADD      r4,#&ff
001614  1840                        ADD      r0,r1
001616  34fa                        ADD      r4,#&fa
;;;2344   	file->dirEntOffset = wrkDirOffset;
001618  6360                        STR      r0,[r4,#&34]
00161a  6c70                        LDR      r0,[r6,#&44]
;;;2345   
;;;2346   	if ( strpbrk(mode, "rR") != NULL )  //(ucase(mode[0]) == 'R')
00161c  a1dc                        ADR      r1,F30L1+24
00161e  63a0                        STR      r0,[r4,#&38]
001620  9810                        LDR      r0,[sp,#&40]
001622  f7fe fced                   BL       strpbrk
001626  a90d                        ADD      r1,sp,#&34
001628  910e                        STR      r1,[sp,#&38]
00162a  2800                        CMP      r0,#0
00162c  d055                        BEQ      F30L99
;;;2347   	{
;;;2348   		if (dirEntry.name[0] == FILE_FREE)	// File must exist
00162e  a806                        ADD      r0,sp,#&18
001630  7800                        LDRB     r0,[r0,#0]
001632  28e5                        CMP      r0,#&e5
001634  d0be                        BEQ      F30L5
;;;2349   		{
;;;2350   			return NULL;
;;;2351   		}
;;;2352   		
;;;2353   		file->read = true;
001636  2501                        MOV      r5,#1
;;;2354   		file->write = ( strchr(mode, '+') != NULL ); //(mode[1] == '+');
001638  6265                        STR      r5,[r4,#&24]
00163a  212b                        MOV      r1,#&2b
00163c  1c2e                        MOV      r6,r5
00163e  9810                        LDR      r0,[sp,#&40]
001640  f7fe fcde                   BL       strchr
001644  2800                        CMP      r0,#0
001646  d100                        BNE      F30L100
001648  2600                        MOV      r6,#0
                            F30L100
;;;2355   		file->append = false;
00164a  62a6                        STR      r6,[r4,#&28]
00164c  2600                        MOV      r6,#0
;;;2356   		
;;;2357   		// Store information about position within the file, for use
;;;2358   		// by FAT_fread, FAT_fseek, etc.
;;;2359   		file->firstCluster = dirEntry.startCluster | (dirEntry.startClusterHigh << 16);
00164e  62e6                        STR      r6,[r4,#&2c]
001650  a90b                        ADD      r1,sp,#&2c
001652  8809                        LDRH     r1,[r1,#0]
001654  a80c                        ADD      r0,sp,#&30
001656  8840                        LDRH     r0,[r0,#2]
001658  0409                        LSL      r1,#16
00165a  4308                        ORR      r0,r1
;;;2360   	
;;;2361   		// Check if file is openned for random. If it is, and currently has no cluster, one must be 
;;;2362   		// assigned to it.
;;;2363   		if (file->write && file->firstCluster == CLUSTER_FREE)
00165c  6038                        STR      r0,[r7,#0]
00165e  6aa1                        LDR      r1,[r4,#&28]
001660  2900                        CMP      r1,#0
001662  d01f                        BEQ      F30L101
001664  2800                        CMP      r0,#0
001666  d11d                        BNE      F30L102
;;;2364   		{
;;;2365   			file->firstCluster = FAT_LinkFreeCluster (CLUSTER_FREE);
001668  f7ff f81e                   BL       FAT_LinkFreeCluster
;;;2366   			if (file->firstCluster == CLUSTER_FREE)	// Couldn't get a free cluster
00166c  6038                        STR      r0,[r7,#0]
00166e  2800                        CMP      r0,#0
001670  d101                        BNE      F30L103
;;;2367   			{
;;;2368   				return NULL;
001672  1c30                        MOV      r0,r6
001674  e1a8                        B        F30L94
                            F30L103
;;;2369   			}
;;;2370   
;;;2371   			// Store cluster position into the directory entry
;;;2372   			dirEntry.startCluster = (file->firstCluster & 0xFFFF);
001676  ab0c                        ADD      r3,sp,#&30
001678  8058                        STRH     r0,[r3,#2]
;;;2373   			dirEntry.startClusterHigh = ((file->firstCluster >> 16) & 0xFFFF);
00167a  0c00                        LSR      r0,#16
00167c  3b04                        SUB      r3,#4
00167e  8018                        STRH     r0,[r3,#0]
;;;2374   			disc_ReadSector (file->dirEntSector, globalBuffer);
001680  6b60                        LDR      r0,[r4,#&34]
001682  2101                        MOV      r1,#1
001684  4ac3                        LDR      r2,F30L1+28
001686  f7fe fceb                   BL       MPCF_ReadSectors
;;;2375   			((DIR_ENT*) globalBuffer)[file->dirEntOffset] = dirEntry;
00168a  6ba0                        LDR      r0,[r4,#&38]
00168c  4ac1                        LDR      r2,F30L1+28
00168e  0140                        LSL      r0,#5
001690  1880                        ADD      r0,r2
001692  2220                        MOV      r2,#&20
001694  a906                        ADD      r1,sp,#&18
001696  f7fe fcb3                   BL       memcpy
;;;2376   			disc_WriteSector (file->dirEntSector, globalBuffer);
00169a  6b60                        LDR      r0,[r4,#&34]
00169c  4abd                        LDR      r2,F30L1+28
00169e  2101                        MOV      r1,#1
0016a0  f7fe fd4a                   BL       MPCF_WriteSectors
                            F30L101
                            F30L102
;;;2377   		}
;;;2378   			
;;;2379   		file->length = dirEntry.fileSize;
0016a4  980e                        LDR      r0,[sp,#&38]
0016a6  f7fe fcab                   BL       __16_uread4
;;;2380   		file->curPos = 0;
;;;2381   		file->curClus = dirEntry.startCluster | (dirEntry.startClusterHigh << 16);
0016aa  6078                        STR      r0,[r7,#4]
0016ac  60be                        STR      r6,[r7,#8]
0016ae  a90b                        ADD      r1,sp,#&2c
0016b0  8809                        LDRH     r1,[r1,#0]
0016b2  a80c                        ADD      r0,sp,#&30
0016b4  8840                        LDRH     r0,[r0,#2]
0016b6  0409                        LSL      r1,#16
0016b8  4308                        ORR      r0,r1
;;;2382   		file->curSect = 0;
;;;2383   		file->curByte = 0;
0016ba  60f8                        STR      r0,[r7,#&c]
0016bc  613e                        STR      r6,[r7,#&10]
;;;2384   
;;;2385   		// Not appending
;;;2386   		file->appByte = 0;
0016be  617e                        STR      r6,[r7,#&14]
;;;2387   		file->appClus = 0;
0016c0  6226                        STR      r6,[r4,#&20]
;;;2388   		file->appSect = 0;
0016c2  61a6                        STR      r6,[r4,#&18]
;;;2389   	
;;;2390   		disc_ReadSector( FAT_ClustToSect( file->curClus), file->readBuffer);
0016c4  61e6                        STR      r6,[r4,#&1c]
0016c6  4eb1                        LDR      r6,F30L1+20
0016c8  68f8                        LDR      r0,[r7,#&c]
0016ca  6a31                        LDR      r1,[r6,#&20]
0016cc  3802                        SUB      r0,#2
0016ce  4348                        MUL      r0,r1
0016d0  69b1                        LDR      r1,[r6,#&18]
0016d2  1dfa                        ADD      r2,r7,#7
0016d4  3211                        ADD      r2,#&11
0016d6  1840                        ADD      r0,r1
0016d8  e171                        B        F30L104
                            F30L99
;;;2391   		file->inUse = true;	// We're using this file now
;;;2392   
;;;2393   		return file;
;;;2394   	}	// mode "r"
;;;2395   
;;;2396   	if ( strpbrk(mode, "wW") != NULL ) // (ucase(mode[0]) == 'W')
0016da  9810                        LDR      r0,[sp,#&40]
0016dc  a1ae                        ADR      r1,F30L1+32
0016de  f7fe fc8f                   BL       strpbrk
0016e2  2520                        MOV      r5,#&20
0016e4  2800                        CMP      r0,#0
0016e6  ae09                        ADD      r6,sp,#&24
0016e8  d074                        BEQ      F30L105
;;;2397   	{
;;;2398   		if (dirEntry.name[0] == FILE_FREE)	// Create file if it doesn't exist
0016ea  a806                        ADD      r0,sp,#&18
0016ec  7800                        LDRB     r0,[r0,#0]
0016ee  28e5                        CMP      r0,#&e5
0016f0  d10d                        BNE      F30L106
;;;2399   		{
;;;2400   			dirEntry.attrib = ATTRIB_ARCH;
0016f2  ab08                        ADD      r3,sp,#&20
0016f4  70dd                        STRB     r5,[r3,#3]
;;;2401   			dirEntry.reserved = 0;
0016f6  2000                        MOV      r0,#0
0016f8  7118                        STRB     r0,[r3,#4]
;;;2402   			
;;;2403   			// Time and date set to system time and date
;;;2404   			dirEntry.cTime_ms = 0;
0016fa  ab09                        ADD      r3,sp,#&24
0016fc  7058                        STRB     r0,[r3,#1]
;;;2405   			dirEntry.cTime = 0;//getRTCtoFileTime();
0016fe  8058                        STRH     r0,[r3,#2]
;;;2406   			dirEntry.cDate = 0;//getRTCtoFileDate();
001700  8098                        STRH     r0,[r3,#4]
;;;2407   			dirEntry.aDate = 0;//getRTCtoFileDate();
001702  ab0a                        ADD      r3,sp,#&28
001704  8058                        STRH     r0,[r3,#2]
;;;2408   			dirEntry.mTime = 0;//getRTCtoFileTime();
001706  80d8                        STRH     r0,[r3,#6]
;;;2409   			dirEntry.mDate = 0;//getRTCtoFileDate();
001708  ab0c                        ADD      r3,sp,#&30
00170a  8018                        STRH     r0,[r3,#0]
00170c  e007                        B        F30L107
                            F30L106
;;;2410   		}
;;;2411   		else	// Already a file entry 
;;;2412   		{
;;;2413   			// Free any clusters used
;;;2414   			FAT_ClearLinks (dirEntry.startCluster | (dirEntry.startClusterHigh << 16));
00170e  a80c                        ADD      r0,sp,#&30
001710  8840                        LDRH     r0,[r0,#2]
001712  a90b                        ADD      r1,sp,#&2c
001714  8809                        LDRH     r1,[r1,#0]
001716  0409                        LSL      r1,#16
001718  4308                        ORR      r0,r1
00171a  f7fe fff1                   BL       FAT_ClearLinks
                            F30L107
;;;2415   		}
;;;2416   		
;;;2417   		// Get a cluster to use
;;;2418   		startCluster = FAT_LinkFreeCluster (CLUSTER_FREE);
00171e  2000                        MOV      r0,#0
001720  f7fe ffc2                   BL       FAT_LinkFreeCluster
001724  9005                        STR      r0,[sp,#&14]
;;;2419   		if (startCluster == CLUSTER_FREE)	// Couldn't get a free cluster
001726  2800                        CMP      r0,#0
001728  d100                        BNE      F30L108
                            F30L118
                            F30L110
00172a  e743                        B        F30L5
                            F30L108
;;;2420   		{
;;;2421   			return NULL;
;;;2422   		}
;;;2423   
;;;2424   		// Store cluster position into the directory entry
;;;2425   		dirEntry.startCluster = (startCluster & 0xFFFF);
00172c  9805                        LDR      r0,[sp,#&14]
00172e  ab0c                        ADD      r3,sp,#&30
001730  8058                        STRH     r0,[r3,#2]
;;;2426   		dirEntry.startClusterHigh = ((startCluster >> 16) & 0xFFFF);
001732  9805                        LDR      r0,[sp,#&14]
001734  0c00                        LSR      r0,#16
001736  3b04                        SUB      r3,#4
001738  8018                        STRH     r0,[r3,#0]
;;;2427   
;;;2428   		// The file has no data in it - its over written so should be empty
;;;2429   		dirEntry.fileSize = 0;
00173a  990e                        LDR      r1,[sp,#&38]
00173c  2000                        MOV      r0,#0
00173e  f7fe fc5f                   BL       __16_uwrite4
;;;2430   
;;;2431   		if (dirEntry.name[0] == FILE_FREE)	// No file
001742  a806                        ADD      r0,sp,#&18
001744  7800                        LDRB     r0,[r0,#0]
001746  28e5                        CMP      r0,#&e5
001748  d121                        BNE      F30L109
;;;2432   		{
;;;2433   			// Have to create a new entry
;;;2434   			if(!FAT_AddDirEntry (path, dirEntry))
00174a  4668                        MOV      r0,sp
00174c  2214                        MOV      r2,#&14
00174e  1c31                        MOV      r1,r6
001750  f7fe fc56                   BL       __16_memcpy
001754  980f                        LDR      r0,[sp,#&3c]
001756  ae06                        ADD      r6,sp,#&18
001758  ce62                        LDMIA    r6!,{r1,r5,r6}
00175a  1c2a                        MOV      r2,r5
00175c  1c33                        MOV      r3,r6
00175e  f7ff fbdf                   BL       FAT_AddDirEntry
001762  2800                        CMP      r0,#0
001764  d0e1                        BEQ      F30L110
;;;2435   			{
;;;2436   				return NULL;
;;;2437   			}
;;;2438   			// Get the newly created dirEntry
;;;2439   			dirEntry = FAT_DirEntFromPath (path);
001766  990f                        LDR      r1,[sp,#&3c]
001768  a806                        ADD      r0,sp,#&18
00176a  f7ff faed                   BL       FAT_DirEntFromPath
;;;2440   
;;;2441   			// Remember where directory entry was
;;;2442   			file->dirEntSector = (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector;
00176e  4e87                        LDR      r6,F30L1+20
001770  6bf0                        LDR      r0,[r6,#&3c]
001772  6871                        LDR      r1,[r6,#4]
001774  2800                        CMP      r0,#0
001776  d004                        BEQ      F30L111
001778  6a31                        LDR      r1,[r6,#&20]
00177a  3802                        SUB      r0,#2
00177c  4348                        MUL      r0,r1
00177e  69b1                        LDR      r1,[r6,#&18]
001780  1841                        ADD      r1,r0,r1
                            F30L111
001782  6c30                        LDR      r0,[r6,#&40]
001784  1808                        ADD      r0,r1,r0
;;;2443   			file->dirEntOffset = wrkDirOffset;
001786  6360                        STR      r0,[r4,#&34]
001788  6c70                        LDR      r0,[r6,#&44]
00178a  63a0                        STR      r0,[r4,#&38]
00178c  e011                        B        F30L112
                            F30L109
;;;2444   		}
;;;2445   		else	// Already a file
;;;2446   		{
;;;2447   			// Just modify the old entry
;;;2448   			disc_ReadSector (file->dirEntSector, globalBuffer);
00178e  4d81                        LDR      r5,F30L1+28
001790  2101                        MOV      r1,#1
001792  1c2a                        MOV      r2,r5
001794  6b60                        LDR      r0,[r4,#&34]
001796  f7fe fc63                   BL       MPCF_ReadSectors
;;;2449   			((DIR_ENT*) globalBuffer)[file->dirEntOffset] = dirEntry;
00179a  6ba0                        LDR      r0,[r4,#&38]
00179c  a906                        ADD      r1,sp,#&18
00179e  0140                        LSL      r0,#5
0017a0  1940                        ADD      r0,r5
0017a2  2220                        MOV      r2,#&20
0017a4  f7fe fc2c                   BL       memcpy
;;;2450   			disc_WriteSector (file->dirEntSector, globalBuffer);
0017a8  2101                        MOV      r1,#1
0017aa  1c2a                        MOV      r2,r5
0017ac  6b60                        LDR      r0,[r4,#&34]
0017ae  f7fe fcc3                   BL       MPCF_WriteSectors
                            F30L112
;;;2451   		}
;;;2452   		
;;;2453   
;;;2454   		// Now that file is created, open it
;;;2455   		file->read = ( strchr(mode, '+') != NULL ); //(mode[1] == '+');
0017b2  2501                        MOV      r5,#1
0017b4  212b                        MOV      r1,#&2b
0017b6  1c2e                        MOV      r6,r5
0017b8  9810                        LDR      r0,[sp,#&40]
0017ba  f7fe fc21                   BL       strchr
0017be  2800                        CMP      r0,#0
0017c0  d100                        BNE      F30L113
0017c2  2600                        MOV      r6,#0
                            F30L113
;;;2456   		file->write = true;
;;;2457   		file->append = false;
0017c4  62a5                        STR      r5,[r4,#&28]
0017c6  6266                        STR      r6,[r4,#&24]
0017c8  2000                        MOV      r0,#0
;;;2458   		
;;;2459   		// Store information about position within the file, for use
;;;2460   		// by FAT_fread, FAT_fseek, etc.
;;;2461   		file->firstCluster = startCluster;
0017ca  62e0                        STR      r0,[r4,#&2c]
;;;2462   		file->length = 0;	// Should always have 0 bytes if openning in "w" mode
0017cc  9905                        LDR      r1,[sp,#&14]
0017ce  6039                        STR      r1,[r7,#0]
;;;2463   		file->curPos = 0;
0017d0  6078                        STR      r0,[r7,#4]
0017d2  e000                        B        F30L115
                            F30L105
0017d4  e00f                        B        F30L116
                            F30L115
;;;2464   		file->curClus = startCluster;
0017d6  60b8                        STR      r0,[r7,#8]
0017d8  9905                        LDR      r1,[sp,#&14]
;;;2465   		file->curSect = 0;
;;;2466   		file->curByte = 0;
;;;2467   
;;;2468   		// Not appending
;;;2469   		file->appByte = 0;
;;;2470   		file->appClus = 0;
;;;2471   		file->appSect = 0;
;;;2472   		
;;;2473   		// Empty file, so empty read buffer
;;;2474   		memset (file->readBuffer, 0, BYTE_PER_READ);
0017da  2201                        MOV      r2,#1
0017dc  60f9                        STR      r1,[r7,#&c]   ;;;2465
0017de  6138                        STR      r0,[r7,#&10]   ;;;2469
0017e0  6178                        STR      r0,[r7,#&14]   ;;;2469
0017e2  61a0                        STR      r0,[r4,#&18]
0017e4  61e0                        STR      r0,[r4,#&1c]
0017e6  0252                        LSL      r2,#9
0017e8  6220                        STR      r0,[r4,#&20]
0017ea  1df8                        ADD      r0,r7,#7
0017ec  2100                        MOV      r1,#0
0017ee  3011                        ADD      r0,#&11
0017f0  f7fe fc06                   BL       memset
0017f4  e0e6                        B        F30L117
                            F30L116
;;;2475   		file->inUse = true;	// We're using this file now
;;;2476   
;;;2477   		return file;
;;;2478   	}
;;;2479   
;;;2480   	if ( strpbrk(mode, "aA") != NULL ) // (ucase(mode[0]) == 'A')
0017f6  9810                        LDR      r0,[sp,#&40]
0017f8  a160                        ADR      r1,F30L1+4
0017fa  f7fe fc01                   BL       strpbrk
0017fe  2800                        CMP      r0,#0
001800  d093                        BEQ      F30L118
;;;2481   	{
;;;2482   		if (dirEntry.name[0] == FILE_FREE)	// Create file if it doesn't exist
001802  a806                        ADD      r0,sp,#&18
001804  7800                        LDRB     r0,[r0,#0]
001806  28e5                        CMP      r0,#&e5
001808  d141                        BNE      F30L119
;;;2483   		{
;;;2484   			dirEntry.attrib = ATTRIB_ARCH;
00180a  ab08                        ADD      r3,sp,#&20
00180c  70dd                        STRB     r5,[r3,#3]
;;;2485   			dirEntry.reserved = 0;
00180e  2000                        MOV      r0,#0
001810  7118                        STRB     r0,[r3,#4]
;;;2486   			
;;;2487   			// Time and date set to system time and date
;;;2488   			dirEntry.cTime_ms = 0;
001812  ab09                        ADD      r3,sp,#&24
001814  7058                        STRB     r0,[r3,#1]
;;;2489   			dirEntry.cTime = 0;//getRTCtoFileTime();
001816  8058                        STRH     r0,[r3,#2]
;;;2490   			dirEntry.cDate = 0;//getRTCtoFileDate();
001818  8098                        STRH     r0,[r3,#4]
;;;2491   			dirEntry.aDate = 0;//getRTCtoFileDate();
00181a  ab0a                        ADD      r3,sp,#&28
00181c  8058                        STRH     r0,[r3,#2]
;;;2492   			dirEntry.mTime = 0;//getRTCtoFileTime();
00181e  80d8                        STRH     r0,[r3,#6]
;;;2493   			dirEntry.mDate = 0;//getRTCtoFileDate();
001820  ab0c                        ADD      r3,sp,#&30
001822  8018                        STRH     r0,[r3,#0]
;;;2494   
;;;2495   			// The file has no data in it
;;;2496   			dirEntry.fileSize = 0;
001824  990e                        LDR      r1,[sp,#&38]
001826  f7fe fbeb                   BL       __16_uwrite4
;;;2497   
;;;2498   			// Get a cluster to use
;;;2499   			startCluster = FAT_LinkFreeCluster (CLUSTER_FREE);
00182a  2000                        MOV      r0,#0
00182c  f7fe ff3c                   BL       FAT_LinkFreeCluster
001830  9005                        STR      r0,[sp,#&14]
;;;2500   			if (startCluster == CLUSTER_FREE)	// Couldn't get a free cluster
001832  2800                        CMP      r0,#0
001834  d100                        BNE      F30L120
                            F30L125
                            F30L121
001836  e6bd                        B        F30L5
                            F30L120
;;;2501   			{
;;;2502   				return NULL;
;;;2503   			}
;;;2504   			dirEntry.startCluster = (startCluster & 0xFFFF);
001838  9805                        LDR      r0,[sp,#&14]
00183a  ab0c                        ADD      r3,sp,#&30
00183c  8058                        STRH     r0,[r3,#2]
;;;2505   			dirEntry.startClusterHigh = ((startCluster >> 16) & 0xFFFF);
00183e  9805                        LDR      r0,[sp,#&14]
001840  0c00                        LSR      r0,#16
001842  3b04                        SUB      r3,#4
001844  8018                        STRH     r0,[r3,#0]
;;;2506   			
;;;2507   			if(!FAT_AddDirEntry (path, dirEntry))
001846  4668                        MOV      r0,sp
001848  2214                        MOV      r2,#&14
00184a  1c31                        MOV      r1,r6
00184c  f7fe fbd8                   BL       __16_memcpy
001850  980f                        LDR      r0,[sp,#&3c]
001852  ae06                        ADD      r6,sp,#&18
001854  ce62                        LDMIA    r6!,{r1,r5,r6}
001856  1c2a                        MOV      r2,r5
001858  1c33                        MOV      r3,r6
00185a  f7ff fb61                   BL       FAT_AddDirEntry
00185e  2800                        CMP      r0,#0
001860  d0e9                        BEQ      F30L121
;;;2508   				return NULL;
;;;2509   			
;;;2510   			// Get the newly created dirEntry
;;;2511   			dirEntry = FAT_DirEntFromPath (path);
001862  990f                        LDR      r1,[sp,#&3c]
001864  a806                        ADD      r0,sp,#&18
001866  f7ff fa6f                   BL       FAT_DirEntFromPath
;;;2512   			
;;;2513   			// Store append cluster
;;;2514   			file->appClus = startCluster;
00186a  9805                        LDR      r0,[sp,#&14]
;;;2515   
;;;2516   			// Remember where directory entry was
;;;2517   			file->dirEntSector = (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector;
00186c  4e47                        LDR      r6,F30L1+20
00186e  61a0                        STR      r0,[r4,#&18]
001870  6bf0                        LDR      r0,[r6,#&3c]
001872  6871                        LDR      r1,[r6,#4]
001874  2800                        CMP      r0,#0
001876  d004                        BEQ      F30L122
001878  6a31                        LDR      r1,[r6,#&20]
00187a  3802                        SUB      r0,#2
00187c  4348                        MUL      r0,r1
00187e  69b1                        LDR      r1,[r6,#&18]
001880  1841                        ADD      r1,r0,r1
                            F30L122
001882  6c30                        LDR      r0,[r6,#&40]
001884  1808                        ADD      r0,r1,r0
;;;2518   			file->dirEntOffset = wrkDirOffset;
001886  6360                        STR      r0,[r4,#&34]
001888  6c70                        LDR      r0,[r6,#&44]
00188a  63a0                        STR      r0,[r4,#&38]
00188c  e04b                        B        F30L123
                            F30L119
;;;2519   		}
;;;2520   		else	// File already exists - reuse the old directory entry
;;;2521   		{
;;;2522   			startCluster = dirEntry.startCluster | (dirEntry.startClusterHigh << 16);
00188e  a80c                        ADD      r0,sp,#&30
001890  8840                        LDRH     r0,[r0,#2]
001892  a90b                        ADD      r1,sp,#&2c
001894  8809                        LDRH     r1,[r1,#0]
001896  0409                        LSL      r1,#16
001898  4308                        ORR      r0,r1
00189a  9005                        STR      r0,[sp,#&14]
;;;2523   			// If it currently has no cluster, one must be assigned to it.
;;;2524   			if (startCluster == CLUSTER_FREE)
00189c  d11e                        BNE      F30L124
;;;2525   			{
;;;2526   				file->firstCluster = FAT_LinkFreeCluster (CLUSTER_FREE);
00189e  f7fe ff03                   BL       FAT_LinkFreeCluster
;;;2527   				if (file->firstCluster == CLUSTER_FREE)	// Couldn't get a free cluster
0018a2  6038                        STR      r0,[r7,#0]
0018a4  2800                        CMP      r0,#0
0018a6  d0c6                        BEQ      F30L125
;;;2528   				{
;;;2529   					return NULL;
;;;2530   				}
;;;2531   				
;;;2532   				// Store cluster position into the directory entry
;;;2533   				dirEntry.startCluster = (file->firstCluster & 0xFFFF);
0018a8  ab0c                        ADD      r3,sp,#&30
0018aa  8058                        STRH     r0,[r3,#2]
;;;2534   				dirEntry.startClusterHigh = ((file->firstCluster >> 16) & 0xFFFF);
0018ac  0c00                        LSR      r0,#16
0018ae  3b04                        SUB      r3,#4
;;;2535   				disc_ReadSector (file->dirEntSector, globalBuffer);
0018b0  4d38                        LDR      r5,F30L1+28
0018b2  8018                        STRH     r0,[r3,#0]   ;;;2534
0018b4  2101                        MOV      r1,#1
0018b6  1c2a                        MOV      r2,r5
0018b8  6b60                        LDR      r0,[r4,#&34]
0018ba  f7fe fbd1                   BL       MPCF_ReadSectors
;;;2536   				((DIR_ENT*) globalBuffer)[file->dirEntOffset] = dirEntry;
0018be  6ba0                        LDR      r0,[r4,#&38]
0018c0  a906                        ADD      r1,sp,#&18
0018c2  0140                        LSL      r0,#5
0018c4  1940                        ADD      r0,r5
0018c6  2220                        MOV      r2,#&20
0018c8  f7fe fb9a                   BL       memcpy
;;;2537   				disc_WriteSector (file->dirEntSector, globalBuffer);
0018cc  2101                        MOV      r1,#1
0018ce  1c2a                        MOV      r2,r5
0018d0  6b60                        LDR      r0,[r4,#&34]
0018d2  f7fe fc31                   BL       MPCF_WriteSectors
;;;2538   
;;;2539   				// Store append cluster
;;;2540   				file->appClus = startCluster;
0018d6  9805                        LDR      r0,[sp,#&14]
0018d8  61a0                        STR      r0,[r4,#&18]
0018da  e024                        B        F30L123
                            F30L124
;;;2541   		
;;;2542   			} else {
;;;2543   
;;;2544   				// Follow cluster list until last one is found
;;;2545   				clusCount = dirEntry.fileSize / filesysBytePerClus;
0018dc  980e                        LDR      r0,[sp,#&38]
0018de  f7fe fb8f                   BL       __16_uread4
0018e2  4e2a                        LDR      r6,F30L1+20
0018e4  1c01                        MOV      r1,r0
0018e6  6a72                        LDR      r2,[r6,#&24]
0018e8  1c10                        MOV      r0,r2
0018ea  f7fe fb89                   BL       __16__rt_udiv
;;;2546   				file->appClus = startCluster;
0018ee  1c05                        MOV      r5,r0
0018f0  9805                        LDR      r0,[sp,#&14]
0018f2  e002                        B        F30L126
                            F30L70
;;;2547   				while ((clusCount--) && (FAT_NextCluster (file->appClus) != CLUSTER_FREE) && (FAT_NextCluster (file->appClus) != CLUSTER_EOF))
;;;2548   				{
;;;2549   					file->appClus = FAT_NextCluster (file->appClus);
0018f4  69a0                        LDR      r0,[r4,#&18]
0018f6  f7fe fca1                   BL       FAT_NextCluster
                            F30L126
0018fa  61a0                        STR      r0,[r4,#&18]   ;;;2547
0018fc  1c28                        MOV      r0,r5   ;;;2547
0018fe  3d01                        SUB      r5,#1   ;;;2547
001900  2800                        CMP      r0,#0   ;;;2547
001902  d00a                        BEQ      F30L127   ;;;2547
001904  69a0                        LDR      r0,[r4,#&18]   ;;;2547
001906  f7fe fc99                   BL       FAT_NextCluster   ;;;2547
00190a  2800                        CMP      r0,#0   ;;;2547
00190c  d005                        BEQ      F30L128   ;;;2547
00190e  69a0                        LDR      r0,[r4,#&18]   ;;;2547
001910  f7fe fc94                   BL       FAT_NextCluster   ;;;2547
001914  4b21                        LDR      r3,F30L1+36   ;;;2547
001916  4298                        CMP      r0,r3   ;;;2547
001918  d1ec                        BNE      F30L70   ;;;2547
                            F30L127
                            F30L128
;;;2550   				}
;;;2551   				if (clusCount >= 0) // Check if ran out of clusters
00191a  2d00                        CMP      r5,#0
00191c  db03                        BLT      F30L123
;;;2552   				{
;;;2553   					// Set flag to allocate new cluster when needed
;;;2554   					file->appSect = filesysSecPerClus;
00191e  6a30                        LDR      r0,[r6,#&20]
;;;2555   					file->appByte = 0;
001920  61e0                        STR      r0,[r4,#&1c]
001922  2000                        MOV      r0,#0
001924  6220                        STR      r0,[r4,#&20]
                            F30L123
;;;2556   				}
;;;2557   			}
;;;2558   		}
;;;2559   
;;;2560   		// Now that file is created, open it
;;;2561   		file->read = ( strchr(mode, '+') != NULL );
001926  2501                        MOV      r5,#1
001928  212b                        MOV      r1,#&2b
00192a  1c2e                        MOV      r6,r5
00192c  9810                        LDR      r0,[sp,#&40]
00192e  f7fe fb67                   BL       strchr
001932  2800                        CMP      r0,#0
001934  d100                        BNE      F30L129
001936  2600                        MOV      r6,#0
                            F30L129
;;;2562   		file->write = false;
001938  2000                        MOV      r0,#0
00193a  6266                        STR      r6,[r4,#&24]
;;;2563   		file->append = true;
00193c  62a0                        STR      r0,[r4,#&28]
;;;2564   		
;;;2565   		// Calculate the sector and byte of the current position,
;;;2566   		// and store them
;;;2567   		file->appSect = (dirEntry.fileSize % filesysBytePerClus) / BYTE_PER_READ;
00193e  62e5                        STR      r5,[r4,#&2c]
001940  980e                        LDR      r0,[sp,#&38]
001942  f7fe fb5d                   BL       __16_uread4
001946  4e11                        LDR      r6,F30L1+20
001948  1c01                        MOV      r1,r0
00194a  6a72                        LDR      r2,[r6,#&24]
00194c  1c10                        MOV      r0,r2
00194e  f7fe fb57                   BL       __16__rt_udiv
001952  0a48                        LSR      r0,r1,#9
;;;2568   		file->appByte = dirEntry.fileSize % BYTE_PER_READ;
001954  61e0                        STR      r0,[r4,#&1c]
001956  980e                        LDR      r0,[sp,#&38]
001958  f7fe fb52                   BL       __16_uread4
00195c  05c0                        LSL      r0,#23
00195e  0dc0                        LSR      r0,#23
;;;2569   
;;;2570   		// Store information about position within the file, for use
;;;2571   		// by FAT_fread, FAT_fseek, etc.
;;;2572   		file->firstCluster = startCluster;
001960  6220                        STR      r0,[r4,#&20]
;;;2573   		file->length = dirEntry.fileSize;
001962  9805                        LDR      r0,[sp,#&14]
001964  6038                        STR      r0,[r7,#0]
001966  980e                        LDR      r0,[sp,#&38]
001968  f7fe fb4a                   BL       __16_uread4
;;;2574   		file->curPos = dirEntry.fileSize;
00196c  6078                        STR      r0,[r7,#4]
00196e  980e                        LDR      r0,[sp,#&38]
001970  f7fe fb46                   BL       __16_uread4
001974  e014                        B        F30L131
001976  0000                        LSL      r0,#0
                            F30L1
001978  57775272                    DCB      DCB      "rRwW"
00197c  00004161                    DCB      DCB      "aA\0\0"
001980  41615777                    DCB      DCB      "wWaA"
001984  0000002b                    DCB      DCB      "+\0\0\0"
001988  00000000                    DCD      openFiles
00198c  00000000                    DCD      |x$dataseg|
001990  00005272                    DCB      DCB      "rR\0\0"
001994  00000000                    DCD      globalBuffer
001998  00005777                    DCB      DCB      "wW\0\0"
00199c  0fffffff                    DCD      0x0fffffff
                            F30L131
;;;2575   		file->curClus = file->appClus;
0019a0  60b8                        STR      r0,[r7,#8]
0019a2  69a1                        LDR      r1,[r4,#&18]
;;;2576   		file->curSect = file->appSect;
0019a4  60f9                        STR      r1,[r7,#&c]
0019a6  69e0                        LDR      r0,[r4,#&1c]
;;;2577   		file->curByte = file->appByte;
;;;2578   		
;;;2579   		// Read into buffer
;;;2580   		disc_ReadSector( FAT_ClustToSect(file->curClus) + file->curSect, file->readBuffer);
0019a8  3902                        SUB      r1,#2
0019aa  6138                        STR      r0,[r7,#&10]   ;;;2577
0019ac  6a22                        LDR      r2,[r4,#&20]   ;;;2577
0019ae  617a                        STR      r2,[r7,#&14]
0019b0  6a32                        LDR      r2,[r6,#&20]
0019b2  4351                        MUL      r1,r2
0019b4  69b2                        LDR      r2,[r6,#&18]
0019b6  1889                        ADD      r1,r2
0019b8  1808                        ADD      r0,r1,r0
0019ba  1dfa                        ADD      r2,r7,#7
0019bc  3211                        ADD      r2,#&11
                            F30L104
0019be  2101                        MOV      r1,#1
0019c0  f7fe fb4e                   BL       MPCF_ReadSectors
                            F30L117
0019c4  6325                        STR      r5,[r4,#&30]   ;;;2393
0019c6  1c38                        MOV      r0,r7   ;;;2393
                            F30L94
0019c8  b011                        ADD      sp,#&44   ;;;2393
0019ca  bcf0                        POP      {r4-r7}   ;;;2393
0019cc  bc08                        POP      {r3}   ;;;2393
0019ce  4718                        BX       r3   ;;;2393

;;;2581   		file->inUse = true;	// We're using this file now
;;;2582   		return file;
;;;2583   	}
;;;2584   
;;;2585   	// Can only reach here if a bad mode was specified
;;;2586   	return NULL;
;;;2587   }
;;;2588   
;;;2589   /*-----------------------------------------------------------------
;;;2590   FAT_fclose(file)
;;;2591   Closes a file
;;;2592   FAT_FILE* file: IN handle of the file to close
;;;2593   bool return OUT: true if successful, false if not
;;;2594   -----------------------------------------------------------------*/
;;;2595   bool FAT_fclose (FAT_FILE* file)
;;;2596   {
0019d0                      FAT_fclose
0019d0  b5f0                        PUSH     {r4-r7,lr}
0019d2  2600                        MOV      r6,#0
;;;2597   	// Clear memory used by file information
;;;2598   	if ((file != NULL) && (file->inUse == true))
0019d4  1c07                        MOV      r7,r0
0019d6  2800                        CMP      r0,#0
0019d8  d034                        BEQ      F31L16
0019da  1dfc                        ADD      r4,r7,#7
0019dc  34ff                        ADD      r4,#&ff
0019de  34fa                        ADD      r4,#&fa
0019e0  6b20                        LDR      r0,[r4,#&30]
0019e2  2801                        CMP      r0,#1
0019e4  d12e                        BNE      F31L17
;;;2599   	{
;;;2600   		if (file->write || file->append)
0019e6  6aa0                        LDR      r0,[r4,#&28]
0019e8  2800                        CMP      r0,#0
0019ea  d102                        BNE      F31L18
0019ec  6ae0                        LDR      r0,[r4,#&2c]
0019ee  2800                        CMP      r0,#0
0019f0  d023                        BEQ      F31L19
                            F31L18
;;;2601   		{
;;;2602   			// Write new length, time and date back to directory entry
;;;2603   			disc_ReadSector (file->dirEntSector, globalBuffer);
0019f2  4d15                        LDR      r5,F31L1
0019f4  2101                        MOV      r1,#1
0019f6  1c2a                        MOV      r2,r5
0019f8  6b60                        LDR      r0,[r4,#&34]
0019fa  f7fe fb31                   BL       MPCF_ReadSectors
;;;2604   
;;;2605   			((DIR_ENT*)globalBuffer)[file->dirEntOffset].fileSize = file->length;
0019fe  6878                        LDR      r0,[r7,#4]
001a00  6ba1                        LDR      r1,[r4,#&38]
001a02  0149                        LSL      r1,#5
001a04  1949                        ADD      r1,r5
001a06  311c                        ADD      r1,#&1c
001a08  f7fe fafa                   BL       __16_uwrite4
;;;2606   			((DIR_ENT*)globalBuffer)[file->dirEntOffset].mTime = 0;//getRTCtoFileTime();
001a0c  6ba0                        LDR      r0,[r4,#&38]
001a0e  0140                        LSL      r0,#5
001a10  1940                        ADD      r0,r5
001a12  7586                        STRB     r6,[r0,#&16]
001a14  0a33                        LSR      r3,r6,#8
001a16  75c3                        STRB     r3,[r0,#&17]
;;;2607   			((DIR_ENT*)globalBuffer)[file->dirEntOffset].mDate = 0;//getRTCtoFileDate();
001a18  6ba0                        LDR      r0,[r4,#&38]
001a1a  0140                        LSL      r0,#5
001a1c  1940                        ADD      r0,r5
001a1e  7606                        STRB     r6,[r0,#&18]
001a20  0a33                        LSR      r3,r6,#8
001a22  7643                        STRB     r3,[r0,#&19]
;;;2608   			((DIR_ENT*)globalBuffer)[file->dirEntOffset].aDate = 0;//getRTCtoFileDate();
001a24  6ba0                        LDR      r0,[r4,#&38]
001a26  0140                        LSL      r0,#5
001a28  1940                        ADD      r0,r5
001a2a  0a33                        LSR      r3,r6,#8
001a2c  7486                        STRB     r6,[r0,#&12]
001a2e  74c3                        STRB     r3,[r0,#&13]
;;;2609   
;;;2610   			disc_WriteSector (file->dirEntSector, globalBuffer);
001a30  2101                        MOV      r1,#1
001a32  1c2a                        MOV      r2,r5
001a34  6b60                        LDR      r0,[r4,#&34]
001a36  f7fe fb7f                   BL       MPCF_WriteSectors
                            F31L19
;;;2611   		}
;;;2612   		file->inUse = false;		
;;;2613   		return true;
001a3a  2001                        MOV      r0,#1
001a3c  6326                        STR      r6,[r4,#&30]
                            F31L14
001a3e  bcf0                        POP      {r4-r7}
001a40  bc08                        POP      {r3}
001a42  4718                        BX       r3
                            F31L16
                            F31L17
;;;2614   	}
;;;2615   	else
;;;2616   	{
;;;2617   		return false;
001a44  1c30                        MOV      r0,r6
001a46  e7fa                        B        F31L14
                            F31L1
001a48  00000000                    DCD      globalBuffer

;;;2618   	}
;;;2619   }
;;;2620   
;;;2621   /*-----------------------------------------------------------------
;;;2622   FAT_ftell(file)
;;;2623   Returns the current position in a file
;;;2624   FAT_FILE* file: IN handle of an open file
;;;2625   u32 OUT: Current position
;;;2626   -----------------------------------------------------------------*/
;;;2627   u32 FAT_ftell (FAT_FILE* file)
;;;2628   {
;;;2629   	// Return the position as specified in the FAT_FILE structure
;;;2630   	if ((file != NULL) && (file->inUse == true))
001a4c                      FAT_ftell
001a4c  2800                        CMP      r0,#0
001a4e  d007                        BEQ      F32L12
001a50  1dc1                        ADD      r1,r0,#7
001a52  31ff                        ADD      r1,#&ff
001a54  31fa                        ADD      r1,#&fa
001a56  6b09                        LDR      r1,[r1,#&30]
001a58  2901                        CMP      r1,#1
001a5a  d101                        BNE      F32L13
;;;2631   	{
;;;2632   		return file->curPos;
001a5c  6880                        LDR      r0,[r0,#8]
001a5e  4770                        BX       lr
                            F32L12
                            F32L13
;;;2633   	}
;;;2634   	else
;;;2635   	{
;;;2636   		// Return -1 if no file was given
;;;2637   		return -1;
001a60  2000                        MOV      r0,#0
001a62  43c0                        MVN      r0,r0
001a64  4770                        BX       lr

;;;2638   	}
;;;2639   }
;;;2640   
;;;2641   /*-----------------------------------------------------------------
;;;2642   FAT_fseek(file, offset, origin)
;;;2643   Seeks to specified byte position in file
;;;2644   FAT_FILE* file: IN handle of an open file
;;;2645   s32 offset IN: position to seek to, relative to origin
;;;2646   int origin IN: origin to seek from
;;;2647   int OUT: Returns 0 if successful, -1 if not
;;;2648   -----------------------------------------------------------------*/
;;;2649   int FAT_fseek(FAT_FILE* file, s32 offset, int origin)
;;;2650   {
001a66                      FAT_fseek
001a66  b5fc                        PUSH     {r2-r7,lr}
001a68  2300                        MOV      r3,#0
001a6a  43db                        MVN      r3,r3
;;;2651   	u32 cluster, nextCluster;
;;;2652   	int clusCount;
;;;2653   	u32 position;
;;;2654   	u32 curPos;
;;;2655   
;;;2656   	if ((file == NULL) || (file->inUse == false))	// invalid file
001a6c  1c07                        MOV      r7,r0
001a6e  2800                        CMP      r0,#0
001a70  d006                        BEQ      F33L61
001a72  1df8                        ADD      r0,r7,#7
001a74  30ff                        ADD      r0,#&ff
001a76  30fa                        ADD      r0,#&fa
001a78  9001                        STR      r0,[sp,#4]
001a7a  6b00                        LDR      r0,[r0,#&30]
001a7c  2800                        CMP      r0,#0
001a7e  d101                        BNE      F33L62
                            F33L61
                            F33L5
;;;2657   	{
;;;2658   		return -1;
001a80  1c18                        MOV      r0,r3
001a82  e087                        B        F33L63
                            F33L62
;;;2659   	}
;;;2660   
;;;2661   	// Can't seek in append only mode
;;;2662   	if (!file->read && !file->write)	
001a84  9801                        LDR      r0,[sp,#4]
001a86  6a40                        LDR      r0,[r0,#&24]
001a88  2800                        CMP      r0,#0
001a8a  d103                        BNE      F33L64
001a8c  9801                        LDR      r0,[sp,#4]
001a8e  6a80                        LDR      r0,[r0,#&28]
001a90  2800                        CMP      r0,#0
001a92  d0f5                        BEQ      F33L5
                            F33L64
;;;2663   	{
;;;2664   		return -1;
;;;2665   	}
;;;2666   
;;;2667   	curPos = file->curPos;
001a94  68b8                        LDR      r0,[r7,#8]
;;;2668   
;;;2669   	switch (origin) 
001a96  2a00                        CMP      r2,#0
001a98  9000                        STR      r0,[sp,#0]   ;;;2667
001a9a  d008                        BEQ      F33L65
001a9c  4248                        NEG      r0,r1
001a9e  2a01                        CMP      r2,#1
001aa0  d009                        BEQ      F33L66
001aa2  2a02                        CMP      r2,#2
001aa4  d1ec                        BNE      F33L5
;;;2670   	{
;;;2671   	case SEEK_SET:
;;;2672   		if (offset >= 0)
;;;2673   		{
;;;2674   			position = offset;
;;;2675   		} else {
;;;2676   			// Tried to seek before start of file
;;;2677   			position = 0;
;;;2678   		}
;;;2679   		break;
;;;2680   	case SEEK_CUR:
;;;2681   		if (offset >= 0)
;;;2682   		{
;;;2683   			position = curPos + offset;
;;;2684   		} 
;;;2685   		else if ( (u32)(offset * -1) >= curPos )
;;;2686   		{
;;;2687   			// Tried to seek before start of file
;;;2688   			position = 0;
;;;2689   		}
;;;2690   		else 
;;;2691   		{
;;;2692   			// Using u32 to maintain 32 bits of accuracy
;;;2693   			position = curPos - (u32)(offset * -1);
;;;2694   		}
;;;2695   		break;
;;;2696   	case SEEK_END:
;;;2697   		if (offset >= 0)
001aa6  2900                        CMP      r1,#0
001aa8  db0f                        BLT      F33L67
;;;2698   		{
;;;2699   			// Seeking to end of file
;;;2700   			position = file->length;	// Fixed thanks to MoonLight
001aaa  687d                        LDR      r5,[r7,#4]
001aac  e013                        B        F33L68
                            F33L65
001aae  2900                        CMP      r1,#0   ;;;2672
001ab0  db0e                        BLT      F33L69   ;;;2672
001ab2  1c0d                        MOV      r5,r1   ;;;2674
001ab4  e00f                        B        F33L68   ;;;2674
                            F33L66
001ab6  2900                        CMP      r1,#0   ;;;2681
001ab8  db02                        BLT      F33L70   ;;;2681
001aba  9800                        LDR      r0,[sp,#0]   ;;;2683
001abc  1845                        ADD      r5,r0,r1   ;;;2683
001abe  e00a                        B        F33L68   ;;;2683
                            F33L70
001ac0  9900                        LDR      r1,[sp,#0]   ;;;2685
001ac2  4288                        CMP      r0,r1   ;;;2685
001ac4  d204                        BCS      F33L71   ;;;2685
001ac6  9900                        LDR      r1,[sp,#0]   ;;;2693
001ac8  e004                        B        F33L72   ;;;2693
                            F33L67
;;;2701   		}
;;;2702   		else if ( (u32)(offset * -1) >= file->length )
001aca  6879                        LDR      r1,[r7,#4]
001acc  4281                        CMP      r1,r0
001ace  d801                        BHI      F33L72
                            F33L69
                            F33L71
;;;2703   		{
;;;2704   			// Tried to seek before start of file
;;;2705   			position = 0;
001ad0  2500                        MOV      r5,#0
001ad2  e000                        B        F33L68
                            F33L72
;;;2706   		}
;;;2707   		else 
;;;2708   		{
;;;2709   			// Using u32 to maintain 32 bits of accuracy
;;;2710   			position = file->length - (u32)(offset * -1);
001ad4  1a0d                        SUB      r5,r1,r0
                            F33L68
;;;2711   		}
;;;2712   		break;
;;;2713   	default:
;;;2714   		return -1;
;;;2715   	}
;;;2716   
;;;2717   	if (position > file->length)
001ad6  6878                        LDR      r0,[r7,#4]
001ad8  42a8                        CMP      r0,r5
001ada  d200                        BCS      F33L73
;;;2718   	{
;;;2719   		// Tried to go past end of file
;;;2720   		position = file->length;
001adc  1c05                        MOV      r5,r0
                            F33L73
;;;2721   	}
;;;2722   	
;;;2723   	// Save position
;;;2724   	file->curPos = position;
;;;2725   
;;;2726   
;;;2727   	// Calculate where the correct cluster is
;;;2728   	if (position > curPos)
001ade  60bd                        STR      r5,[r7,#8]
001ae0  9800                        LDR      r0,[sp,#0]
001ae2  4285                        CMP      r5,r0
001ae4  d90e                        BLS      F33L74
;;;2729   	{
;;;2730   		clusCount = (position - curPos + (file->curSect * filesysBytePerSec) + file->curByte) / filesysBytePerClus;	// Fixed thanks to AgentQ
001ae6  9800                        LDR      r0,[sp,#0]
001ae8  4a2c                        LDR      r2,F33L1
001aea  1a29                        SUB      r1,r5,r0
001aec  6938                        LDR      r0,[r7,#&10]
001aee  69d3                        LDR      r3,[r2,#&1c]
001af0  4358                        MUL      r0,r3
001af2  1808                        ADD      r0,r1,r0
001af4  6979                        LDR      r1,[r7,#&14]
001af6  1841                        ADD      r1,r0,r1
001af8  6a50                        LDR      r0,[r2,#&24]
001afa  f7fe fa81                   BL       __16__rt_udiv
;;;2731   		cluster = file->curClus;
001afe  68fe                        LDR      r6,[r7,#&c]
001b00  1c04                        MOV      r4,r0
001b02  e006                        B        F33L75
                            F33L74
;;;2732   	} else {
;;;2733   		clusCount = position / filesysBytePerClus;
001b04  4a25                        LDR      r2,F33L1
001b06  1c29                        MOV      r1,r5
001b08  6a50                        LDR      r0,[r2,#&24]
001b0a  f7fe fa79                   BL       __16__rt_udiv
;;;2734   		cluster = file->firstCluster;
001b0e  683e                        LDR      r6,[r7,#0]
001b10  1c04                        MOV      r4,r0
                            F33L75
;;;2735   	}
;;;2736   
;;;2737   	// Calculate the sector and byte of the current position,
;;;2738   	// and store them
;;;2739   	file->curSect = (position % filesysBytePerClus) / BYTE_PER_READ;
001b12  4822                        LDR      r0,F33L1
001b14  1c29                        MOV      r1,r5
001b16  6a40                        LDR      r0,[r0,#&24]
001b18  f7fe fa72                   BL       __16__rt_udiv
001b1c  0a48                        LSR      r0,r1,#9
;;;2740   	file->curByte = position % BYTE_PER_READ;
001b1e  6138                        STR      r0,[r7,#&10]
001b20  05e8                        LSL      r0,r5,#23
001b22  0dc0                        LSR      r0,#23
;;;2741   
;;;2742   	// Follow cluster list until desired one is found
;;;2743   	if (clusCount > 0)	// Only look at next cluster if need to
001b24  6178                        STR      r0,[r7,#&14]
001b26  2c00                        CMP      r4,#0
001b28  dd03                        BLE      F33L76
                            F33L40
;;;2744   	{
;;;2745   		nextCluster = FAT_NextCluster (cluster);
001b2a  1c30                        MOV      r0,r6
001b2c  f7fe fb86                   BL       FAT_NextCluster
001b30  e000                        B        F33L77
                            F33L76
;;;2746   	} else {
;;;2747   		nextCluster = cluster;
001b32  1c30                        MOV      r0,r6
                            F33L77
;;;2748   	}
;;;2749   	while ((clusCount--) && (nextCluster != CLUSTER_FREE) && (nextCluster != CLUSTER_EOF))
001b34  1c21                        MOV      r1,r4
001b36  3c01                        SUB      r4,#1
001b38  2900                        CMP      r1,#0
001b3a  d006                        BEQ      F33L78
001b3c  2800                        CMP      r0,#0
001b3e  d004                        BEQ      F33L79
001b40  4b17                        LDR      r3,F33L1+4
001b42  4298                        CMP      r0,r3
001b44  d001                        BEQ      F33L79
;;;2750   	{
;;;2751   		cluster = nextCluster;
001b46  1c06                        MOV      r6,r0
001b48  e7ef                        B        F33L40
                            F33L78
                            F33L79
;;;2752   		nextCluster = FAT_NextCluster (cluster);
;;;2753   	}
;;;2754   	// Check if ran out of clusters, and the file is being written to
;;;2755   	if ((clusCount >= 0) && (file->write || file->append)) 
001b4a  1c20                        MOV      r0,r4
001b4c  2400                        MOV      r4,#0
001b4e  2800                        CMP      r0,#0
001b50  db0b                        BLT      F33L80
001b52  9801                        LDR      r0,[sp,#4]
001b54  6a80                        LDR      r0,[r0,#&28]
001b56  2800                        CMP      r0,#0
001b58  d103                        BNE      F33L81
001b5a  9801                        LDR      r0,[sp,#4]
001b5c  6ac0                        LDR      r0,[r0,#&2c]
001b5e  2800                        CMP      r0,#0
001b60  d003                        BEQ      F33L82
                            F33L81
;;;2756   	{
;;;2757   		// Set flag to allocate a new cluster
;;;2758   		file->curSect = filesysSecPerClus;
001b62  480e                        LDR      r0,F33L1
001b64  6a00                        LDR      r0,[r0,#&20]
;;;2759   		file->curByte = 0;
001b66  6138                        STR      r0,[r7,#&10]
001b68  617c                        STR      r4,[r7,#&14]
                            F33L80
                            F33L82
;;;2760   	}
;;;2761   	file->curClus = cluster;
;;;2762   	
;;;2763   	// Reload sector buffer for new position in file, if it is a different sector
;;;2764   	if ((curPos ^ position) >= BYTE_PER_READ)
001b6a  60fe                        STR      r6,[r7,#&c]
001b6c  9800                        LDR      r0,[sp,#0]
001b6e  4068                        EOR      r0,r5
001b70  2301                        MOV      r3,#1
001b72  025b                        LSL      r3,#9
001b74  4298                        CMP      r0,r3
001b76  d30c                        BCC      F33L83
;;;2765   	{
;;;2766   		disc_ReadSector( file->curSect + FAT_ClustToSect(file->curClus), file->readBuffer);
001b78  4a08                        LDR      r2,F33L1
001b7a  1eb1                        SUB      r1,r6,#2
001b7c  6a13                        LDR      r3,[r2,#&20]
001b7e  6938                        LDR      r0,[r7,#&10]
001b80  4359                        MUL      r1,r3
001b82  6992                        LDR      r2,[r2,#&18]
001b84  1889                        ADD      r1,r2
001b86  1840                        ADD      r0,r1
001b88  2101                        MOV      r1,#1
001b8a  1dfa                        ADD      r2,r7,#7
001b8c  3211                        ADD      r2,#&11
001b8e  f7fe fa67                   BL       MPCF_ReadSectors
                            F33L83
;;;2767   	}
;;;2768   
;;;2769   	return 0;
001b92  1c20                        MOV      r0,r4
                            F33L63
001b94  bcfc                        POP      {r2-r7}
001b96  bc08                        POP      {r3}
001b98  4718                        BX       r3
001b9a  0000                        LSL      r0,#0
                            F33L1
001b9c  00000000                    DCD      |x$dataseg|
001ba0  0fffffff                    DCD      0x0fffffff

;;;2770   }
;;;2771   
;;;2772   /*-----------------------------------------------------------------
;;;2773   FAT_fread(buffer, size, count, file)
;;;2774   Reads in size * count bytes into buffer from file, starting
;;;2775   	from current position. It then sets the current position to the
;;;2776   	byte after the last byte read. If it reaches the end of file
;;;2777   	before filling the buffer then it stops reading.
;;;2778   void* buffer OUT: Pointer to buffer to fill. Should be at least as
;;;2779   	big as the number of bytes required
;;;2780   u32 size IN: size of each item to read
;;;2781   u32 count IN: number of items to read
;;;2782   FAT_FILE* file IN: Handle of an open file
;;;2783   u32 OUT: returns the actual number of bytes read
;;;2784   -----------------------------------------------------------------*/
;;;2785   u32 FAT_fread (void* buffer, u32 size, u32 count, FAT_FILE* file)
;;;2786   {
001ba4                      FAT_fread
001ba4  b5ff                        PUSH     {r0-r7,lr}
001ba6  b085                        SUB      sp,#&14
;;;2787   	int curByte;
;;;2788   	int curSect;
;;;2789   	u32 curClus;
;;;2790   	u32 tempNextCluster;
;;;2791   	
;;;2792   	int tempVar;
;;;2793   
;;;2794   	char* data = (char*)buffer;
;;;2795   
;;;2796   	u32 length = size * count;
001ba8  1c0f                        MOV      r7,r1
001baa  4357                        MUL      r7,r2
;;;2797   	u32 remain;
;;;2798   
;;;2799   	bool flagNoError = true;
001bac  2301                        MOV      r3,#1
001bae  9300                        STR      r3,[sp,#0]
;;;2800   
;;;2801   	// Can't read non-existant files
;;;2802   	if ((file == NULL) || (file->inUse == false) || size == 0 || count == 0 || buffer == NULL)
001bb0  9b08                        LDR      r3,[sp,#&20]
001bb2  9701                        STR      r7,[sp,#4]   ;;;2796
001bb4  2700                        MOV      r7,#0
001bb6  1c05                        MOV      r5,r0
001bb8  2b00                        CMP      r3,#0
001bba  d00f                        BEQ      F34L61
001bbc  9b08                        LDR      r3,[sp,#&20]
001bbe  33ff                        ADD      r3,#&ff
001bc0  33ff                        ADD      r3,#&ff
001bc2  3302                        ADD      r3,#2
001bc4  6b1c                        LDR      r4,[r3,#&30]
001bc6  2c00                        CMP      r4,#0
001bc8  d008                        BEQ      F34L62
001bca  2900                        CMP      r1,#0
001bcc  d006                        BEQ      F34L61
001bce  2a00                        CMP      r2,#0
001bd0  d004                        BEQ      F34L61
001bd2  2800                        CMP      r0,#0
001bd4  d002                        BEQ      F34L61
;;;2803   		return 0;
;;;2804   
;;;2805   	// Can only read files openned for reading
;;;2806   	if (!file->read)
001bd6  6a58                        LDR      r0,[r3,#&24]
001bd8  2800                        CMP      r0,#0
001bda  d101                        BNE      F34L63
                            F34L61
                            F34L62
001bdc  1c38                        MOV      r0,r7   ;;;2803
001bde  e0cc                        B        F34L64   ;;;2803
                            F34L63
;;;2807   		return 0;
;;;2808   
;;;2809   	// Don't read past end of file
;;;2810   	if (length + file->curPos > file->length)
001be0  9b08                        LDR      r3,[sp,#&20]
001be2  6898                        LDR      r0,[r3,#8]
001be4  9901                        LDR      r1,[sp,#4]
001be6  1842                        ADD      r2,r0,r1
001be8  6859                        LDR      r1,[r3,#4]
001bea  428a                        CMP      r2,r1
001bec  d901                        BLS      F34L65
;;;2811   		length = file->length - file->curPos;
001bee  1a09                        SUB      r1,r0
001bf0  9101                        STR      r1,[sp,#4]
                            F34L65
;;;2812   
;;;2813   	remain = length;
;;;2814   
;;;2815   	curByte = file->curByte;
001bf2  9b08                        LDR      r3,[sp,#&20]
001bf4  9f01                        LDR      r7,[sp,#4]
001bf6  6959                        LDR      r1,[r3,#&14]
;;;2816   	curSect = file->curSect;
;;;2817   	curClus = file->curClus;
;;;2818   
;;;2819   	// Align to sector
;;;2820   	tempVar = BYTE_PER_READ - curByte;
001bf8  2001                        MOV      r0,#1
001bfa  0240                        LSL      r0,#9
001bfc  9103                        STR      r1,[sp,#&c]   ;;;2815
001bfe  691c                        LDR      r4,[r3,#&10]
001c00  1a42                        SUB      r2,r0,r1
001c02  68de                        LDR      r6,[r3,#&c]
001c04  9202                        STR      r2,[sp,#8]
;;;2821   	if (tempVar > remain)
001c06  42ba                        CMP      r2,r7
001c08  d900                        BLS      F34L66
;;;2822   		tempVar = remain;
001c0a  9702                        STR      r7,[sp,#8]
                            F34L66
;;;2823   
;;;2824   	if ((tempVar < BYTE_PER_READ) && flagNoError) 
001c0c  2301                        MOV      r3,#1
001c0e  9a02                        LDR      r2,[sp,#8]
001c10  025b                        LSL      r3,#9
001c12  429a                        CMP      r2,r3
001c14  da15                        BGE      F34L67
;;;2825   	{
;;;2826   		memcpy(data, &(file->readBuffer[curByte]), tempVar);
001c16  9803                        LDR      r0,[sp,#&c]
001c18  9b08                        LDR      r3,[sp,#&20]
001c1a  9a02                        LDR      r2,[sp,#8]
001c1c  1818                        ADD      r0,r3,r0
001c1e  1dc1                        ADD      r1,r0,#7
001c20  3111                        ADD      r1,#&11
001c22  1c28                        MOV      r0,r5
001c24  f7fe f9ec                   BL       memcpy
;;;2827   		remain -= tempVar;
001c28  9a02                        LDR      r2,[sp,#8]
;;;2828   		data += tempVar;
;;;2829   
;;;2830   		curByte += tempVar;
001c2a  9803                        LDR      r0,[sp,#&c]
001c2c  1abf                        SUB      r7,r2   ;;;2827
001c2e  1880                        ADD      r0,r2
001c30  18ad                        ADD      r5,r2   ;;;2828
;;;2831   		if (curByte >= BYTE_PER_READ) 
001c32  2301                        MOV      r3,#1
001c34  025b                        LSL      r3,#9
001c36  4298                        CMP      r0,r3
001c38  9003                        STR      r0,[sp,#&c]   ;;;2830
001c3a  db02                        BLT      F34L68
;;;2832   		{
;;;2833   			curByte = 0;
001c3c  2000                        MOV      r0,#0
001c3e  9003                        STR      r0,[sp,#&c]
;;;2834   			curSect++;
001c40  3401                        ADD      r4,#1
                            F34L67
                            F34L68
;;;2835   		}
;;;2836   	}
;;;2837   
;;;2838   	// align to cluster
;;;2839   	// tempVar is number of sectors to read
;;;2840   	if (remain > (filesysSecPerClus - curSect) * BYTE_PER_READ) 
001c42  4a50                        LDR      r2,F34L1
001c44  6a10                        LDR      r0,[r2,#&20]
001c46  1b01                        SUB      r1,r0,r4
001c48  024a                        LSL      r2,r1,#9
001c4a  42ba                        CMP      r2,r7
001c4c  d300                        BCC      F34L69
;;;2841   	{
;;;2842   		tempVar = filesysSecPerClus - curSect;
;;;2843   	} else {
;;;2844   		tempVar = remain / BYTE_PER_READ;
001c4e  0a79                        LSR      r1,r7,#9
                            F34L69
001c50  9102                        STR      r1,[sp,#8]   ;;;2842
;;;2845   	}
;;;2846   
;;;2847   	if ((tempVar > 0) && flagNoError)
001c52  2900                        CMP      r1,#0
001c54  dd10                        BLE      F34L70
;;;2848   	{
;;;2849   		disc_ReadSectors ( curSect + FAT_ClustToSect(curClus), tempVar, data);
001c56  1eb1                        SUB      r1,r6,#2
001c58  4341                        MUL      r1,r0
001c5a  4a4a                        LDR      r2,F34L1
001c5c  6990                        LDR      r0,[r2,#&18]
001c5e  1808                        ADD      r0,r1,r0
001c60  9902                        LDR      r1,[sp,#8]
001c62  1900                        ADD      r0,r4
001c64  0609                        LSL      r1,#24
001c66  0e09                        LSR      r1,#24
001c68  1c2a                        MOV      r2,r5
001c6a  f7fe f9f9                   BL       MPCF_ReadSectors
;;;2850   		data += tempVar * BYTE_PER_READ;
001c6e  9902                        LDR      r1,[sp,#8]
001c70  0248                        LSL      r0,r1,#9
001c72  1945                        ADD      r5,r0,r5
;;;2851   		remain -= tempVar * BYTE_PER_READ;
001c74  1a3f                        SUB      r7,r0
;;;2852   
;;;2853   		curSect += tempVar;
001c76  1864                        ADD      r4,r1
                            F34L70
;;;2854   	}
;;;2855   
;;;2856   	// Move onto next cluster
;;;2857   	// It should get to here without reading anything if a cluster is due to be allocated
;;;2858   	if (curSect >= filesysSecPerClus)
001c78  4842                        LDR      r0,F34L1
001c7a  6a00                        LDR      r0,[r0,#&20]
001c7c  4284                        CMP      r4,r0
001c7e  db2c                        BLT      F34L71
;;;2859   	{
;;;2860   		tempNextCluster = FAT_NextCluster(curClus);
001c80  1c30                        MOV      r0,r6
001c82  f7fe fadb                   BL       FAT_NextCluster
;;;2861   		if ((remain == 0) && (tempNextCluster == CLUSTER_EOF))
001c86  2f00                        CMP      r7,#0
001c88  d105                        BNE      F34L72
001c8a  4b3f                        LDR      r3,F34L1+4
001c8c  4298                        CMP      r0,r3
001c8e  d102                        BNE      F34L72
;;;2862   		{
;;;2863   			curSect = filesysSecPerClus;
001c90  483c                        LDR      r0,F34L1
001c92  6a04                        LDR      r4,[r0,#&20]
001c94  e021                        B        F34L73
                            F34L72
;;;2864   		} else {
;;;2865   			curSect = 0;
001c96  2400                        MOV      r4,#0
;;;2866   			curClus = tempNextCluster;
001c98  1c06                        MOV      r6,r0
001c9a  d11e                        BNE      F34L73
001c9c  e01b                        B        F34L74
                            F34L36
;;;2867   			if (curClus == CLUSTER_FREE)
;;;2868   			{
;;;2869   				flagNoError = false;
;;;2870   			}
;;;2871   		}
;;;2872   	}
;;;2873   
;;;2874   	// Read in whole clusters
;;;2875   	while ((remain >= filesysBytePerClus) && flagNoError)
;;;2876   	{
;;;2877   		disc_ReadSectors (FAT_ClustToSect(curClus), filesysSecPerClus, data);
001c9e  1c0c                        MOV      r4,r1
001ca0  6a09                        LDR      r1,[r1,#&20]
001ca2  1eb0                        SUB      r0,r6,#2
001ca4  4348                        MUL      r0,r1
001ca6  69a2                        LDR      r2,[r4,#&18]
001ca8  1880                        ADD      r0,r2
001caa  0609                        LSL      r1,#24
001cac  0e09                        LSR      r1,#24
001cae  1c2a                        MOV      r2,r5
001cb0  f7fe f9d6                   BL       MPCF_ReadSectors
;;;2878   		data += filesysBytePerClus;
001cb4  6a60                        LDR      r0,[r4,#&24]
001cb6  182d                        ADD      r5,r0
;;;2879   		remain -= filesysBytePerClus;
001cb8  1a3f                        SUB      r7,r0
;;;2880   
;;;2881   		// Advance to next cluster
;;;2882   		tempNextCluster = FAT_NextCluster(curClus);
001cba  1c30                        MOV      r0,r6
001cbc  f7fe fabe                   BL       FAT_NextCluster
;;;2883   		if ((remain == 0) && (tempNextCluster == CLUSTER_EOF))
001cc0  2f00                        CMP      r7,#0
001cc2  d105                        BNE      F34L75
001cc4  4b30                        LDR      r3,F34L1+4
001cc6  4298                        CMP      r0,r3
001cc8  d102                        BNE      F34L75
;;;2884   		{
;;;2885   			curSect = filesysSecPerClus;
001cca  492e                        LDR      r1,F34L1
001ccc  6a0c                        LDR      r4,[r1,#&20]
001cce  e004                        B        F34L76
                            F34L75
;;;2886   		} else {
;;;2887   			curSect = 0;
001cd0  2400                        MOV      r4,#0
;;;2888   			curClus = tempNextCluster;
001cd2  1c06                        MOV      r6,r0
001cd4  d101                        BNE      F34L73
                            F34L74
;;;2889   			if (curClus == CLUSTER_FREE)
;;;2890   			{
;;;2891   				flagNoError = false;
001cd6  2000                        MOV      r0,#0
001cd8  9000                        STR      r0,[sp,#0]
                            F34L71
                            F34L73
                            F34L76
001cda  492a                        LDR      r1,F34L1   ;;;2875
001cdc  6a48                        LDR      r0,[r1,#&24]   ;;;2875
001cde  4287                        CMP      r7,r0   ;;;2875
001ce0  d302                        BCC      F34L77   ;;;2875
001ce2  9800                        LDR      r0,[sp,#0]   ;;;2875
001ce4  2800                        CMP      r0,#0   ;;;2875
001ce6  d1da                        BNE      F34L36   ;;;2875
                            F34L77
;;;2892   			}
;;;2893   		}
;;;2894   	}
;;;2895   
;;;2896   	// Read remaining sectors
;;;2897   	tempVar = remain / BYTE_PER_READ; // Number of sectors left
001ce8  0a79                        LSR      r1,r7,#9
001cea  9102                        STR      r1,[sp,#8]
;;;2898   	if ((tempVar > 0) && flagNoError)
001cec  2900                        CMP      r1,#0
001cee  dd13                        BLE      F34L78
001cf0  9800                        LDR      r0,[sp,#0]
001cf2  2800                        CMP      r0,#0
001cf4  d010                        BEQ      F34L79
;;;2899   	{
;;;2900   		disc_ReadSectors (FAT_ClustToSect(curClus), tempVar, data);
001cf6  4923                        LDR      r1,F34L1
001cf8  1eb0                        SUB      r0,r6,#2
001cfa  6a0a                        LDR      r2,[r1,#&20]
001cfc  6989                        LDR      r1,[r1,#&18]
001cfe  4350                        MUL      r0,r2
001d00  1840                        ADD      r0,r1
001d02  9902                        LDR      r1,[sp,#8]
001d04  0609                        LSL      r1,#24
001d06  0e09                        LSR      r1,#24
001d08  1c2a                        MOV      r2,r5
001d0a  f7fe f9a9                   BL       MPCF_ReadSectors
;;;2901   		data += tempVar * BYTE_PER_READ;
001d0e  9902                        LDR      r1,[sp,#8]
001d10  0248                        LSL      r0,r1,#9
001d12  1945                        ADD      r5,r0,r5
;;;2902   		remain -= tempVar * BYTE_PER_READ;
001d14  1a3f                        SUB      r7,r0
;;;2903   		curSect += tempVar;
001d16  1864                        ADD      r4,r1
                            F34L78
                            F34L79
;;;2904   	}
;;;2905   
;;;2906   	// Last remaining sector
;;;2907   	// Check if sector wanted is different to the one started with
;;;2908   	if ( ((file->curByte + length) >= BYTE_PER_READ) && flagNoError)
001d18  9b08                        LDR      r3,[sp,#&20]
001d1a  6958                        LDR      r0,[r3,#&14]
001d1c  9901                        LDR      r1,[sp,#4]
001d1e  1840                        ADD      r0,r1
001d20  2301                        MOV      r3,#1
001d22  025b                        LSL      r3,#9
001d24  4298                        CMP      r0,r3
001d26  d31b                        BCC      F34L80
001d28  9800                        LDR      r0,[sp,#0]
001d2a  2800                        CMP      r0,#0
001d2c  d018                        BEQ      F34L81
;;;2909   	{
;;;2910   		disc_ReadSector( curSect + FAT_ClustToSect( curClus), file->readBuffer);
001d2e  9b08                        LDR      r3,[sp,#&20]
001d30  4914                        LDR      r1,F34L1
001d32  1dda                        ADD      r2,r3,#7
001d34  3211                        ADD      r2,#&11
001d36  9204                        STR      r2,[sp,#&10]
001d38  6a0b                        LDR      r3,[r1,#&20]
001d3a  1eb0                        SUB      r0,r6,#2
001d3c  4358                        MUL      r0,r3
001d3e  6989                        LDR      r1,[r1,#&18]
001d40  1840                        ADD      r0,r1
001d42  1900                        ADD      r0,r4
001d44  2101                        MOV      r1,#1
001d46  f7fe f98b                   BL       MPCF_ReadSectors
;;;2911   		if (remain > 0)
001d4a  2f00                        CMP      r7,#0
001d4c  d908                        BLS      F34L82
;;;2912   		{
;;;2913   			memcpy(data, file->readBuffer, remain);
001d4e  1c28                        MOV      r0,r5
001d50  1c3a                        MOV      r2,r7
001d52  9904                        LDR      r1,[sp,#&10]
001d54  f7fe f954                   BL       memcpy
;;;2914   			curByte += remain;
001d58  9803                        LDR      r0,[sp,#&c]
001d5a  19c0                        ADD      r0,r7
001d5c  9003                        STR      r0,[sp,#&c]
;;;2915   			remain = 0;
001d5e  2700                        MOV      r7,#0
                            F34L80
                            F34L81
                            F34L82
;;;2916   		}
;;;2917   	}
;;;2918   
;;;2919   	// Length read is the wanted length minus the stuff not read
;;;2920   	length = length - remain;
001d60  9901                        LDR      r1,[sp,#4]
;;;2921   
;;;2922   	// Update file information
;;;2923   	file->curByte = curByte;
001d62  9b08                        LDR      r3,[sp,#&20]
001d64  1bc8                        SUB      r0,r1,r7   ;;;2920
001d66  9903                        LDR      r1,[sp,#&c]
;;;2924   	file->curSect = curSect;
001d68  6159                        STR      r1,[r3,#&14]
001d6a  9b08                        LDR      r3,[sp,#&20]
;;;2925   	file->curClus = curClus;
001d6c  611c                        STR      r4,[r3,#&10]
001d6e  9b08                        LDR      r3,[sp,#&20]
;;;2926   	file->curPos = file->curPos + length;
001d70  60de                        STR      r6,[r3,#&c]
001d72  9b08                        LDR      r3,[sp,#&20]
001d74  6899                        LDR      r1,[r3,#8]
001d76  1809                        ADD      r1,r0
001d78  6099                        STR      r1,[r3,#8]
                            F34L64
001d7a  b009                        ADD      sp,#&24
001d7c  bcf0                        POP      {r4-r7}
001d7e  bc08                        POP      {r3}
001d80  4718                        BX       r3
001d82  0000                        LSL      r0,#0
                            F34L1
001d84  00000000                    DCD      |x$dataseg|
001d88  0fffffff                    DCD      0x0fffffff

;;;2927   	return length;
;;;2928   }
;;;2929   
;;;2930   /*-----------------------------------------------------------------
;;;2931   FAT_fwrite(buffer, size, count, file)
;;;2932   Writes size * count bytes into file from buffer, starting
;;;2933   	from current position. It then sets the current position to the
;;;2934   	byte after the last byte written. If the file was openned in 
;;;2935   	append mode it always writes to the end of the file.
;;;2936   const void* buffer IN: Pointer to buffer containing data. Should be
;;;2937   	at least as big as the number of bytes to be written.
;;;2938   u32 size IN: size of each item to write
;;;2939   u32 count IN: number of items to write
;;;2940   FAT_FILE* file IN: Handle of an open file
;;;2941   u32 OUT: returns the actual number of bytes written
;;;2942   -----------------------------------------------------------------*/
;;;2943   u32 FAT_fwrite (const void* buffer, u32 size, u32 count, FAT_FILE* file)
;;;2944   {
001d8c                      FAT_fwrite
001d8c  b5ff                        PUSH     {r0-r7,lr}
001d8e  b088                        SUB      sp,#&20
;;;2945   	int curByte;
;;;2946   	int curSect;
;;;2947   	u32 curClus;
;;;2948   
;;;2949   	u32 tempNextCluster;
;;;2950   	int tempVar;
;;;2951   	u32 length = size * count;
001d90  4351                        MUL      r1,r2
001d92  9103                        STR      r1,[sp,#&c]
001d94  1c0c                        MOV      r4,r1
;;;2952   	u32 remain = length;
;;;2953   	char* data = (char*)buffer;
;;;2954   
;;;2955   	char* writeBuffer;
;;;2956   
;;;2957   	bool flagNoError = true;
001d96  2101                        MOV      r1,#1
001d98  9101                        STR      r1,[sp,#4]
;;;2958   	bool flagAppending = false;
001d9a  2100                        MOV      r1,#0
;;;2959   
;;;2960   	if ((file == NULL) || (file->inUse == false) || length == 0 || buffer == NULL)
001d9c  9b0b                        LDR      r3,[sp,#&2c]
001d9e  1c06                        MOV      r6,r0
001da0  2b00                        CMP      r3,#0
001da2  9100                        STR      r1,[sp,#0]   ;;;2958
001da4  d00c                        BEQ      F35L94
001da6  9b0b                        LDR      r3,[sp,#&2c]
001da8  1dda                        ADD      r2,r3,#7
001daa  32ff                        ADD      r2,#&ff
001dac  32fa                        ADD      r2,#&fa
001dae  9207                        STR      r2,[sp,#&1c]
001db0  6b12                        LDR      r2,[r2,#&30]
001db2  2a00                        CMP      r2,#0
001db4  d004                        BEQ      F35L95
001db6  9a03                        LDR      r2,[sp,#&c]
001db8  2a00                        CMP      r2,#0
001dba  d001                        BEQ      F35L94
001dbc  2800                        CMP      r0,#0
001dbe  d101                        BNE      F35L96
                            F35L94
                            F35L95
                            F35L5
;;;2961   		return 0;
001dc0  1c08                        MOV      r0,r1
001dc2  e163                        B        F35L97
                            F35L96
;;;2962   
;;;2963   	if (file->write)
001dc4  9807                        LDR      r0,[sp,#&1c]
001dc6  6a80                        LDR      r0,[r0,#&28]
001dc8  2800                        CMP      r0,#0
001dca  d010                        BEQ      F35L98
;;;2964   	{
;;;2965   		// Write at current read pointer
;;;2966   		curByte = file->curByte;
001dcc  9b0b                        LDR      r3,[sp,#&2c]
001dce  6958                        LDR      r0,[r3,#&14]
001dd0  9005                        STR      r0,[sp,#&14]
;;;2967   		curSect = file->curSect;
;;;2968   		curClus = file->curClus;
;;;2969   
;;;2970   		// Use read buffer as write buffer
;;;2971   		writeBuffer = file->readBuffer;
001dd2  1dd8                        ADD      r0,r3,#7
001dd4  691d                        LDR      r5,[r3,#&10]
001dd6  68df                        LDR      r7,[r3,#&c]
001dd8  3011                        ADD      r0,#&11
001dda  9002                        STR      r0,[sp,#8]
;;;2972   
;;;2973   		// If it is writing past the current end of file, set appending flag
;;;2974   		if (length + file->curPos > file->length)
001ddc  6898                        LDR      r0,[r3,#8]
001dde  9903                        LDR      r1,[sp,#&c]
001de0  1840                        ADD      r0,r1
001de2  6859                        LDR      r1,[r3,#4]
001de4  4288                        CMP      r0,r1
001de6  d91b                        BLS      F35L99
;;;2975   		{
;;;2976   			flagAppending = true;
001de8  2001                        MOV      r0,#1
001dea  9000                        STR      r0,[sp,#0]
001dec  e018                        B        F35L100
                            F35L98
;;;2977   		}
;;;2978   	}
;;;2979   	else if (file->append)
001dee  9807                        LDR      r0,[sp,#&1c]
001df0  6ac0                        LDR      r0,[r0,#&2c]
001df2  2800                        CMP      r0,#0
001df4  d0e4                        BEQ      F35L5
;;;2980   	{
;;;2981   		// Write at end of file
;;;2982   		curByte = file->appByte;
001df6  9807                        LDR      r0,[sp,#&1c]
;;;2983   		curSect = file->appSect;
;;;2984   		curClus = file->appClus;
;;;2985   		flagAppending = true;
;;;2986   
;;;2987   		// Use global buffer as write buffer, don't touch read buffer
;;;2988   		writeBuffer = (char*)globalBuffer;
001df8  4aa6                        LDR      r2,F35L1
001dfa  6a00                        LDR      r0,[r0,#&20]   ;;;2982
;;;2989   		disc_ReadSector(curSect + FAT_ClustToSect(curClus), writeBuffer);
001dfc  49a6                        LDR      r1,F35L1+4
001dfe  9005                        STR      r0,[sp,#&14]   ;;;2982
001e00  9807                        LDR      r0,[sp,#&1c]   ;;;2983
001e02  69c5                        LDR      r5,[r0,#&1c]   ;;;2985
001e04  6987                        LDR      r7,[r0,#&18]   ;;;2985
001e06  2001                        MOV      r0,#1   ;;;2985
001e08  9000                        STR      r0,[sp,#0]   ;;;2985
001e0a  9202                        STR      r2,[sp,#8]   ;;;2988
001e0c  6a0a                        LDR      r2,[r1,#&20]
001e0e  1eb8                        SUB      r0,r7,#2
001e10  4350                        MUL      r0,r2
001e12  6989                        LDR      r1,[r1,#&18]
001e14  9a02                        LDR      r2,[sp,#8]
001e16  1840                        ADD      r0,r1
001e18  1940                        ADD      r0,r5
001e1a  2101                        MOV      r1,#1
001e1c  f7fe f920                   BL       MPCF_ReadSectors
                            F35L99
                            F35L100
;;;2990   	}
;;;2991   	else
;;;2992   	{
;;;2993   		return 0;
;;;2994   	}
;;;2995   
;;;2996   	// Move onto next cluster if needed
;;;2997   	if (curSect >= filesysSecPerClus)
001e20  499d                        LDR      r1,F35L1+4
001e22  6a08                        LDR      r0,[r1,#&20]
001e24  4285                        CMP      r5,r0
001e26  db21                        BLT      F35L101
;;;2998   	{
;;;2999   		curSect = 0;
001e28  2500                        MOV      r5,#0
;;;3000   		tempNextCluster = FAT_NextCluster(curClus);
001e2a  1c38                        MOV      r0,r7
001e2c  f7fe fa06                   BL       FAT_NextCluster
;;;3001   		if ((tempNextCluster == CLUSTER_EOF) || (tempNextCluster == CLUSTER_FREE))
001e30  4b9a                        LDR      r3,F35L1+8
001e32  4298                        CMP      r0,r3
001e34  d001                        BEQ      F35L102
001e36  2800                        CMP      r0,#0
001e38  d10d                        BNE      F35L103
                            F35L102
;;;3002   		{
;;;3003   			// Ran out of clusters so get a new one
;;;3004   			curClus = FAT_LinkFreeCluster(curClus);
001e3a  1c38                        MOV      r0,r7
001e3c  f7fe fc34                   BL       FAT_LinkFreeCluster
001e40  1c07                        MOV      r7,r0
001e42  d101                        BNE      F35L104
;;;3005   			if (curClus == CLUSTER_FREE) // Couldn't get a cluster, so abort
;;;3006   			{
;;;3007   				flagNoError = false;
001e44  2000                        MOV      r0,#0
001e46  9001                        STR      r0,[sp,#4]
                            F35L104
;;;3008   			}
;;;3009   			memset(writeBuffer, 0, BYTE_PER_READ);
001e48  2201                        MOV      r2,#1
001e4a  0252                        LSL      r2,#9
001e4c  2100                        MOV      r1,#0
001e4e  9802                        LDR      r0,[sp,#8]
001e50  f7fe f8d6                   BL       memset
001e54  e00a                        B        F35L105
                            F35L103
;;;3010   		} else {
;;;3011   			curClus = tempNextCluster;
;;;3012   			disc_ReadSector( FAT_ClustToSect( curClus), writeBuffer);
001e56  4990                        LDR      r1,F35L1+4
001e58  1c07                        MOV      r7,r0
001e5a  6a0a                        LDR      r2,[r1,#&20]
001e5c  3802                        SUB      r0,#2
001e5e  4350                        MUL      r0,r2
001e60  6989                        LDR      r1,[r1,#&18]
001e62  9a02                        LDR      r2,[sp,#8]
001e64  1840                        ADD      r0,r1
001e66  2101                        MOV      r1,#1
001e68  f7fe f8fa                   BL       MPCF_ReadSectors
                            F35L101
                            F35L105
;;;3013   		}
;;;3014   	}
;;;3015   	
;;;3016   	// Align to sector
;;;3017   	tempVar = BYTE_PER_READ - curByte;
001e6c  2001                        MOV      r0,#1
001e6e  9905                        LDR      r1,[sp,#&14]
001e70  0240                        LSL      r0,#9
001e72  1a42                        SUB      r2,r0,r1
001e74  9204                        STR      r2,[sp,#&10]
;;;3018   	if (tempVar > remain)
001e76  42a2                        CMP      r2,r4
001e78  d900                        BLS      F35L106
;;;3019   		tempVar = remain;
001e7a  9404                        STR      r4,[sp,#&10]
                            F35L106
;;;3020   
;;;3021   	if ((tempVar < BYTE_PER_READ) && flagNoError)
001e7c  2301                        MOV      r3,#1
001e7e  9a04                        LDR      r2,[sp,#&10]
001e80  025b                        LSL      r3,#9
001e82  429a                        CMP      r2,r3
001e84  da22                        BGE      F35L107
001e86  9801                        LDR      r0,[sp,#4]
001e88  2800                        CMP      r0,#0
001e8a  d01f                        BEQ      F35L108
;;;3022   	{
;;;3023   		memcpy(&(writeBuffer[curByte]), data, tempVar);
001e8c  9802                        LDR      r0,[sp,#8]
001e8e  9905                        LDR      r1,[sp,#&14]
001e90  9a04                        LDR      r2,[sp,#&10]
001e92  1840                        ADD      r0,r1
001e94  1c31                        MOV      r1,r6
001e96  f7fe f8b3                   BL       memcpy
;;;3024   		remain -= tempVar;
001e9a  9a04                        LDR      r2,[sp,#&10]
;;;3025   		data += tempVar;
;;;3026   		curByte += tempVar;
001e9c  9805                        LDR      r0,[sp,#&14]
;;;3027   
;;;3028   		// Write buffer back to disk
;;;3029   		disc_WriteSector (curSect + FAT_ClustToSect(curClus), writeBuffer);
001e9e  497e                        LDR      r1,F35L1+4
001ea0  1880                        ADD      r0,r2   ;;;3026
001ea2  9005                        STR      r0,[sp,#&14]   ;;;3026
001ea4  1aa4                        SUB      r4,r2   ;;;3024
001ea6  18b6                        ADD      r6,r2   ;;;3025
001ea8  6a0a                        LDR      r2,[r1,#&20]
001eaa  1eb8                        SUB      r0,r7,#2
001eac  4350                        MUL      r0,r2
001eae  6989                        LDR      r1,[r1,#&18]
001eb0  9a02                        LDR      r2,[sp,#8]
001eb2  1840                        ADD      r0,r1
001eb4  1940                        ADD      r0,r5
001eb6  2101                        MOV      r1,#1
001eb8  f7fe f93e                   BL       MPCF_WriteSectors
;;;3030   		
;;;3031   		// Move onto next sector
;;;3032   		if (curByte >= BYTE_PER_READ) 
001ebc  2301                        MOV      r3,#1
001ebe  9805                        LDR      r0,[sp,#&14]
001ec0  025b                        LSL      r3,#9
001ec2  4298                        CMP      r0,r3
001ec4  db02                        BLT      F35L109
;;;3033   		{
;;;3034   			curByte = 0;
001ec6  2000                        MOV      r0,#0
001ec8  9005                        STR      r0,[sp,#&14]
;;;3035   			curSect++;
001eca  3501                        ADD      r5,#1
                            F35L107
                            F35L108
                            F35L109
;;;3036   		}
;;;3037   	}
;;;3038   
;;;3039   	// Align to cluster
;;;3040   	// tempVar is number of sectors to write
;;;3041   	if (remain > (filesysSecPerClus - curSect) * BYTE_PER_READ) 
001ecc  4a72                        LDR      r2,F35L1+4
001ece  6a10                        LDR      r0,[r2,#&20]
001ed0  1b41                        SUB      r1,r0,r5
001ed2  024a                        LSL      r2,r1,#9
001ed4  42a2                        CMP      r2,r4
001ed6  d300                        BCC      F35L110
;;;3042   	{
;;;3043   		tempVar = filesysSecPerClus - curSect;
;;;3044   	} else {
;;;3045   		tempVar = remain / BYTE_PER_READ;
001ed8  0a61                        LSR      r1,r4,#9
                            F35L110
001eda  9104                        STR      r1,[sp,#&10]   ;;;3043
;;;3046   	}
;;;3047   
;;;3048   	if ((tempVar > 0) && flagNoError)
001edc  2900                        CMP      r1,#0
001ede  dd13                        BLE      F35L111
001ee0  9901                        LDR      r1,[sp,#4]
001ee2  2900                        CMP      r1,#0
001ee4  d010                        BEQ      F35L112
;;;3049   	{
;;;3050   		disc_WriteSectors ( curSect + FAT_ClustToSect(curClus), tempVar, data);
001ee6  1eb9                        SUB      r1,r7,#2
001ee8  4341                        MUL      r1,r0
001eea  4a6b                        LDR      r2,F35L1+4
001eec  6990                        LDR      r0,[r2,#&18]
001eee  1808                        ADD      r0,r1,r0
001ef0  9904                        LDR      r1,[sp,#&10]
001ef2  1940                        ADD      r0,r5
001ef4  0609                        LSL      r1,#24
001ef6  0e09                        LSR      r1,#24
001ef8  1c32                        MOV      r2,r6
001efa  f7fe f91d                   BL       MPCF_WriteSectors
;;;3051   		data += tempVar * BYTE_PER_READ;
001efe  9904                        LDR      r1,[sp,#&10]
001f00  0248                        LSL      r0,r1,#9
001f02  1986                        ADD      r6,r0,r6
;;;3052   		remain -= tempVar * BYTE_PER_READ;
001f04  1a24                        SUB      r4,r0
;;;3053   		curSect += tempVar;
001f06  186d                        ADD      r5,r1
                            F35L111
                            F35L112
;;;3054   	}
;;;3055   
;;;3056   	if (((curSect >= filesysSecPerClus) && flagNoError) && (remain > 0))
001f08  4863                        LDR      r0,F35L1+4
001f0a  6a00                        LDR      r0,[r0,#&20]
001f0c  4285                        CMP      r5,r0
001f0e  da02                        BGE      F35L113
                            F35L88
001f10  1eb8                        SUB      r0,r7,#2
001f12  9006                        STR      r0,[sp,#&18]
001f14  e038                        B        F35L114
                            F35L113
001f16  9801                        LDR      r0,[sp,#4]
001f18  2800                        CMP      r0,#0
001f1a  d0f9                        BEQ      F35L88
001f1c  2c00                        CMP      r4,#0
001f1e  d9f7                        BLS      F35L88
;;;3057   	{
;;;3058   		curSect = 0;
001f20  2500                        MOV      r5,#0
;;;3059   		tempNextCluster = FAT_NextCluster(curClus);
001f22  1c38                        MOV      r0,r7
001f24  f7fe f98a                   BL       FAT_NextCluster
;;;3060   		if ((tempNextCluster == CLUSTER_EOF) || (tempNextCluster == CLUSTER_FREE))
001f28  4b5c                        LDR      r3,F35L1+8
001f2a  4298                        CMP      r0,r3
001f2c  d001                        BEQ      F35L115
001f2e  2800                        CMP      r0,#0
001f30  d128                        BNE      F35L116
                            F35L115
;;;3061   		{
;;;3062   			// Ran out of clusters so get a new one
;;;3063   			curClus = FAT_LinkFreeCluster(curClus);
001f32  1c38                        MOV      r0,r7
001f34  f7fe fbb8                   BL       FAT_LinkFreeCluster
001f38  1c07                        MOV      r7,r0
001f3a  d1e9                        BNE      F35L88
;;;3064   			if (curClus == CLUSTER_FREE) // Couldn't get a cluster, so abort
;;;3065   			{
;;;3066   				flagNoError = false;
001f3c  2000                        MOV      r0,#0
001f3e  9001                        STR      r0,[sp,#4]
001f40  e7e6                        B        F35L88
                            F35L51
;;;3067   			}
;;;3068   		} else {
;;;3069   			curClus = tempNextCluster;
;;;3070   		}
;;;3071   	}
;;;3072   
;;;3073   	// Write whole clusters
;;;3074   	while ((remain >= filesysBytePerClus) && flagNoError)
;;;3075   	{
;;;3076   		disc_WriteSectors (FAT_ClustToSect(curClus), filesysSecPerClus, data);
001f42  4955                        LDR      r1,F35L1+4
001f44  9806                        LDR      r0,[sp,#&18]
001f46  6a09                        LDR      r1,[r1,#&20]
001f48  4a53                        LDR      r2,F35L1+4
001f4a  4348                        MUL      r0,r1
001f4c  6992                        LDR      r2,[r2,#&18]
001f4e  1880                        ADD      r0,r2
001f50  0609                        LSL      r1,#24
001f52  0e09                        LSR      r1,#24
001f54  1c32                        MOV      r2,r6
001f56  f7fe f8ef                   BL       MPCF_WriteSectors
;;;3077   		data += filesysBytePerClus;
001f5a  494f                        LDR      r1,F35L1+4
001f5c  6a48                        LDR      r0,[r1,#&24]
001f5e  1836                        ADD      r6,r0
;;;3078   		remain -= filesysBytePerClus;
001f60  1a24                        SUB      r4,r0
;;;3079   		if (remain > 0)
001f62  d011                        BEQ      F35L114
;;;3080   		{
;;;3081   			tempNextCluster = FAT_NextCluster(curClus);
001f64  1c38                        MOV      r0,r7
001f66  f7fe f969                   BL       FAT_NextCluster
;;;3082   			if ((tempNextCluster == CLUSTER_EOF) || (tempNextCluster == CLUSTER_FREE))
001f6a  4b4c                        LDR      r3,F35L1+8
001f6c  4298                        CMP      r0,r3
001f6e  d001                        BEQ      F35L117
001f70  2800                        CMP      r0,#0
001f72  d107                        BNE      F35L116
                            F35L117
;;;3083   			{
;;;3084   				// Ran out of clusters so get a new one
;;;3085   				curClus = FAT_LinkFreeCluster(curClus);
001f74  1c38                        MOV      r0,r7
001f76  f7fe fb97                   BL       FAT_LinkFreeCluster
001f7a  1c07                        MOV      r7,r0
001f7c  d1c8                        BNE      F35L88
;;;3086   				if (curClus == CLUSTER_FREE) // Couldn't get a cluster, so abort
;;;3087   				{
;;;3088   					flagNoError = false;
001f7e  2000                        MOV      r0,#0
001f80  9001                        STR      r0,[sp,#4]
001f82  e008                        B        F35L118
                            F35L116
;;;3089   					break;
;;;3090   				}
;;;3091   			} else {
;;;3092   				curClus = tempNextCluster;
001f84  1c07                        MOV      r7,r0
001f86  e7c3                        B        F35L88
                            F35L114
001f88  4943                        LDR      r1,F35L1+4   ;;;3074
001f8a  6a48                        LDR      r0,[r1,#&24]   ;;;3074
001f8c  4284                        CMP      r4,r0   ;;;3074
001f8e  d302                        BCC      F35L118   ;;;3074
001f90  9801                        LDR      r0,[sp,#4]   ;;;3074
001f92  2800                        CMP      r0,#0   ;;;3074
001f94  d1d5                        BNE      F35L51   ;;;3074
                            F35L118
;;;3093   			}
;;;3094   		}
;;;3095   	}
;;;3096   
;;;3097   	// Write remaining sectors
;;;3098   	tempVar = remain / BYTE_PER_READ; // Number of sectors left
001f96  0a61                        LSR      r1,r4,#9
001f98  9104                        STR      r1,[sp,#&10]
;;;3099   	if ((tempVar > 0) && flagNoError)
001f9a  2900                        CMP      r1,#0
001f9c  dd13                        BLE      F35L119
001f9e  9801                        LDR      r0,[sp,#4]
001fa0  2800                        CMP      r0,#0
001fa2  d010                        BEQ      F35L120
;;;3100   	{
;;;3101   		disc_WriteSectors (FAT_ClustToSect(curClus), tempVar, data);
001fa4  493c                        LDR      r1,F35L1+4
001fa6  1eb8                        SUB      r0,r7,#2
001fa8  6a0a                        LDR      r2,[r1,#&20]
001faa  6989                        LDR      r1,[r1,#&18]
001fac  4350                        MUL      r0,r2
001fae  1840                        ADD      r0,r1
001fb0  9904                        LDR      r1,[sp,#&10]
001fb2  0609                        LSL      r1,#24
001fb4  0e09                        LSR      r1,#24
001fb6  1c32                        MOV      r2,r6
001fb8  f7fe f8be                   BL       MPCF_WriteSectors
;;;3102   		data += tempVar * BYTE_PER_READ;
001fbc  9904                        LDR      r1,[sp,#&10]
001fbe  0248                        LSL      r0,r1,#9
001fc0  1986                        ADD      r6,r0,r6
;;;3103   		remain -= tempVar * BYTE_PER_READ;
001fc2  1a24                        SUB      r4,r0
;;;3104   		curSect += tempVar;
001fc4  186d                        ADD      r5,r1
                            F35L119
                            F35L120
;;;3105   	}
;;;3106   	
;;;3107   	// Last remaining sector
;;;3108   	// Check if sector wanted is different to the one started with
;;;3109   	if ( (( (file->append ? file->appByte : file->curByte) + length) >= BYTE_PER_READ) && flagNoError)
001fc6  9807                        LDR      r0,[sp,#&1c]
001fc8  6ac0                        LDR      r0,[r0,#&2c]
001fca  2800                        CMP      r0,#0
001fcc  d002                        BEQ      F35L121
001fce  9807                        LDR      r0,[sp,#&1c]
001fd0  6a00                        LDR      r0,[r0,#&20]
001fd2  e001                        B        F35L122
                            F35L121
001fd4  9b0b                        LDR      r3,[sp,#&2c]
001fd6  6958                        LDR      r0,[r3,#&14]
                            F35L122
001fd8  9903                        LDR      r1,[sp,#&c]
001fda  1840                        ADD      r0,r1
001fdc  2301                        MOV      r3,#1
001fde  025b                        LSL      r3,#9
001fe0  4298                        CMP      r0,r3
001fe2  d32c                        BCC      F35L123
001fe4  9801                        LDR      r0,[sp,#4]
001fe6  2800                        CMP      r0,#0
001fe8  d029                        BEQ      F35L124
;;;3110   	{
;;;3111   		if (flagAppending)
001fea  9800                        LDR      r0,[sp,#0]
001fec  2800                        CMP      r0,#0
001fee  d005                        BEQ      F35L125
;;;3112   		{
;;;3113   			// Zero sector before using it
;;;3114   			memset (writeBuffer, 0, BYTE_PER_READ);
001ff0  2100                        MOV      r1,#0
001ff2  1c1a                        MOV      r2,r3
001ff4  9802                        LDR      r0,[sp,#8]
001ff6  f7fe f803                   BL       memset
001ffa  e00a                        B        F35L126
                            F35L125
;;;3115   		} else {
;;;3116   			// Modify existing sector
;;;3117   			disc_ReadSector( curSect + FAT_ClustToSect( curClus), writeBuffer);
001ffc  4926                        LDR      r1,F35L1+4
001ffe  1eb8                        SUB      r0,r7,#2
002000  6a0a                        LDR      r2,[r1,#&20]
002002  6989                        LDR      r1,[r1,#&18]
002004  4350                        MUL      r0,r2
002006  1840                        ADD      r0,r1
002008  1940                        ADD      r0,r5
00200a  2101                        MOV      r1,#1
00200c  9a02                        LDR      r2,[sp,#8]
00200e  f7fe f827                   BL       MPCF_ReadSectors
                            F35L126
;;;3118   		}
;;;3119   		if (remain > 0) {
002012  2c00                        CMP      r4,#0
002014  d913                        BLS      F35L127
;;;3120   			memcpy(writeBuffer, data, remain);
002016  1c31                        MOV      r1,r6
002018  1c22                        MOV      r2,r4
00201a  9802                        LDR      r0,[sp,#8]
00201c  f7fd fff0                   BL       memcpy
;;;3121   			curByte += remain;
002020  9805                        LDR      r0,[sp,#&14]
;;;3122   			remain = 0;
;;;3123   			disc_WriteSector( curSect + FAT_ClustToSect( curClus), writeBuffer);
002022  491d                        LDR      r1,F35L1+4
002024  1900                        ADD      r0,r4   ;;;3121
002026  9005                        STR      r0,[sp,#&14]   ;;;3121
002028  6a0a                        LDR      r2,[r1,#&20]
00202a  1eb8                        SUB      r0,r7,#2
00202c  4350                        MUL      r0,r2
00202e  6989                        LDR      r1,[r1,#&18]
002030  2400                        MOV      r4,#0   ;;;3122
002032  1840                        ADD      r0,r1
002034  1940                        ADD      r0,r5
002036  2101                        MOV      r1,#1
002038  9a02                        LDR      r2,[sp,#8]
00203a  f7fe f87d                   BL       MPCF_WriteSectors
                            F35L123
                            F35L124
                            F35L127
;;;3124   		}
;;;3125   	}
;;;3126   	
;;;3127   	// Amount read is the originally requested amount minus stuff remaining
;;;3128   	length = length - remain;
00203e  9903                        LDR      r1,[sp,#&c]
;;;3129   
;;;3130   	// Update file information
;;;3131   	if (file->write)	// Writing also shifts the read pointer
002040  9a07                        LDR      r2,[sp,#&1c]
002042  1b08                        SUB      r0,r1,r4   ;;;3128
002044  6a91                        LDR      r1,[r2,#&28]
002046  2900                        CMP      r1,#0
002048  d011                        BEQ      F35L128
;;;3132   	{
;;;3133   		file->curByte = curByte;
00204a  9905                        LDR      r1,[sp,#&14]
00204c  9b0b                        LDR      r3,[sp,#&2c]
;;;3134   		file->curSect = curSect;
00204e  6159                        STR      r1,[r3,#&14]
002050  9b0b                        LDR      r3,[sp,#&2c]
;;;3135   		file->curClus = curClus;
002052  611d                        STR      r5,[r3,#&10]
002054  9b0b                        LDR      r3,[sp,#&2c]
;;;3136   		file->curPos = file->curPos + length;
002056  60df                        STR      r7,[r3,#&c]
002058  9b0b                        LDR      r3,[sp,#&2c]
00205a  6899                        LDR      r1,[r3,#8]
00205c  1809                        ADD      r1,r0
;;;3137   		if (file->length < file->curPos)
00205e  6099                        STR      r1,[r3,#8]
002060  9b0b                        LDR      r3,[sp,#&2c]
002062  685a                        LDR      r2,[r3,#4]
002064  428a                        CMP      r2,r1
002066  d211                        BCS      F35L97
                            F35L83
;;;3138   		{
;;;3139   			file->length = file->curPos;
002068  9b0b                        LDR      r3,[sp,#&2c]
00206a  6059                        STR      r1,[r3,#4]
00206c  e00e                        B        F35L129
                            F35L128
;;;3140   		}
;;;3141   	}
;;;3142   	else if (file->append)	// Appending doesn't affect the read pointer
00206e  9a07                        LDR      r2,[sp,#&1c]
002070  6ad1                        LDR      r1,[r2,#&2c]
002072  2900                        CMP      r1,#0
002074  d00a                        BEQ      F35L129
;;;3143   	{
;;;3144   		file->appByte = curByte;
002076  9905                        LDR      r1,[sp,#&14]
002078  9a07                        LDR      r2,[sp,#&1c]
;;;3145   		file->appSect = curSect;
00207a  6211                        STR      r1,[r2,#&20]
00207c  9a07                        LDR      r2,[sp,#&1c]
;;;3146   		file->appClus = curClus;
00207e  61d5                        STR      r5,[r2,#&1c]
002080  9a07                        LDR      r2,[sp,#&1c]
;;;3147   		file->length = file->length + length;
002082  6197                        STR      r7,[r2,#&18]
002084  9b0b                        LDR      r3,[sp,#&2c]
002086  6859                        LDR      r1,[r3,#4]
002088  1809                        ADD      r1,r0
00208a  e7ed                        B        F35L83
                            F35L97
                            F35L129
00208c  b00c                        ADD      sp,#&30
00208e  bcf0                        POP      {r4-r7}
002090  bc08                        POP      {r3}
002092  4718                        BX       r3
                            F35L1
002094  00000000                    DCD      globalBuffer
002098  00000000                    DCD      |x$dataseg|
00209c  0fffffff                    DCD      0x0fffffff
;;;3148   	}
;;;3149   
;;;3150   	return length;
;;;3151   }
;;;3152   
;;;3153   #if JUNK
;;;3154   
;;;3155   /*-----------------------------------------------------------------
;;;3156   FAT_feof(file)
;;;3157   Returns true if the end of file has been reached
;;;3158   FAT_FILE* file IN: Handle of an open file
;;;3159   bool return OUT: true if EOF, false if not
;;;3160   -----------------------------------------------------------------*/
;;;3161   bool FAT_feof(FAT_FILE* file)
;;;3162   {
;;;3163   	if ((file == NULL) || (file->inUse == false))
;;;3164   		return true;	// Return eof on invalid files
;;;3165   
;;;3166   	return (file->length == file->curPos);
;;;3167   }
;;;3168   
;;;3169   
;;;3170   /*-----------------------------------------------------------------
;;;3171   FAT_remove (path)
;;;3172   Deletes the file or empty directory sepecified in path
;;;3173   const char* path IN: Path of item to delete
;;;3174   int return OUT: zero if successful, non-zero if not
;;;3175   -----------------------------------------------------------------*/
;;;3176   int FAT_remove (const char* path)
;;;3177   {
;;;3178   	DIR_ENT dirEntry;
;;;3179   	u32 oldWorkDirCluster;
;;;3180   	char checkFilename[13];
;;;3181   	FILE_TYPE checkFiletype;
;;;3182   	
;;;3183   	dirEntry = FAT_DirEntFromPath (path);
;;;3184   
;;;3185   	if (dirEntry.name[0] == FILE_FREE)
;;;3186   	{
;;;3187   		return -1;
;;;3188   	}
;;;3189   	
;;;3190   	// Only delete directories if the directory is entry
;;;3191   	if (dirEntry.attrib & ATTRIB_DIR)
;;;3192   	{
;;;3193   		// Change to the directory temporarily
;;;3194   		oldWorkDirCluster = curWorkDirCluster;
;;;3195   		FAT_chdir(path);
;;;3196   
;;;3197   		// Search for files or directories, excluding the . and .. entries
;;;3198   		checkFiletype = FAT_FindFirstFile (checkFilename);
;;;3199   		while ((checkFilename[0] == '.')  && (checkFiletype != FT_NONE))
;;;3200   		{
;;;3201   			checkFiletype = FAT_FindNextFile (checkFilename);
;;;3202   		}
;;;3203   		
;;;3204   		// Change back to working directory
;;;3205   		curWorkDirCluster = oldWorkDirCluster;
;;;3206   		
;;;3207   		// Check that the directory is empty
;;;3208   		if (checkFiletype != FT_NONE)
;;;3209   		{
;;;3210   			// Directory isn't empty
;;;3211   			return -1;
;;;3212   		}
;;;3213   	}
;;;3214   
;;;3215   	// Refresh directory information
;;;3216   	dirEntry = FAT_DirEntFromPath (path);
;;;3217   
;;;3218   	// Free any clusters used
;;;3219   	FAT_ClearLinks (dirEntry.startCluster | (dirEntry.startClusterHigh << 16));
;;;3220   
;;;3221   	// Remove Directory entry
;;;3222   	disc_ReadSector ( (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector , globalBuffer);
;;;3223   	((DIR_ENT*)globalBuffer)[wrkDirOffset].name[0] = FILE_FREE;
;;;3224   	disc_WriteSector ( (wrkDirCluster == FAT16_ROOT_DIR_CLUSTER ? filesysRootDir : FAT_ClustToSect(wrkDirCluster)) + wrkDirSector , globalBuffer);
;;;3225   		
;;;3226   	return 0;
;;;3227   }
;;;3228   
;;;3229   
;;;3230   /*-----------------------------------------------------------------
;;;3231   FAT_mkdir (path)
;;;3232   Makes a new directory, so long as no other directory or file has 
;;;3233   	the same name.
;;;3234   const char* path IN: Path and filename of directory to make
;;;3235   int return OUT: zero if successful, non-zero if not
;;;3236   -----------------------------------------------------------------*/
;;;3237   int FAT_mkdir (const char* path)
;;;3238   {
;;;3239   	u32 newDirCluster;
;;;3240   	u32 parentDirCluster;
;;;3241   	DIR_ENT dirEntry;
;;;3242   	DIR_ENT* entries = (DIR_ENT*)globalBuffer;
;;;3243   	int i;
;;;3244   
;;;3245   	int pathPos, filePos;
;;;3246   	char pathname[MAX_FILENAME_LENGTH];
;;;3247   	u32 oldDirCluster;
;;;3248   
;;;3249   	if (FAT_FileExists(path) != FT_NONE)
;;;3250   	{
;;;3251   		return -1;	// File or directory exists with that name
;;;3252   	}
;;;3253   
;;;3254   	// Find filename within path and change to that directory
;;;3255   	oldDirCluster = curWorkDirCluster;
;;;3256   	if (path[0] == '/')
;;;3257   	{
;;;3258   		curWorkDirCluster = filesysRootDirClus;
;;;3259   	}
;;;3260   	
;;;3261   	pathPos = 0;
;;;3262   	filePos = 0;
;;;3263   
;;;3264   	while (path[pathPos + filePos] != '\0')
;;;3265   	{
;;;3266   		if (path[pathPos + filePos] == '/')
;;;3267   		{
;;;3268   			pathname[filePos] = '\0';
;;;3269   			if (FAT_chdir(pathname) == false) 
;;;3270   			{
;;;3271   				curWorkDirCluster = oldDirCluster;
;;;3272   				return -1; // Couldn't change directory
;;;3273   			}
;;;3274   			pathPos += filePos + 1;
;;;3275   			filePos = 0;
;;;3276   		}
;;;3277   		pathname[filePos] = path[pathPos + filePos];
;;;3278   		filePos++;
;;;3279   	}
;;;3280   
;;;3281   	// Now grab the parent directory's cluster
;;;3282   	parentDirCluster = curWorkDirCluster;
;;;3283   	curWorkDirCluster = oldDirCluster;
;;;3284   
;;;3285   	// Get a new cluster for the file
;;;3286   	newDirCluster = FAT_LinkFreeCluster(CLUSTER_FREE);
;;;3287   
;;;3288   	if (newDirCluster == CLUSTER_FREE)
;;;3289   	{
;;;3290   		return -1;	// Couldn't get a new cluster for the directory
;;;3291   	}
;;;3292   	
;;;3293   	// Fill in directory entry's information
;;;3294   	dirEntry.attrib = ATTRIB_DIR;
;;;3295   	dirEntry.reserved = 0;
;;;3296   	// Time and date set to system time and date
;;;3297   	dirEntry.cTime_ms = 0;
;;;3298   	dirEntry.cTime = 0;//getRTCtoFileTime();
;;;3299   	dirEntry.cDate = 0;//getRTCtoFileDate();
;;;3300   	dirEntry.aDate = 0;//getRTCtoFileDate();
;;;3301   	dirEntry.mTime = 0;//getRTCtoFileTime();
;;;3302   	dirEntry.mDate = 0;//getRTCtoFileDate();
;;;3303   	// Store cluster position into the directory entry
;;;3304   	dirEntry.startCluster = (newDirCluster & 0xFFFF);
;;;3305   	dirEntry.startClusterHigh = ((newDirCluster >> 16) & 0xFFFF);
;;;3306   	// The file has no data in it - its over written so should be empty
;;;3307   	dirEntry.fileSize = 0;
;;;3308   
;;;3309   	if (FAT_AddDirEntry (path, dirEntry) == false)
;;;3310   	{
;;;3311   		return -1;	// Couldn't add the directory entry
;;;3312   	}
;;;3313   
;;;3314   	// Create the new directory itself
;;;3315   	memset(entries, FILE_LAST, BYTE_PER_READ);
;;;3316   
;;;3317   	// Create . directory entry
;;;3318   	dirEntry.name[0] = '.';
;;;3319   	// Fill name and extension with spaces
;;;3320   	for (i = 1; i < 11; i++)
;;;3321   	{
;;;3322   		dirEntry.name[i] = ' ';
;;;3323   	}
;;;3324   
;;;3325   	memcpy(entries, &dirEntry, sizeof(dirEntry));
;;;3326   
;;;3327   	// Create .. directory entry
;;;3328   	dirEntry.name[1] = '.';
;;;3329   	dirEntry.startCluster = (parentDirCluster & 0xFFFF);
;;;3330   	dirEntry.startClusterHigh = ((parentDirCluster >> 16) & 0xFFFF);
;;;3331   
;;;3332   	memcpy(&entries[1], &dirEntry, sizeof(dirEntry));
;;;3333   
;;;3334   	// Write entry to disc
;;;3335   	disc_WriteSector(FAT_ClustToSect(newDirCluster), entries);
;;;3336   
;;;3337   	return 0;
;;;3338   }
;;;3339   
;;;3340   /*-----------------------------------------------------------------
;;;3341   FAT_fgetc (handle)
;;;3342   Gets the next character in the file
;;;3343   FAT_FILE* file IN: Handle of open file
;;;3344   bool return OUT: character if successful, EOF if not
;;;3345   -----------------------------------------------------------------*/
;;;3346   char FAT_fgetc (FAT_FILE* file)
;;;3347   {
;;;3348   	char c;
;;;3349   	return (FAT_fread(&c, 1, 1, file) == 1) ? c : EOF;
;;;3350   }
;;;3351   
;;;3352   /*-----------------------------------------------------------------
;;;3353   FAT_fputc (character, handle)
;;;3354   Writes the given character into the file
;;;3355   char c IN: Character to be written
;;;3356   FAT_FILE* file IN: Handle of open file
;;;3357   bool return OUT: character if successful, EOF if not
;;;3358   -----------------------------------------------------------------*/
;;;3359   char FAT_fputc (char c, FAT_FILE* file)
;;;3360   {
;;;3361   	return (FAT_fwrite(&c, 1, 1, file) == 1) ? c : EOF;
;;;3362   }
;;;3363   
;;;3364   /*-----------------------------------------------------------------
;;;3365   FAT_fgets (char *tgtBuffer, int num, FAT_FILE* file)
;;;3366   Gets a up to num bytes from file, stopping at the first
;;;3367    newline.
;;;3368   
;;;3369   CAUTION: does not do strictly streaming. I.e. it's 
;;;3370    reading more then needed bytes and seeking back.
;;;3371    shouldn't matter for random access 
;;;3372   
;;;3373   char *tgtBuffer OUT: buffer to write to
;;;3374   int num IN: size of target buffer
;;;3375   FAT_FILE* file IN: Handle of open file
;;;3376   bool return OUT: character if successful, EOF if not
;;;3377   
;;;3378     Written by MightyMax
;;;3379     Modified by Chishm - 2005-11-17
;;;3380   	* Added check for unix style text files
;;;3381   	* Removed seek when no newline is found, since it isn't necessary
;;;3382   -------------------------------------------------------------------*/
;;;3383   char *FAT_fgets(char *tgtBuffer, int num, FAT_FILE* file) 
;;;3384   { 
;;;3385   	u32 curPos;
;;;3386   	u32 readLength;
;;;3387   	char *returnChar;
;;;3388   	
;;;3389   	// invalid filehandle 
;;;3390   	if (file == NULL)
;;;3391   	{
;;;3392   		return NULL ; 
;;;3393   	}
;;;3394   	
;;;3395   	// end of file 
;;;3396   	if (FAT_feof(file)==true)
;;;3397   	{
;;;3398   		return NULL ; 
;;;3399   	}
;;;3400   	
;;;3401   	// save current position 
;;;3402   	curPos = FAT_ftell(file); 
;;;3403   	
;;;3404   	// read the full buffer (max string chars is num-1 and one end of string \0 
;;;3405   	readLength = FAT_fread(tgtBuffer,1,num-1,file) ; 
;;;3406   	
;;;3407   	// mark least possible end of string 
;;;3408   	tgtBuffer[readLength] = '\0' ;    
;;;3409   	
;;;3410   	if (readLength==0) { 
;;;3411   		// return error 
;;;3412   		return NULL ; 
;;;3413   	}
;;;3414   	
;;;3415   	// get position of first return '\r' 
;;;3416   	returnChar = strchr(tgtBuffer,'\r'); 
;;;3417   	
;;;3418   	// if no return is found, search for a newline
;;;3419   	if (returnChar == NULL)
;;;3420   	{
;;;3421   		returnChar = strchr(tgtBuffer,'\n');
;;;3422   	}
;;;3423   	
;;;3424   	// Mark the return, if existant, as end of line/string 
;;;3425   	if (returnChar!=NULL) { 
;;;3426   		*returnChar++ = 0 ; 
;;;3427   		if (*returnChar=='\n') { // catch newline too when jumping over the end 
;;;3428   			// return to location after \r\n (strlen+2) 
;;;3429   			FAT_fseek(file,curPos+strlen(tgtBuffer)+2,SEEK_SET) ; 
;;;3430   			return tgtBuffer ; 
;;;3431   		} else { 
;;;3432   			// return to location after \r (strlen+1) 
;;;3433   			FAT_fseek(file,curPos+strlen(tgtBuffer)+1,SEEK_SET) ; 
;;;3434   			return tgtBuffer ; 
;;;3435   		}
;;;3436   	}
;;;3437   	
;;;3438   	return tgtBuffer ; 
;;;3439   }
;;;3440   
;;;3441   /*-----------------------------------------------------------------
;;;3442   FAT_fputs (const char *string, FAT_FILE* file)
;;;3443   Writes string to file, excluding end of string character
;;;3444   const char *string IN: string to write
;;;3445   FAT_FILE* file IN: Handle of open file
;;;3446   bool return OUT: number of characters written if successful,
;;;3447   	EOF if not
;;;3448   
;;;3449     Written by MightyMax
;;;3450     Modified by Chishm - 2005-11-17
;;;3451   	* Uses FAT_FILE instead of int
;;;3452   	* writtenBytes is now u32 instead of int
;;;3453   -------------------------------------------------------------------*/
;;;3454   int FAT_fputs (const char *string, FAT_FILE* file) 
;;;3455   { 
;;;3456      u32 writtenBytes;
;;;3457   	// save string except end of string '\0' 
;;;3458      writtenBytes = FAT_fwrite((void *)string, 1, strlen(string), file); 
;;;3459   
;;;3460      // check if we had an error 
;;;3461      if (writtenBytes != strlen(string)) 
;;;3462      { 
;;;3463         // return EOF error 
;;;3464         return EOF;
;;;3465      }
;;;3466   
;;;3467      // return the charcount written 
;;;3468      return writtenBytes ; 
;;;3469   }
;;;3470   
;;;3471   
;;;3472   
;;;3473   #endif
        AREA |C$$constdata|, DATA, READONLY

|x$constdata|
lfn_offset_table
        DCB      0x01,0x03,0x05,0x07
        DCB      0x09,0x0e,0x10,0x12
        DCB      0x14,0x16,0x18,0x1c
        DCB      0x1e,00,00,00

        AREA |C$$data|, DATA

|x$dataseg|
lfnExists
        DCD      00000000
filesysRootDir
        DCD      00000000
filesysRootDirClus
        DCD      00000000
filesysFAT
        DCD      00000000
filesysSecPerFAT
        DCD      00000000
filesysNumSec
        DCD      00000000
filesysData
        DCD      00000000
filesysBytePerSec
        DCD      00000000
filesysSecPerClus
        DCD      00000000
filesysBytePerClus
        DCD      00000000
filesysType
        DCB      00,00,00,00
fatLastCluster
        DCD      00000000
fatFirstFree
        DCD      00000000
fatBufferCurSector
        DCD      00000000
curWorkDirCluster
        DCD      00000000
wrkDirCluster
        DCD      00000000
wrkDirSector
        DCD      00000000
wrkDirOffset
        DCD      00000000


        END
