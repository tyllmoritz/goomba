#include "includes.h"

#define page_size (16)
#define page_size_2 (page_size*1024)

u8 *const bank_0=(u8*)0x0600C000;
u8 *const bank_1=(u8*)0x06014000;

int cache_queue_cursor;
u16 prgcache[MAX_CACHE_SIZE];
u8* cachebase;
u8 cachepages;
u32* pageoffsets;

u8 *make_instant_pages(u8* rom_base)
{
	//this is for cases where there is no caching!
	u32 *p=(u32*)rom_base;
	int num_pages;
	int page_mask;
	int i;
	if (*p==TRIM)
	{
		p+=2;
//		num_pages=p[0]/4-8;
//		page_mask=num_pages-1;
		for (i=0;i<256;i++)
		{
			INSTANT_PAGES[i]=rom_base+p[i];//&page_mask];
		}
	}
	else
	{
//		num_pages=(2<<rom_base[148]);
//		page_mask=num_pages-1;
		for (i=0;i<256;i++)
		{
			INSTANT_PAGES[i]=rom_base+16384*(i);//&page_mask);
		}
	}
	return INSTANT_PAGES[0];
}

void init_cache(u8* gb_header)
{
	int i;
	u8* dest=(u8*)&Image$$RO$$Limit;
	u8 *end_of_cache=(u8*)(&END_OF_EXRAM);
	
	cachebase=dest;
	cachepages=(end_of_cache-cachebase)/page_size_2;
	//set up cache locations, first few are sequential
	for (i=0;i<cachepages;i++)
	{
		cache_location[i]=cachebase+page_size_2*i;
	}
	//two extra pages
	cache_location[i++]=bank_0;
	cachepages+=1;
	clear_instant_prg();
	flushcache();
	usingcache=1;
//	usingcompcache=0;
}

void flushcache()
{
	int i;

	for (i=0;i<cachepages;i++)
	{
		prgcache[i]=65535;
	}
	cache_queue_cursor=0;
}

void clear_instant_prg()
{
	int i;
	int l = 256;
	u32 *instant_prg = (u32*)INSTANT_PAGES;
	for (i=0;i<l;i++)
	{
		instant_prg[i]=0xC0000000;
	}
}

void regenerate_instant_prg()
{
	int i;
	int w;//within 16k
	u8**instant_prg=INSTANT_PAGES;

	for (i=0;i<cachepages;i++)
	{
		int p=prgcache[i];
		if (p<256)
		{
			instant_prg[p]=cache_location[i];
		}
	}
}

void getbank(int kilobyte)
{
	int bank;
	u32 i,j;
	int slotcontent,slotcontent2;
//	u8 *src, *dest;
	u8 *dest;
	u8 *banks=g_bank6;
	bank=kilobyte/page_size;
	
	//page is in cache?
	for (i=0;i<cachepages;i++)
	{
		if (prgcache[i]==bank)
		{
			return;
		}
	}
	
slot_is_locked:
	i=cache_queue_cursor;
	cache_queue_cursor++;
	slotcontent=prgcache[i];
	if (cache_queue_cursor>=cachepages) cache_queue_cursor=0;

	for (j=0;j<2;j++)
	{
		if (slotcontent!=65535)
		{
			if (banks[j]*8/page_size==slotcontent)
			{
				goto slot_is_locked;
			}
		}
	}
	prgcache[i]=bank;

#if 0
	if (usingcompcache)
	{
		int srcoffset;
		srcoffset = 16 + pageoffsets[bank];
//		dest = (u8*)06014000;
//		FAT_fseek(rom_file,srcoffset,SEEK_SET);
//		src=FAT_fread_16(dest,1,16384,rom_file);

		dest = cachebase+0x4000*cachepages;
		FAT_fseek(rom_file,srcoffset,SEEK_SET);
		FAT_fread(dest,1,16384,rom_file);
		src=dest;
		dest =cachebase+0x4000*i;
		depack(src,dest);
	}
	else
#endif
	{
		if (usinggbamp)
		{
			FAT_fseek(rom_file, 16 + bank*page_size_2,SEEK_SET);
			dest =cache_location[i];
			FAT_fread(dest,1,page_size_2,rom_file);
		}
		else
		{
			dest =cache_location[i];
			memcpy(dest,romstart+bank*page_size_2,page_size_2);
		}
	}
	return;
}

void get_rom_map()
{
	u8* banks=g_bank6;
	u8**srammap =(g_memmap_tbl)+3;
	u8**instant_prg = g_instant_prg_banks;
	int i;

	for (i=0;i<2;i++)
	{
		if (banks[i]<65535)
		{
			srammap[i]=instant_prg[banks[i]]-(3+i)*8192;
		}
	}
}
void update_cache()
{
	//updates the cache's state, and all the lookup tables
	//also fixes the memory map and vram map
	u8* banks=g_bank6;
	int i;

	clear_instant_prg();
	for (i=0;i<2;i++)
	{
		if (banks[i]<65535)
		{
			getbank(banks[i]*16);
		}
	}
	regenerate_instant_prg();
	get_rom_map();
}

