; generated by Norcroft  Thumb C vsn 1.20 (ARM Ltd SDT2.50) [Build number 80]


|x$codeseg| DATA

;;;1      #include "gba.h"
;;;2      #include <string.h>
;;;3      
;;;4      extern u32 num_speedhacks;
;;;5      extern u16 speedhacks[256];
;;;6      extern u8 g_hackflags;
;;;7      
;;;8      const u8 instructions_with_size_2[]={
;;;9      0x06,0x0E,0x16,0x18,0x1E,0x20,0x26,0x28,0x2E,0x30,0x36,0x38,0x3E,0xC6,0xCB,0xCE,
;;;10     0xD6,0xDE,0xE0,0xE6,0xE8,0xEE,0xF0,0xF6,0xF8,0xFE
;;;11     };
;;;12     const u8 instructions_with_size_3[]={
;;;13     0x01,0x08,0x11,0x21,0x31,0xC2,0xC3,0xC4,0xCA,0xCC,0xCD,0xD2,0xD4,0xDA,0xDC,0xEA,0xFA
;;;14     };
;;;15     
;;;16     const u8 whitelist[]={
;;;17     5,4,
;;;18     0xF0,0x41,0xE6,0x02, //lcd status polling
;;;19     0xF0,0x41,0xE6,0x03,
;;;20     0xF0,0x41,0xE6,0x04,
;;;21     0xF0,0x41,0xCB,0x4F,
;;;22     0xF0,0x41,0xCB,0x57,
;;;23     1,2,
;;;24     0xF0,0x44, //scanline polling
;;;25     0
;;;26     };
;;;27     
;;;28     const u8 graylist[]={
;;;29     18,1,
;;;30     0xDC, //call
;;;31     0xD4,
;;;32     0xC4,
;;;33     0xCC,
;;;34     0xCD,
;;;35     0xC7, //rst
;;;36     0xCF,
;;;37     0xD7,
;;;38     0xDF,
;;;39     0xE7,
;;;40     0xEF,
;;;41     0xF7,
;;;42     0xFF,
;;;43     0x23, //inc hl
;;;44     0x09, //add hl,*
;;;45     0x19,
;;;46     0x29,
;;;47     0x39,
;;;48     0
;;;49     };
;;;50     
;;;51     
;;;52     const u8 blacklist[]={
;;;53     14,1,
;;;54     0xE8, //anything that affects SP
;;;55     0x3B,
;;;56     0x33,
;;;57     0xF9,
;;;58     0x31,
;;;59     0xF8,
;;;60     0xC3, //unconditional jr,jp,ret
;;;61     0x18,
;;;62     0xC9,
;;;63     0x76, //halt
;;;64     0x2A, //ldi, ldd
;;;65     0x22,
;;;66     0x3A,
;;;67     0x32,
;;;68     6,3,
;;;69     0x0B,0x78,0xB1, //dec rr, ld a,r, or r
;;;70     0x0B,0x79,0xB0,
;;;71     0x1B,0x7A,0xB3,
;;;72     0x1B,0x7B,0xB2,
;;;73     0x2B,0x7C,0xB5,
;;;74     0x2B,0x7D,0xB4,
;;;75     29,2,
;;;76     0xF0,0x4D, //double speed polling
;;;77     0x3D,0xC2, //dec r, jr *,*
;;;78     0x3D,0xCA,
;;;79     0x3D,0x20,
;;;80     0x3D,0x28,
;;;81     0x05,0xC2,
;;;82     0x05,0xCA,
;;;83     0x05,0x20,
;;;84     0x05,0x28,
;;;85     0x0D,0xC2,
;;;86     0x0D,0xCA,
;;;87     0x0D,0x20,
;;;88     0x0D,0x28,
;;;89     0x15,0xC2,
;;;90     0x15,0xCA,
;;;91     0x15,0x20,
;;;92     0x15,0x28,
;;;93     0x1D,0xC2,
;;;94     0x1D,0xCA,
;;;95     0x1D,0x20,
;;;96     0x1D,0x28,
;;;97     0x25,0xC2,
;;;98     0x25,0xCA,
;;;99     0x25,0x20,
;;;100    0x25,0x28,
;;;101    0x2D,0xC2,
;;;102    0x2D,0xCA,
;;;103    0x2D,0x20,
;;;104    0x2D,0x28,
;;;105    0
;;;106    };
;;;107    
;;;108    //jp
;;;109    const u8 jplist[]= {
;;;110    0xC2,
;;;111    //0xC3,
;;;112    0xCA,
;;;113    0xD2,
;;;114    0xDA
;;;115    //0xE9
;;;116    };
;;;117    //jr
;;;118    const u8 jrlist[]= {
;;;119    //0x18
;;;120    0x20,
;;;121    0x28,
;;;122    0x30,
;;;123    0x38
;;;124    };
;;;125    
;;;126    extern u8* romstart;
;;;127    
;;;128    #define binsearch(xxxx,yyyy) binsearch_(xxxx,yyyy,sizeof(xxxx)/sizeof(u8))
;;;129         
;;;130    int binsearch_(const u8* list, u8 lookfor, size_t listsize)
;;;131    {
000000                      binsearch_
000000  b490                        PUSH     {r4,r7}
;;;132    	int i,l=0,r=listsize;
000002  2700                        MOV      r7,#0
000004  1c13                        MOV      r3,r2
                            F1L4
;;;133    	do
;;;134    	{
;;;135    		i=(l+r)/2;
000006  18fa                        ADD      r2,r7,r3
000008  d500                        BPL      F1L19
00000a  3201                        ADD      r2,#1
                            F1L19
00000c  1052                        ASR      r2,#1
;;;136    		if (list[i]==lookfor) return i;
00000e  5c84                        LDRB     r4,[r0,r2]
000010  428c                        CMP      r4,r1
000012  d102                        BNE      F1L20
000014  1c10                        MOV      r0,r2
                            F1L17
000016  bc90                        POP      {r4,r7}
000018  4770                        BX       lr
                            F1L20
;;;137    		else if (list[i]>lookfor)
00001a  428c                        CMP      r4,r1
00001c  dd01                        BLE      F1L21
;;;138    		{
;;;139    			r=i-1;
00001e  1e53                        SUB      r3,r2,#1
000020  e000                        B        F1L22
                            F1L21
;;;140    		}
;;;141    		else
;;;142    		{
;;;143    			l=i+1;
000022  1c57                        ADD      r7,r2,#1
                            F1L22
;;;144    		}
;;;145    	} while (l<=r);
000024  429f                        CMP      r7,r3
000026  ddee                        BLE      F1L4
;;;146    	return -1;
000028  2000                        MOV      r0,#0
00002a  43c0                        MVN      r0,r0
00002c  e7f3                        B        F1L17

;;;147    }
;;;148    
;;;149    int instruction_size(u8 instruction)
;;;150    {
00002e                      instruction_size
00002e  b590                        PUSH     {r4,r7,lr}
;;;151    	int i=binsearch(instructions_with_size_2,instruction);
000030  1c01                        MOV      r1,r0
000032  1c07                        MOV      r7,r0
000034  480b                        LDR      r0,F2L1
000036  221a                        MOV      r2,#&1a
000038  f7ff ffe2                   BL       binsearch_
;;;152    	if (i>-1) return 2;
00003c  2400                        MOV      r4,#0
00003e  43e4                        MVN      r4,r4
000040  42a0                        CMP      r0,r4
000042  dd03                        BLE      F2L12
000044  2002                        MOV      r0,#2
                            F2L10
000046  bc90                        POP      {r4,r7}
000048  bc08                        POP      {r3}
00004a  4718                        BX       r3
                            F2L12
;;;153    	i=binsearch(instructions_with_size_3,instruction);
00004c  1c39                        MOV      r1,r7
00004e  2211                        MOV      r2,#&11
000050  4805                        LDR      r0,F2L1+4
000052  f7ff ffd5                   BL       binsearch_
;;;154    	if (i>-1) return 3;
000056  42a0                        CMP      r0,r4
000058  dd01                        BLE      F2L13
00005a  2003                        MOV      r0,#3
00005c  e7f3                        B        F2L10
                            F2L13
;;;155    	return 1;
00005e  2001                        MOV      r0,#1
000060  e7f1                        B        F2L10
000062  0000                        LSL      r0,#0
                            F2L1
000064  00000000                    DCD      |x$constdata|
000068  0000001a                    DCD      |x$constdata|+26

;;;156    }
;;;157    
;;;158    
;;;159    //returns 1 or 0
;;;160    int match(const u8 *mem, const u8* patterns, int startaddr, int length)
;;;161    {
00006c                      match
00006c  b5ff                        PUSH     {r0-r7,lr}
00006e  b085                        SUB      sp,#&14
;;;162    	int addrbase;
;;;163    	int addrend;
;;;164    	int addr;
;;;165    	const u8 *pattern;
;;;166    	int p;
;;;167    	int numpatterns;
;;;168    	int onpattern;
;;;169    	int patternstart=0;
;;;170    	int patternlength;
;;;171    	
;;;172    	numpatterns=patterns[patternstart];
000070  9906                        LDR      r1,[sp,#&18]
;;;173    	patternstart++;
000072  1c07                        MOV      r7,r0
000074  7809                        LDRB     r1,[r1,#0]   ;;;172
000076  2001                        MOV      r0,#1
000078  9102                        STR      r1,[sp,#8]   ;;;172
00007a  e037                        B        F3L29
                            F3L4
;;;174    	while (numpatterns!=0)
;;;175    	{
;;;176    		patternlength=patterns[patternstart];
00007c  9906                        LDR      r1,[sp,#&18]
00007e  5c0d                        LDRB     r5,[r1,r0]
;;;177    		patternstart++;
000080  3001                        ADD      r0,#1
000082  9000                        STR      r0,[sp,#0]
;;;178    		for (onpattern=0; onpattern<numpatterns; onpattern++)
000084  9b08                        LDR      r3,[sp,#&20]
000086  2000                        MOV      r0,#0
000088  9a07                        LDR      r2,[sp,#&1c]
00008a  9001                        STR      r0,[sp,#4]
00008c  18d0                        ADD      r0,r2,r3
00008e  1b40                        SUB      r0,r5
000090  9004                        STR      r0,[sp,#&10]
000092  e022                        B        F3L30
                            F3L6
;;;179    		{
;;;180    			pattern=&(patterns[patternstart]);
000094  9800                        LDR      r0,[sp,#0]
000096  9906                        LDR      r1,[sp,#&18]
;;;181    			addrend=startaddr+length-patternlength;
;;;182    			for (addrbase=startaddr; addrbase<addrend; addrbase+=instruction_size(mem[addrbase]))
000098  9c07                        LDR      r4,[sp,#&1c]
00009a  180e                        ADD      r6,r1,r0   ;;;180
00009c  9804                        LDR      r0,[sp,#&10]   ;;;181
00009e  9003                        STR      r0,[sp,#&c]   ;;;181
0000a0  e012                        B        F3L31
                            F3L8
;;;183    			{
;;;184    				addr=addrbase;
;;;185    				p=0;
0000a2  2000                        MOV      r0,#0
0000a4  1c21                        MOV      r1,r4
0000a6  e001                        B        F3L32
                            F3L10
;;;186    				while (mem[addr]==pattern[p] && p<patternlength)
;;;187    				{
;;;188    					p++;
;;;189    					addr++;
0000a8  3001                        ADD      r0,#1
0000aa  3101                        ADD      r1,#1
                            F3L32
0000ac  5c7a                        LDRB     r2,[r7,r1]   ;;;186
0000ae  5c33                        LDRB     r3,[r6,r0]   ;;;186
0000b0  429a                        CMP      r2,r3   ;;;186
0000b2  d101                        BNE      F3L33   ;;;186
0000b4  42a8                        CMP      r0,r5   ;;;186
0000b6  dbf7                        BLT      F3L10   ;;;186
                            F3L33
;;;190    				}
;;;191    				if (p==patternlength)
0000b8  42a8                        CMP      r0,r5
0000ba  d101                        BNE      F3L34
;;;192    				{
;;;193    					return 1;
0000bc  2001                        MOV      r0,#1
0000be  e019                        B        F3L35
                            F3L34
0000c0  5d38                        LDRB     r0,[r7,r4]   ;;;182
0000c2  f7ff ffb4                   BL       instruction_size   ;;;182
0000c6  1904                        ADD      r4,r0,r4   ;;;182
                            F3L31
0000c8  9803                        LDR      r0,[sp,#&c]   ;;;182
0000ca  4284                        CMP      r4,r0   ;;;182
0000cc  dbe9                        BLT      F3L8   ;;;182
;;;194    				}
;;;195    			}
;;;196    			patternstart+=patternlength;
0000ce  9800                        LDR      r0,[sp,#0]
0000d0  1940                        ADD      r0,r5
0000d2  9000                        STR      r0,[sp,#0]
0000d4  9801                        LDR      r0,[sp,#4]   ;;;178
0000d6  3001                        ADD      r0,#1   ;;;178
0000d8  9001                        STR      r0,[sp,#4]   ;;;178
                            F3L30
0000da  9801                        LDR      r0,[sp,#4]   ;;;178
0000dc  9902                        LDR      r1,[sp,#8]   ;;;178
0000de  4288                        CMP      r0,r1   ;;;178
0000e0  dbd8                        BLT      F3L6   ;;;178
;;;197    		}
;;;198    		numpatterns=patterns[patternstart];
0000e2  9800                        LDR      r0,[sp,#0]
0000e4  9906                        LDR      r1,[sp,#&18]
0000e6  5c09                        LDRB     r1,[r1,r0]
;;;199    		patternstart++;
0000e8  3001                        ADD      r0,#1
0000ea  9102                        STR      r1,[sp,#8]   ;;;198
                            F3L29
0000ec  9902                        LDR      r1,[sp,#8]   ;;;174
0000ee  2900                        CMP      r1,#0   ;;;174
0000f0  d1c4                        BNE      F3L4   ;;;174
;;;200    	}
;;;201    	return 0;
0000f2  2000                        MOV      r0,#0
                            F3L35
0000f4  b009                        ADD      sp,#&24
0000f6  bcf0                        POP      {r4-r7}
0000f8  bc08                        POP      {r3}
0000fa  4718                        BX       r3

;;;202    }
;;;203    
;;;204    //returns 0-7, bit 0 = wl, bit 1 = gl, bit 2 = bl
;;;205    int hacktest(const u8 *mem, int startaddr, int length)
;;;206    {
0000fc                      hacktest
0000fc  b5fe                        PUSH     {r1-r7,lr}
;;;207    	int wl,gl,bl;
;;;208    	//verify if even adds up to the branch again...
;;;209    	int i,addthis;
;;;210    	i=startaddr;
0000fe  1c0e                        MOV      r6,r1
000100  1c0f                        MOV      r7,r1
000102  1889                        ADD      r1,r2
000104  9101                        STR      r1,[sp,#4]
000106  3901                        SUB      r1,#1
000108  1c14                        MOV      r4,r2
00010a  1c05                        MOV      r5,r0
00010c  9102                        STR      r1,[sp,#8]
00010e  e003                        B        F4L17
                            F4L4
;;;211    	while (i<startaddr+length-1)
;;;212    	{
;;;213    		addthis=instruction_size(mem[i]);
000110  5da8                        LDRB     r0,[r5,r6]
000112  f7ff ff8c                   BL       instruction_size
;;;214    		i+=addthis;
000116  1836                        ADD      r6,r0
                            F4L17
000118  9902                        LDR      r1,[sp,#8]   ;;;211
00011a  42b1                        CMP      r1,r6   ;;;211
00011c  dcf8                        BGT      F4L4   ;;;211
;;;215    	}
;;;216    	if (i!=startaddr+length || addthis!=2)
00011e  9901                        LDR      r1,[sp,#4]
000120  42b1                        CMP      r1,r6
000122  d101                        BNE      F4L18
000124  2802                        CMP      r0,#2
000126  d001                        BEQ      F4L19
                            F4L18
;;;217    	{
;;;218    		return 6;
000128  2006                        MOV      r0,#6
00012a  e018                        B        F4L20
                            F4L19
;;;219    	}
;;;220    	wl=match(mem,whitelist,startaddr,length);
00012c  1c3a                        MOV      r2,r7
00012e  1c23                        MOV      r3,r4
000130  1c28                        MOV      r0,r5
000132  490c                        LDR      r1,F4L1
000134  f7ff ff9a                   BL       match
;;;221    	gl=match(mem,graylist,startaddr,length);
000138  1c3a                        MOV      r2,r7
00013a  1c23                        MOV      r3,r4
00013c  1c06                        MOV      r6,r0
00013e  1c28                        MOV      r0,r5
000140  4909                        LDR      r1,F4L1+4
000142  f7ff ff93                   BL       match
000146  9000                        STR      r0,[sp,#0]
;;;222    	bl=match(mem,blacklist,startaddr,length);
000148  1c3a                        MOV      r2,r7
00014a  1c23                        MOV      r3,r4
00014c  1c28                        MOV      r0,r5
00014e  4907                        LDR      r1,F4L1+8
000150  f7ff ff8c                   BL       match
;;;223    	return (wl+bl*2+gl*4);
000154  0041                        LSL      r1,r0,#1
000156  9800                        LDR      r0,[sp,#0]
000158  1989                        ADD      r1,r6
00015a  0080                        LSL      r0,#2
00015c  1808                        ADD      r0,r1,r0
                            F4L20
00015e  bcfe                        POP      {r1-r7}
000160  bc08                        POP      {r3}
000162  4718                        BX       r3
                            F4L1
000164  0000002b                    DCD      |x$constdata|+43
000168  00000046                    DCD      |x$constdata|+70
00016c  0000005b                    DCD      |x$constdata|+91

;;;224    }
;;;225    
;;;226    void cpuhack_reset();
;;;227    
;;;228    void find_speedhacks()
;;;229    {
000170                      find_speedhacks
000170  b5f0                        PUSH     {r4-r7,lr}
;;;230    	const u8* mem=romstart;
000172  4824                        LDR      r0,F5L1
;;;231    	u8 i1;
;;;232    	s8 rel;
;;;233    	int h;
;;;234    	int matched;
;;;235    	int addr;
;;;236    	num_speedhacks=0;
000174  4924                        LDR      r1,F5L1+4
000176  6804                        LDR      r4,[r0,#0]
000178  2000                        MOV      r0,#0
;;;237    	if (g_hackflags&2)
00017a  4d24                        LDR      r5,F5L1+8
00017c  6008                        STR      r0,[r1,#0]
00017e  7828                        LDRB     r0,[r5,#0]
000180  0882                        LSR      r2,r0,#2
000182  d302                        BCC      F5L31
;;;238    	{
;;;239    		g_hackflags=g_hackflags&~2;
000184  2302                        MOV      r3,#2
000186  4398                        BIC      r0,r3
000188  e036                        B        F5L32
                            F5L31
;;;240    		cpuhack_reset();
;;;241    		return;
;;;242    	}
;;;243    	
;;;244    	//just JR hacks for now, ignore JP
;;;245    	for (addr=0x0;addr<16383;addr++)
00018a  2700                        MOV      r7,#0
                            F5L6
;;;246    	{
;;;247    		i1 = mem[addr];
00018c  5de1                        LDRB     r1,[r4,r7]
;;;248    		if (binsearch(jrlist,i1)!=-1)
00018e  4820                        LDR      r0,F5L1+12
000190  2204                        MOV      r2,#4
000192  f7ff ff35                   BL       binsearch_
000196  2301                        MOV      r3,#1
000198  42d8                        CMN      r0,r3
00019a  d022                        BEQ      F5L33
;;;249    		{
;;;250    			rel= ((s8*)mem)[addr+1];
00019c  19e0                        ADD      r0,r4,r7
00019e  56c0                        LDSB     r0,[r0,r3]
;;;251    			if (-rel <= 11 && -rel > 2)
0001a0  1f19                        SUB      r1,r3,#4
0001a2  1a09                        SUB      r1,r0
0001a4  2908                        CMP      r1,#8
0001a6  d81c                        BHI      F5L34
;;;252    			{
;;;253    				h=hacktest(mem,addr+2+rel,-rel);
0001a8  1839                        ADD      r1,r7,r0
0001aa  4242                        NEG      r2,r0
0001ac  1c20                        MOV      r0,r4
0001ae  3102                        ADD      r1,#2
0001b0  1c0e                        MOV      r6,r1
0001b2  f7ff ffa3                   BL       hacktest
;;;254    				matched=1;
0001b6  2101                        MOV      r1,#1
;;;255    				if (h&4) matched=0;
0001b8  08c2                        LSR      r2,r0,#3
0001ba  d300                        BCC      F5L35
0001bc  2100                        MOV      r1,#0
                            F5L35
;;;256    				if (h&2) matched=0;
0001be  0882                        LSR      r2,r0,#2
0001c0  d300                        BCC      F5L36
0001c2  2100                        MOV      r1,#0
                            F5L36
;;;257    				if (h&1) matched=0;
0001c4  0840                        LSR      r0,#1
0001c6  d20c                        BCS      F5L37
;;;258    				if (matched && num_speedhacks<256)
0001c8  2900                        CMP      r1,#0
0001ca  d00a                        BEQ      F5L33
0001cc  490e                        LDR      r1,F5L1+4
0001ce  23ff                        MOV      r3,#&ff
0001d0  6808                        LDR      r0,[r1,#0]
0001d2  3301                        ADD      r3,#1
0001d4  4298                        CMP      r0,r3
0001d6  d204                        BCS      F5L37
;;;259    				{
;;;260    					speedhacks[num_speedhacks]=addr+2+rel;
0001d8  0042                        LSL      r2,r0,#1
0001da  4b0e                        LDR      r3,F5L1+16
;;;261    					num_speedhacks++;
0001dc  3001                        ADD      r0,#1
0001de  529e                        STRH     r6,[r3,r2]   ;;;260
0001e0  6008                        STR      r0,[r1,#0]
                            F5L33
                            F5L34
                            F5L37
0001e2  4b0d                        LDR      r3,F5L1+20   ;;;245
0001e4  3701                        ADD      r7,#1   ;;;245
0001e6  429f                        CMP      r7,r3   ;;;245
0001e8  dbd0                        BLT      F5L6   ;;;245
;;;262    				}
;;;263    				
;;;264    			}
;;;265    		}
;;;266    	}
;;;267    	
;;;268    	if (num_speedhacks) g_hackflags|=2;
0001ea  4907                        LDR      r1,F5L1+4
0001ec  6808                        LDR      r0,[r1,#0]
0001ee  2800                        CMP      r0,#0
0001f0  d003                        BEQ      F5L38
0001f2  7828                        LDRB     r0,[r5,#0]
0001f4  2302                        MOV      r3,#2
0001f6  4318                        ORR      r0,r3
                            F5L32
0001f8  7028                        STRB     r0,[r5,#0]   ;;;239
                            F5L38
;;;269    	cpuhack_reset();
0001fa  f7ff ff01                   BL       cpuhack_reset
0001fe  bcf0                        POP      {r4-r7}
000200  bc08                        POP      {r3}
000202  4718                        BX       r3
                            F5L1
000204  00000000                    DCD      romstart
000208  00000000                    DCD      num_speedhacks
00020c  00000000                    DCD      g_hackflags
000210  000000c0                    DCD      |x$constdata|+192
000214  00000000                    DCD      speedhacks
000218  00003fff                    DCD      0x00003fff
;;;270    
;;;271    }
;;;272    
;;;273    
        AREA |C$$constdata|, DATA, READONLY

|x$constdata|
instructions_with_size_2
        DCB      0x06,0x0e,0x16,0x18
        DCB      0x1e,0x20,0x26,0x28
        DCB      0x2e,0x30,0x36,0x38
        DCB      0x3e,0xc6,0xcb,0xce
        DCB      0xd6,0xde,0xe0,0xe6
        DCB      0xe8,0xee,0xf0,0xf6
        DCB      0xf8,0xfe
instructions_with_size_3
        DCB      0x01,0x08,0x11,0x21
        DCB      0x31,0xc2,0xc3,0xc4
        DCB      0xca,0xcc,0xcd,0xd2
        DCB      0xd4,0xda,0xdc,0xea
        DCB      0xfa
whitelist
        DCB      0x05,0x04,0xf0,0x41
        DCB      0xe6,0x02,0xf0,0x41
        DCB      0xe6,0x03,0xf0,0x41
        DCB      0xe6,0x04,0xf0,0x41
        DCB      0xcb,0x4f,0xf0,0x41
        DCB      0xcb,0x57,0x01,0x02
        DCB      0xf0,0x44,00
graylist
        DCB      0x12,0x01,0xdc,0xd4
        DCB      0xc4,0xcc,0xcd,0xc7
        DCB      0xcf,0xd7,0xdf,0xe7
        DCB      0xef,0xf7,0xff,0x23
        DCB      0x09,0x19,0x29,0x39
        DCB      00
blacklist
        DCB      0x0e,0x01,0xe8,0x3b
        DCB      0x33,0xf9,0x31,0xf8
        DCB      0xc3,0x18,0xc9,0x76
        DCB      0x2a,0x22,0x3a,0x32
        DCB      0x06,0x03,0x0b,0x78
        DCB      0xb1,0x0b,0x79,0xb0
        DCB      0x1b,0x7a,0xb3,0x1b
        DCB      0x7b,0xb2,0x2b,0x7c
        DCB      0xb5,0x2b,0x7d,0xb4
        DCB      0x1d,0x02,0xf0,0x4d
        DCB      0x3d,0xc2,0x3d,0xca
        DCB      0x3d,0x20,0x3d,0x28
        DCB      0x05,0xc2,0x05,0xca
        DCB      0x05,0x20,0x05,0x28
        DCB      0x0d,0xc2,0x0d,0xca
        DCB      0x0d,0x20,0x0d,0x28
        DCB      0x15,0xc2,0x15,0xca
        DCB      0x15,0x20,0x15,0x28
        DCB      0x1d,0xc2,0x1d,0xca
        DCB      0x1d,0x20,0x1d,0x28
        DCB      0x25,0xc2,0x25,0xca
        DCB      0x25,0x20,0x25,0x28
        DCB      0x2d,0xc2,0x2d,0xca
        DCB      0x2d,0x20,0x2d,0x28
        DCB      00
jplist
        DCB      0xc2,0xca,0xd2,0xda
jrlist
        DCB      0x20,0x28,0x30,0x38


        END
